<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL学习笔记（4）——优化</title>
      <link href="/mysql_04/"/>
      <url>/mysql_04/</url>
      
        <content type="html"><![CDATA[<h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><h3 id="数据库设计三大范式"><a href="#数据库设计三大范式" class="headerlink" title="数据库设计三大范式"></a>数据库设计三大范式</h3><ul><li>确保每列都是不可分割的原子项。</li><li>确保每列都和主键相关。</li><li>确保每列和主键直接相关，而不是间接相关。</li></ul><h3 id="使用合适的数据类型"><a href="#使用合适的数据类型" class="headerlink" title="使用合适的数据类型"></a>使用合适的数据类型</h3><ul><li>对于字符串，固定长度使用<code>char</code>，非固定长度使用<code>varchar</code>。对于InnoDB而言，推荐使用<code>varchar</code>。</li><li>对于小数，关于财务方面需要精确数据的，使用<code>decimal</code>，其他情况使用<code>float</code>或者<code>double</code>。</li><li>对于日期类型，尽量使用<code>timestamp</code>，它占用空间小且自动进行时区转换。</li><li>对于大数据，<code>text</code>只能存储字符型数据，<code>blob</code>可以存储二进制数据，例如图片。</li><li>尽可能使用<code>NOT NULL</code>定义字段。</li></ul><h3 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h3><ul><li>对经常使用<code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code>的字段建立索引，避免全表扫描。</li><li>对区分度高的字段建立索引，而例如性别等区分度低的字段不适合建立索引。</li><li>索引并不是建的越多越好，过多的索引会导致<code>INSERT</code>、<code>UPDATE</code>等写入操作的效率降低。</li><li>如果多个字段常用<code>AND</code>连接，应当建立联合索引，而不是单独为每个字段建立索引。</li></ul><h2 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h2><ol><li>客户端连接数据库，连接器进行<strong>权限验证</strong>；</li><li>客户端发送查询语句，MySQL首先会<strong>查询缓存</strong>中是否执行过该语句，如果命中则返回缓存的结果，否则进入下一步；</li><li>对输入的SQL语句进行<strong>语法分析</strong>，识别字符串为对象，检查SQL语句是否符合语法；</li><li><strong>优化器</strong>对SQL语句进行优化，比如存在多个索引时选择走哪一个索引，存在多表关联时选择表连接的顺序；</li><li><strong>执行器</strong>先验证权限，再调用引擎的接口，将符合条件的行保存在结果集合中。</li></ol><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ul><li>在<code>WHERE</code>子句中，应当避免使用函数、运算、不等号（<code>&lt;&gt;</code>或<code>!=</code>）、<code>OR</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>LIKE</code>查询以<code>%</code>开头，这些会导致索引失效。</li><li>注意使用同类型进行比较，字符串使用引号括起来。</li><li>使用联合索引注意最左前缀原则。</li><li>避免使用<code>SELECT *</code>，用具体的字段代替<code>*</code>。</li><li>存储引擎使用聚簇索引时，尽量利用覆盖索引提升查询性能。</li><li>使用<code>LIMIT</code>限制返回结果的数量。</li><li>避免使用子查询和<code>JOIN</code>。</li><li>使用<code>BETWEEN</code>代替<code>IN</code>。</li></ul><h3 id="EXPLAIN命令"><a href="#EXPLAIN命令" class="headerlink" title="EXPLAIN命令"></a>EXPLAIN命令</h3><p><code>explain SELECT ... FROM t WHERE ...</code>用于显示MySQL为SQL语句准备的执行计划，查看是否走了索引、走了什么样的索引，可以用于优化索引和查询语句。主要关注以下几条信息：</p><ul><li><code>type</code>：表示MySQL走的索引类型，常见的类型如下（按性能由好到差排列）：<ul><li><code>system</code>：表仅有一行，是<code>const</code>的特例。</li><li><code>const</code>：表最多有一个匹配行，将在查询开始时被读取。</li><li><code>eq_ref</code>：最多返回一条符合条件的记录，使用主键索引或者唯一索引时出现。</li><li><code>ref</code>：返回所有符合条件的记录，使用非主键索引、非唯一索引或者联合索引时出现。</li><li><code>range</code>：范围查找。</li><li><code>index</code>：遍历全索引树进行查找。</li><li><code>ALL</code>：全表查找。</li></ul></li><li><code>possible_keys</code>：若查询涉及到的字段上存在索引，则该索引被列出，但不一定被使用。</li><li><code>key</code>：实际使用的索引。</li><li><code>ref</code>：显示哪些字段或常量被用于查找索引列上的值。</li><li><code>rows</code>：估计需要读取的行数，这个值越小越好。</li><li><code>extra</code>：主要关心是否出现<code>Using index</code>，如果出现则表示使用了覆盖索引。</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><ul><li>垂直分表是按照字段的活跃性，把一个表中的字段拆分到不同的表中。</li><li>每个表的数据不同，每个表都有一列交集（一般为主键）用于关联数据，所有表的并集是全量数据。</li><li>字段较多，热门字段和非热门字段放在一起，单行数据占用空间大，查询时IO开销大，产生IO瓶颈。垂直分表减少了随机IO，但查询时需要获取多个表的数据来获得全部数据。</li></ul><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><ul><li>水平分表是将数据行按照一定策略（如Hash取模、时间戳等）拆分到多个表中。</li><li>水平分库是将数据行按照一定策略拆分到多个库中。每个库中数据的结构一致，且没有交集。</li><li>水平分库分表提升数据库整体的并发量和负载能力。</li><li>按照时间戳或者ID范围切分：<ul><li>单表大小可控，便于水平扩展，避免跨分片查询。</li><li>近期的热点数据被频繁读写，早期的数据很少被查询，使得热点数据成为性能瓶颈。</li></ul></li><li>Hash取模切分：<ul><li>数据分片均匀，不会造成并发访问的瓶颈。</li><li>后期集群扩容时，需要迁移旧的数据（使用一致性Hash算法可解决这类问题）；容易出现跨分片查询。</li></ul></li></ul><h3 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h3><ul><li><strong>UUID</strong>：优点：易于实现，本地生成。缺点：UUID占用大量存储空间且无序，在B+树索引上引起数据频繁变动。</li><li><strong>MySQL单独维护自增主键ID表</strong>：优点是易于实现。缺点：可用性低，容易成为性能瓶颈。</li><li><strong>设置自增步长的自增ID</strong>：优点是易于实现。缺点：后续扩容升级较为麻烦，也没有解决性能问题。</li><li><strong>Redis自增ID</strong>：Redis<code>incr</code>原子自增，高并发。缺点：RDB持久化容易丢失数据，AOF持久化损失性能。</li><li><strong>Snowflake</strong>：64位的<code>Long</code>型数字，其中第1位不使用，41位为毫秒级时间戳，5位为数据中心ID，5位为工作机器ID，12位为毫秒内的序列号。优点：自增，高性能，灵活。缺点：依赖强机器时钟。</li><li><strong>Leaf Segment</strong>：一次性批量获取自增ID号段，每台机器只使用本地缓存的ID，耗尽之后再去获取。优点：易于扩展，容灾性高。缺点：ID不够随机，大量请求可能造成阻塞。</li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul><li><strong>两阶段提交</strong>：分为协调者和参与者节点。<ul><li>第一阶段：协调者向所有的参与者发送事务预处理请求，开始等待各参与者的响应；各个参与者节点在本地执行事务操作，但不提交，而是向协调者报告它执行事务是否成功；</li><li>第二阶段：如果第一阶段所有参与者都报告本地事务执行成功，则告知所有参与者正式提交事务；如果有任何一个参与者报告事务失败或者超时，告知所有参与者回滚。</li></ul></li></ul><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主库负责写，从库负责读，这样即使主库需要锁表而不能读时，也能从从库读取保证业务正常进行；当主节点挂了，也能从从库中选取一个作为新的主节点。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li>Slave连接到Master，Master创建binlog dump线程。</li><li>Master的binlog发生变化时，dump线程会通知所有的Slave，并将binlog内容推送给Slave。</li><li>Slave执行<code>start slave</code>命令，创建IO线程用于从主节点接收binlog，将内容写到本地的relay log。</li><li>Slave的SQL线程负责读取relay log中的内容，解析成具体的操作并执行，保证主从数据的一致性。</li></ol><p>主从复制模式：</p><ul><li><strong>同步</strong>：Master等待所有的Slave都回应后才提交。</li><li><strong>半同步</strong>：Master等待至少一个Slave回应就可以提交。</li><li><strong>异步</strong>：Master不会等待Slave回应就提交。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> MySQL </tag>
            
            <tag> OLTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（3）——日志</title>
      <link href="/mysql_03/"/>
      <url>/mysql_03/</url>
      
        <content type="html"><![CDATA[<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><ul><li><code>redo log</code>是InnoDB存储引擎层面的实现，并非所有存储引擎都具备。</li><li><code>redo log</code>用于记录事务对数据页的修改。</li><li><code>redo log</code>采用WAL（Write-Ahead Log）技术，先将记录写入内存中的Redo Log Buffer，再在一定时机将缓存写入磁盘。</li><li><code>innodb_flush_log_at_trx_commit</code>参数用于设置<code>redo log</code>刷盘时机：<ul><li><code>0</code>：InnoDB线程每秒1次将Redo Log Buffer中的日志刷入磁盘。</li><li><code>1</code>：事务每次提交时就会把Redo Log Buffer中的日志写入磁盘。</li><li><code>2</code>：事务提交时仅写入OS Buffer，由InnoDB线程每秒1次将OS Buffer中的日志刷入磁盘。</li></ul></li><li><code>redo log</code>采用大小固定、循环写入的方式，当写到文件结尾时，回到文件头部循环写入日志。因此<code>redo log</code>无法记录完整的数据，必须配合<code>binlog</code>才能保证数据不丢失。</li><li><code>redo log</code>用于数据服务奔溃后的恢复。</li></ul><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><ul><li><code>undo log</code>记录数据的逻辑变化，例如当执行了一条<code>INSERT</code>语句，<code>undo log</code>会记录一条对应的<code>DELETE</code>语句，这样便于数据回滚到事务执行前的状态。</li><li><code>undo log</code>还用于MVCC。</li><li><code>undo log</code>保证事务的原子性。</li></ul><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><ul><li><code>binlog</code>是MySQL服务层的实现，因此所有存储引擎都能使用。</li><li><code>binlog</code>日志是二进制格式的，具有以下三种工作模式：<ul><li><code>Row Level</code>：日志会记录每一行数据被修改的情况，支持一些特殊功能（存储过程、触发器、函数），但会造成日志内容庞大。</li><li><code>Statement Level</code>：日志会记录对数据进行修改的SQL语句，减少了日志量，但不支持一些语句。是默认的工作模式。</li><li><code>Mixed</code>：混合以上两种模式，根据执行的具体语句判断使用哪种工作模式。</li></ul></li><li><code>binlog</code>是以追加写入的方式执行的，当一个bin log文件到达设置的最大值（<code>max_binlog_size</code>）时，会另生成新的文件来保存新的日志。</li><li><code>binlog</code>会在每次事务提交时写入内存，并在一定时机写入磁盘，通过<code>sync_binlog</code>参数设置刷盘时机，默认为<code>1</code>即每次提交事务的时候都进行刷盘，如果将此参数调大可以牺牲一定的一致性来提升性能。</li><li><code>binlog</code>主要用于MySQL主从复制，监听<code>binlog</code>能用于数据同步、作为实时计算引擎的数据源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> MySQL </tag>
            
            <tag> OLTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（2）——索引</title>
      <link href="/mysql_02/"/>
      <url>/mysql_02/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h3><p>MySQL索引默认的数据结构为B+树。</p><p>B+树是B树（Balance Tree）的进化版本，具有$O(log_2n)$的查找、插入、删除的时间复杂度，其设计目的是减少硬盘IO次数。</p><h4 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+树特点"></a>B+树特点</h4><ul><li>所有父节点元素出现在其子节点中，作为子节点的最大（或最小）元素。</li><li>所有的叶子节点位于同一层，节点中的元素从小到大排列，叶子结点之间按从小到大的顺序相互连接，形成了有序的链表。</li><li>非叶子节点不存储数据，仅作为索引，叶子节点存储了全部信息。</li></ul><h4 id="与其他结构比较"><a href="#与其他结构比较" class="headerlink" title="与其他结构比较"></a>与其他结构比较</h4><p>与B树相比：</p><ul><li>非叶子节点不存储数据，意味着中间节点可以容纳更多元素，因此B+树比B树更加矮胖，减少IO次数；</li><li>B树查询次数不稳定，B+树每一次查找都是稳定的；</li><li>叶子节点相对有序，且连接成链表，便于范围查找。</li></ul><p>相比于红黑树和AVL树，B+树深度小，因此需要较少IO的次数，并且红黑树等AVL树不能利用磁盘预读性能。</p><h4 id="B-树数据量"><a href="#B-树数据量" class="headerlink" title="B+树数据量"></a>B+树数据量</h4><ul><li>B+树叶子节点大小默认情况下等于一个磁盘页的大小（16KB），这样每个节点只需要一次IO就可以完全载入，并且可以利用磁盘预读的功能，加载该节点附近的数据，降低磁盘IO次数。</li><li>InnoDB中非叶子节点存放主键ID和指针，为<code>8+6=14B</code>，那么一个非叶子节点大约可以存放<code>16KB/14B=1170</code>个指针。假设一行记录的大小为1KB，一个叶子节点能存放16条记录，则3层高度的B+树能存放<code>1170*1170*16=21902400</code>条记录。</li></ul><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>Hash索引根据一定的映射函数找到表中数据的具体位置，具有<code>O(1)</code>的读写性能，但它是无序的，用于范围查找时需要全表查找。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>InnoDB会监控表上二级索引的查找，如果某二级索引被频繁访问，会在缓存池中建立哈希索引，可以提升查询性能，但只支持等值查询。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MySQL 5.6版本前只有MyISAM支持全文索引，之后InnoDB加入了对全文索引的支持。MySQL 5.7.6版本开始内置ngram全文解析器，支持中文分词。</p><p>全文索引基于倒排索引实现。</p><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li>从MySQL 5.5版本起作为默认的存储引擎。</li><li>支持事务，支持外键，支持行级锁，支持奔溃后的安全恢复。</li><li><strong>聚簇索引</strong>：InnoDB是聚簇索引，数据存放于主键索引的叶子节点上，辅助索引的叶子节点存放主键的值。走主键索引查询时性能很好，但走辅助索引时，先查询到主键，再返回主键索引去查找数据。</li><li><strong>覆盖索引</strong>：如果走辅助索引就能得到所要查询的全部信息，则无需回到主键索引去查询，可以减少IO操作，大幅提升性能。例如：<code>a</code>为主键索引、<code>b</code>为辅助索引，<code>SELECT a FROM table WHERE b=1</code>发生了覆盖索引，不需要回表查找。</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li>不支持事务，只支持表级锁，不支持外键，不支持奔溃后的安全恢复。</li><li><strong>非聚簇索引</strong>：MyISAM的索引和数据文件是分开的，主键索引和辅助索引的叶子节点存放的是指向数据文件物理地址的指针。</li></ul><h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><ul><li>MEMORY引擎数据全部存放在内存中，如果掉电就会失去所有数据，因此多用于临时表。</li><li>MEMORY引擎默认为Hash索引。</li></ul><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><ul><li>对表上多个列建立索引，本质上也是建立B+树，优先对建立联合索引的最左的列进行排序，当满足最左列的顺序时，才会依次按照第二列、第三列排序。</li><li>使用联合索引时需要满足最左前缀原则。例如创建<code>a,b,c</code>的联合索引，等同于创建了<code>a</code>、<code>a,b</code>、<code>a,b,c</code>的索引，此时部分情况会导致索引失效：<ul><li><code>SELECT id FROM t WHERE a = xxx AND b = yyy</code>——<code>a</code>和<code>b</code>的索引有效；</li><li><code>SELECT id FROM t WHERE a = xxx AND c = yyy</code>——仅<code>a</code>的索引有效；</li><li><code>SELECT id FROM t WHERE b = xxx AND c = yyy</code>——索引失效；</li><li><code>SELECT id FROM t WHERE a &gt; xxx AND b = yyy</code>——仅<code>a</code>的索引有效；</li><li><code>SELECT id FROM t WHERE b = xxx AND a = yyy</code>——<code>a</code>和<code>b</code>的索引有效。</li></ul></li></ul><h2 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h2><ul><li>联合索引，未满足最左前缀原则；</li><li>模糊查询，<code>LIKE</code>以<code>%</code>开头；</li><li>查询条件含有<code>OR</code>；</li><li><code>WHERE</code>条件含有运算、不等号、使用了函数。</li></ul><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><ul><li>每个表只能有一个主键，不允许为NULL。</li><li>一个字段只能在联合主键中出现一次，联合主键不能包含多余的不必要字段。</li><li>InnoDB采用聚簇索引，B+树的构建依赖于主键，因此InnoDB必须要有主键。如果没有手动指定主键，InnoDB会选择第一个非空的唯一索引作为主键，如果找不到这样的索引，会自动生成一个不可见的名为<code>row_id</code>的索引，它是一个6字节的自增数值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> MySQL </tag>
            
            <tag> OLTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（1）——事务</title>
      <link href="/mysql_01/"/>
      <url>/mysql_01/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是指在一系列操作中，所有的操作必须全部成功完成，一旦有一个操作失败，要撤销所有的更改。</p><h2 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h2><ul><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是不可分割的最小工作单位，一次事务中的所有操作要么全部成功提交，要么失败回滚，不可能只执行其中一部分操作。</li><li><strong>一致性</strong>（<code>Consistency</code>）：事务执行前后，数据库的完整性保持一致。</li><li><strong>隔离性</strong>（<code>Isolation</code>）：一个事务所作的修改在最终提交前对其他事务是不可见的。</li><li><strong>持久性</strong>（<code>Durability</code>）：事务一旦成功提交，更改会永久性地保存在数据库中，即使数据库故障，所做的修改也不丢失。</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="并发事务可能发生的问题"><a href="#并发事务可能发生的问题" class="headerlink" title="并发事务可能发生的问题"></a>并发事务可能发生的问题</h3><ul><li><strong>脏读</strong>：事务A修改数据之后还未提交，此时事务B读取数据，读取的是事务A修改后的数据，然后事务A失败回滚，此时B读到了脏数据。</li><li><strong>不可重复读</strong>：事务A读取某个数据后，再次读取该数据，发现读取的数据已经发生更改或者被删除。</li><li><strong>幻读</strong>：事务A查询某个范围的记录，此时事务B在该范围内插入新的记录/删除部分记录，A再次读取该范围的记录时，发现比原来多/少了几行记录。</li></ul><h3 id="MySQL支持的隔离级别"><a href="#MySQL支持的隔离级别" class="headerlink" title="MySQL支持的隔离级别"></a>MySQL支持的隔离级别</h3><ul><li><strong>未提交读</strong>（<code>READ UNCOMMITTED</code>）：可能出现脏读、不可重复读、幻读。</li><li><strong>提交读</strong>（<code>READ COMMITTED</code>）：解决脏读，可能出现不可重复读、幻读。</li><li><strong>可重复读</strong>（<code>REPEATABLE READ</code>）：解决脏读、不可重复读，可能出现幻读。是MySQL的默认隔离级别。InnoDB引擎通过多版本并发控制（MVCC）和<code>next-key lock</code>解决了幻读问题。</li><li><strong>串行化</strong>（<code>SERIALIZABLE</code>）：解决脏读、不可重复读、幻读。</li></ul><p>以上隔离级别的隔离强度逐渐变强，并发性能逐渐变差。</p><h3 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h3><ul><li><strong>共享锁</strong>：又称S锁，用于读的场景，当事务对记录加S锁，其他事务可以对该记录加S锁，但不能加X锁。<code>SELECT ... LOCK IN SHARE MODE</code>会为记录加S锁。</li><li><strong>排他锁</strong>：又称X锁，用于写的场景，当事务对记录加X锁，其他事务不能对该记录加任何锁，直到事务结束。<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT ... FOR UPDATE</code>会为记录加X锁。</li><li><strong>行锁</strong>：锁粒度细，占用更多资源，并发行能好。</li><li><strong>表锁</strong>：锁粒度粗，占用资源少，并发行能差，不会出现死锁。</li><li><strong>意向锁</strong>：分为意向共享锁（IS）和意向排他锁（IX），作用于表，当表里某个记录被加X锁，那么这个表就会自动获得IX锁，其他事务想要对该表加锁就只要先检测这个表是否被上了意向锁，无需对整个表进行遍历。</li><li><code>record lock</code>：即行锁，仅仅把一条记录加锁（S锁或X锁）。</li><li><strong>间隙锁</strong>（<code>gap lock</code>）：，锁住记录之间的间隙，防止其他事务在这个间隙中修改或插入记录。</li><li><code>next-key lock</code>：是<code>record lock</code>和<code>gap lock</code>的组合，用于RR隔离级别防止幻读。</li></ul><h3 id="MySQL隔离级别的实现"><a href="#MySQL隔离级别的实现" class="headerlink" title="MySQL隔离级别的实现"></a>MySQL隔离级别的实现</h3><ul><li>未提交读：读不加任何锁，写加排他锁直到事务结束。</li><li>提交读：读不加锁，而是在每次读时，利用MVCC生成<code>ReadView</code>；写加排他锁直到事务结束。</li><li>可重复读：读不加锁，而是在事务第一次读时，利用MVCC生成<code>ReadView</code>；写加排他锁直到事务结束。</li><li>串行化：读写都加排他锁，将事务串行执行，后来的事务必须等待前面的事务执行结束才开始执行，因此隔离效果最好，效率最差。</li></ul><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><ul><li>InnoDB存储引擎通过MVCC实现了RC和RR隔离级别。</li><li>InnoDB的行记录中，存在几个隐藏的字段：<ul><li><code>trx_id</code>记录最近修改该行记录的事务的ID；</li><li><code>db_roll_ptr</code>指向修改前版本的<code>undo log</code>，通过这个指针可以不断回溯到该记录上一个版本。</li></ul></li><li><code>ReadView</code>用于判断记录的某个版本是否对当前事务可见。它包含以下内容：<ul><li><code>trx_ids</code>：生成此<code>ReadView</code>时系统中未提交的事务列表。</li><li><code>up_limit_id</code>：<code>trx_ids</code>中最小的事务ID，小于此版本号的事务对当前<code>ReadView</code>是可见的。</li><li><code>low_limit_id</code>：当前最大的事务版本号+1，即下一个将被分配的事务id，大于此版本号的事务对当前<code>ReadView</code>是不可见的。</li><li><code>creator_trx_id</code>：当前创建事务的ID。</li></ul></li><li><code>ReadView</code>与记录的<code>trx_id</code>比较算法：<ul><li><code>trx_id</code>&lt;<code>up_limit_id</code>：表示这条记录在当前事务创建快照之前就已经提交了，所以该行数据对当前事务可见；</li><li><code>trx_id</code>&gt;=<code>low_limit_id</code>：表示这条记录在当前事务创建快照之后才被修改，所以该行数据对当前事务不可见；</li><li><code>up_limit_id</code>&lt;=<code>trx_id</code>&lt;<code>low_limit_id</code>：表示这条记录在当前事务创建快照之时可能处于活动状态或者已提交状态，需要对<code>trx_ids</code>进行查找，如果能找到ID为<code>trx_id</code>的事务，这条记录对当前事务是不可见的；如果没有找到，说明ID为<code>trx_id</code>的事务已经提交，这条记录对当前事务是可见的；</li><li>如果判断这条记录对当前事务不可见，则从这条记录的<code>db_roll_ptr</code>中找到它上一个版本号作为<code>trx_id</code>重新开始判断；</li><li>如果判断这条记录对当前事务可见，则将这条记录的值返回。</li></ul></li><li>在RC级别，每次查询都会生成最新版本的<code>ReadView</code>，因此保留了不可重复读和幻读的问题。</li><li>在RR级别，只有在事务第一次<code>SELECT</code>时生成<code>ReadView</code>，此后的查询都基于这个快照。但如果在两次读的过程中，出现了写的情况，仍然会发生幻读的问题。</li></ul><h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><ul><li>在RR隔离级别，事务会在第一次<code>SELECT</code>时生成快照，此后的普通查询都在这个快照上完成，此过程不会加锁，为快照读，或称为非阻塞读。在单纯的快照读情况下，由MVCC保证不会发生幻读。</li><li>对于<code>SELECT ... FOR UPDATE</code>、<code>SELECT ... LOCK IN SHARE MODE</code>、<code>DELETE</code>、<code>UPDATE</code>等需要加锁的操作，此时为当前读，数据库会使用<code>next-key lock</code>来防止幻读。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> MySQL </tag>
            
            <tag> OLTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（7）——常见问题</title>
      <link href="/redis_07/"/>
      <url>/redis_07/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>热点key在某一时间过期，此时大量并发请求进来，直达DB，造成DB压力骤增。</li><li>解决方案：<ul><li>使用互斥锁，同时只能有1个线程能得到锁并访问DB，其他线程等待缓存构建完，再从缓存获取数据。</li><li>设置热点数据永不过期，由定时任务异步加载数据，更新缓存。</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li>缓存同一时间大面积失效，请求直接落到DB上，造成DB压力骤增。</li><li>解决方案：<ul><li>给缓存过期时间加上一个随机值，防止key在同一时刻失效。</li><li>设置热点数据永不过期。</li><li>缓存限流（互斥锁）、降级（启用备用缓存）。</li></ul></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>大量请求访问DB中不存在的key，请求直接落到DB上，且无法写入缓存，造成缓存起不到作用。</li><li>解决方案：<ul><li>接口校验，直接对无效key过滤。</li><li>将这些无效key写入缓存，设置其值为null，设置很短的过期时间。</li><li>布隆过滤器。布隆过滤器由一个二进制数组bitMap和若干哈希函数组成，向容器中添加数据时，将key通过哈希函数映射到bitMap，将对应的值置为1。判断一个key是否存在，只需要判断这个key通过哈希函数映射到的各个值是否全部为1，只要存在某个值不为1，则它一定不在容器的键空间中。布隆过滤器只能判断一个key一定不存在，但无法保证一定存在。</li></ul></li></ul><h2 id="双写不一致"><a href="#双写不一致" class="headerlink" title="双写不一致"></a>双写不一致</h2><ul><li>在同一时刻，Redis和DB中的数据不一致。</li><li>解决方案：<ul><li>如果不要求强一致性，只要保证最终一致性，可以给key设置较短的过期时间。</li><li>先删缓存，再更新数据库。这样可能产生的问题：线程1删除缓存，线程2读取数据库并写入缓存，线程1更新数据库，此时缓存中缓存了脏数据。因此，需要延时双删等策略防止脏数据。</li><li>先更新数据库，再删除缓存。这里可能由于删缓存失败导致产生脏数据。解决方法：使用消息队列不断重试确保删除缓存成功；订阅DB的binlog，尝试删除缓存，如果失败放入消息队列不断重试。</li></ul></li></ul><h2 id="缓存无底洞"><a href="#缓存无底洞" class="headerlink" title="缓存无底洞"></a>缓存无底洞</h2><ul><li>分布式缓存数据量特别大时，批量获取多个key由于分布在多个不同实例，需要多次网络IO，性能下降。</li><li>解决方案：<ul><li>串行<code>MGET</code>，将N个key拆解为N次<code>GET</code>操作。实现简单，性能较低。</li><li>串行IO，计算每个key对应的节点，分别访问对应的节点。实现简单，性能较低。</li><li>并行IO，将串行IO的网络请求改为多线程执行，实现复杂，性能较好。</li><li>hash-tag，强制将多个key分配到一个节点上，性能最高，但维护成本高，容易出现数据倾斜。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（6）——事务</title>
      <link href="/redis_06/"/>
      <url>/redis_06/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><ul><li>Redis的事务是将多个命令打包，一次性、顺序性地执行多个命令。</li><li><code>MULTI</code>指令标记事务的开始，将执行该命令的客户端从非事务切换至事务状态。</li><li>在事务状态下，如果客户端发送了<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>、<code>MULTI</code>四个命令中的一个，服务器会立即执行这个命令；如果是其它命令，不会立即执行，而是将命令放入一个事务队列中，向客户端回复<code>QUEUED</code>。</li><li>事务队列以先进先出的方式保存入队的命令，当客户端发送<code>EXEC</code>指令时顺序执行队列中的所有命令。</li><li><code>EXEC</code>指令执行事务队列中的命令，<code>DISCARD</code>用于放弃当前事务。</li><li>Redis没有回滚机制，因此不具备原子性。</li></ul><h2 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h2><ul><li><code>WATCH</code>命令是一个乐观锁，用于在<code>EXEC</code>执行之前，监视指定的任意数量的键，若被监视的键中有至少一个被修改，则拒绝执行事务；<code>UNWATCH</code>命令用于取消对所有键的监视。</li><li>被<code>WATCH</code>的键保存在一个叫<code>watched_keys</code>的字典中，执行修改指令之前会先判断键是否存在这个字典的键空间中，如果存在，则将被修改键的客户端的<code>REDIS_DIRTY_CAS</code>标识打开，表示客户端的事务安全性被破坏，该客户端发送<code>EXEC</code>命令时，如果<code>REDIS_DIRTY_CAS</code>标识已经打开，服务器会拒绝执行该客户端提交的事务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（5）——高可用</title>
      <link href="/redis_05/"/>
      <url>/redis_05/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis多机数据库"><a href="#Redis多机数据库" class="headerlink" title="Redis多机数据库"></a>Redis多机数据库</h2><ul><li>主从模式：主服务器和从服务器保存相同的数据。</li><li>哨兵模式：哨兵监控主从数据库是否正常，并在主库出现故障时选举从库升级为主库。</li><li>集群模式：集群上每个节点存储不同的内容，每个主节点有从节点备份，每个节点之间互相监控，在主库出现故障时选举从库升级为主库。</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul><li>旧版复制功能：Slave向Master发送<code>SYNC</code>命令，Master收到命令开始执行<code>BGSAVE</code>在后台生成RDB文件，并使用缓冲区记录从开始执行的所有写命令；当Master的<code>BGSAVE</code>执行完毕，会将RDB文件发送给Slave，Slave接收并载入RDB文件，将自己的数据库状态更新至Master执行<code>BGSAVE</code>时的数据库状态；Master再将缓冲区中的所有写命令发送给Slave，Slave执行这些写命令，将自己的数据库状态更新至Master当前所处的状态。每当Master执行客户端的写命令从而导致主从不一致，Master需要将写命令发送给Slave执行，从而回到主从一致的状态。</li><li>新版复制功能：解决旧版复制在处理断线重复制情况时的低效问题。使用<code>PSYNC</code>命令代替<code>SYNC</code>，具有完整重同步和部分重同步两种模式，部分重同步用于处理断线重复制的情况：Slave在断线后重新连接Master后，Master只发送断开连接期间接收到的写命令，Slave只要接收并执行这些命令就可以更新至Master当前所处的状态。</li><li>部分重同步功能的实现：Master和Slave分别维护一个偏移量，通过判断偏移量是否一致，可以判断主从服务器是否处于一致状态；Master维护一个复制积压缓冲区，会将写命令复制到该缓冲区中，为每个字节记录相应的复制偏移量；当Slave连上Master，会把自己的偏移量发送给Master，如果偏移量之后的数据仍存在于缓冲区，执行部分重同步，否则执行完整同步。</li><li>心跳检测：Slave每秒发送<code>REPLCONF ACK</code>心跳包给Master，检测主从服务器的连接状态，并报告自己的偏移量；如果Master发现超过一秒没有接收到<code>REPLCONF ACK</code>命令，可知发生了连接问题；如果Master发现Slave的偏移量少于自己的偏移量，会将复制积压缓冲区中对应的数据发送给Slave，使主从达到一致。</li><li><code>min-slave</code>配置选项：举例，<code>min-slaves-to-write 3</code>、<code>min-slaves-max-lag 10</code>表示Slave少于3个、或者3个Slave的延迟大于等于10秒时，Master拒绝执行写命令。此选项用于减少异步复制的数据丢失。</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><ul><li>主观下线：每个Sentinel以每秒一次的频率向所有与它创建了命令连接的实例发送<code>PING</code>命令，通过返回的命令回复判断实例是否在线。假如Master连续<code>down-after-milliseconds</code>毫秒都向Sentinel1发送无效回复，Sentinel1会把Master标记为主观下线，这称为主观下线。</li><li>客观下线：当一个Sentinel把Master标记为主观下线后，会向同样监视这台Master的其他Sentinel询问，其他Sentinel检测到该Master不可用，并且数量达到<code>quorum</code>时，该Sentinel会认为Master进入客观下线状态。当Master被判断为客观下线状态，监视它的各个Sentinel会通过Raft算法选举出一个领头Sentinel对Master执行故障转移操作。</li><li>故障转移：领头Sentinel从已下线的Master属下的所有Slave中，选举一个Slave升级为新的Master，然后通过发布订阅模式通知其他Slave，修改配置文件，切换主机；当所有Slave开始复制新的Master时，完成故障转移操作。Sentinel会继续监视已下线的旧Master，当它上线时，将它设置为新Master的Slave。</li><li>Redis集群的脑裂问题：由于网络问题，Sentinel无法感知到Master的存在，把Slave提升为Master，此时存在两个不同的Master。客户端向原来的Master写入的数据无法同步到新的Master，当Sentinel与原来的Master的连接恢复，将它降级为Slave，会从新的Master同步数据，会造成数据丢失。解决方法：设置<code>min-slave</code>配置选项。</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul><li>一个集群由若干个节点组成，每个节点之间通过<code>CLUSTER MEET</code>命令进行握手，加入集群。每个节点保存一个<code>clusterState</code>结构，记录当前集群中其它节点的状态。</li><li>整个数据库被分为16384个槽，数据库中每一个键都属于这16384个槽中的一个，集群中的每个节点可以处理0到16384个槽。当数据库中的16384个槽都被指派给相应的节点，集群进入上线状态。</li><li>每个节点通过<code>clusterNode</code>结构的<code>slots</code>属性得知该节点负责哪些槽，同时会把这些信息发送给集群中的其它节点，来告知其它节点自己负责哪些槽。</li><li>当客服端发送与数据库键有关的命令，接收命令的节点先计算出该键属于哪个槽，并判断是否属于自己所负责的槽，如果键所在的槽刚好是当前节点所负责，那么该节点直接执行这个命令；否则会向客户端返回<code>MOVED</code>错误，并告知客户端正确的节点，让它再次发送命令至正确的节点。</li><li>集群中的节点分为Master和Slave，其中Master负责处理槽，Slave用于复制某个Master，在Master下线时，代替下线的Master继续处理请求。集群中每个节点会定期向其它节点发送<code>PING</code>消息来检测是否在线，并将没有及时回复<code>PONG</code>消息的节点标记为疑似下线（<code>PFAIL</code>），如果集群中超过半数的节点把一个节点标记为<code>PFAIL</code>，那么这个节点会被标记为已下线（<code>FAIL</code>）。当某个Slave发现它的Master被标记为<code>FAIL</code>，会进行故障转移，从该Master的所有Slave中通过Raft算法选举出新的Master，将旧Master的槽全部指派给自己，向集群中其它节点发送广播，告知它成为了新的Master，完成故障转移。</li></ul><h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><ul><li>Redis集群分片策略通常是根据key的CRC16校验值对16384取模，当集群中需要添加或删除节点时可能导致大规模的数据迁移，因此可以采用一致性Hash算法来分配key。</li><li>一致性Hash算法将整个Hash空间（<code>[0, 2^32-1]</code>）视为一个圆环，将每个节点的IP地址通过Hash函数映射到圆环上，对于每个key，将其通过Hash函数映射到Hash圆环上，并沿着圆环顺时针行走，遇到的第一个节点就是它应该被分派的节点。</li><li>当集群需要增加或删除节点时，只会影响到与它相邻的节点，对其它节点没有影响。</li><li>当节点数较少时，容易产生数据分布不均匀的现象，可以通过增设虚拟节点的方式使得数据分布更加均衡。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（4）——持久化</title>
      <link href="/redis_04/"/>
      <url>/redis_04/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><ul><li>Redis是内存数据库，一旦服务器意外关闭将会丢失数据，因此需要持久化方式将数据保存到磁盘里。Redis支持RDB和AOF两种持久化方式。</li><li>比较：RDB是快照式的全量备份，体积小、恢复快，但时效性不好，常用于主从同步；AOF是追加写入的持续增量备份，体积大、恢复慢，实时性好，按照<code>everysec</code>策略最多丢失1秒的数据，是主流的持久化方案。</li><li>Redis4.0混合持久化：将RDB的增量内容通过AOF的方式追加写入AOF日志，既得到了RDB的高性能，也得到了AOF的实时性。</li></ul><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><ul><li>RDB持久化是是快照持久化，是Redis默认的持久化方式。它将内存数据在某个时间点上创建快照保存在硬盘里（已过期的键会被忽略）。它生成的RDB文件是一个经过压缩的二进制文件，通过它可以将服务器还原至生成RDB文件时的状态。</li><li>生成RDB文件可以通过配置定期自动执行，也可以手动执行。手动生成RDB文件的命令有<code>SAVE</code>和<code>BGSAVE</code>。<ul><li><code>SAVE</code>命令会阻塞Redis服务器进程，直到RDB文件生成完毕，期间服务器不能处理任何请求。</li><li><code>BGSAVE</code>命令会fork一个子进程负责创建RDB文件，服务器在此期间可以继续处理请求。</li></ul></li><li>服务器使用RDB文件恢复时，会一直处于阻塞状态。如果以主服务器模式载入RDB，会忽略已过期的键；如果以从服务器模式载入RDB，不论键是否过期都会被载入。</li><li>RDB持久化的特性和使用场景：恢复快，高性能，时效性不好，适合冷备。</li></ul><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><ul><li>AOF持久化通过保存Redis服务器执行的写命令来记录数据库状态，因此AOF文件是纯文本格式。</li><li>AOF持久化的实现分为三个步骤：命令追加、文件写入、文件同步。当服务器执行完一个命令，会将被执行的命令写入<code>aof_buf</code>缓冲区的末尾，然后依据<code>appendfsync</code>选项的值来决定是否将<code>aof_buf</code>中的内容保存到AOF文件中。</li><li><code>appendfsync</code>选项的值有：<ul><li><code>always</code>：每次修改<code>aof_buf</code>都同步到AOF文件，最慢，但最安全。</li><li><code>everysec</code>（默认值）：每秒同步一次AOF文件，足够快，即便Redis故障停机也最多丢失一秒钟的数据。</li><li><code>no</code>：由操作系统决定是否同步。</li></ul></li><li>使用AOF文件还原时，会创建一个伪客户端向服务器发送AOF文件保存的写命令，直到文件中的所有命令都被处理完毕为止。</li><li>为了防止AOF文件体积过大，Redis提供了AOF重写功能，生成的新的AOF文件不会保存冗余的指令。已过期的键不会保存到重写后的AOF文件中。</li><li>已过期的键在被惰性删除或定期删除之前不会对AOF造成影响，当它被删除时会在AOF文件追加DEL命令，显式记录该键被删除。</li><li>如果服务器开启了AOF持久化，则会优先使用AOF文件来还原数据库状态。只有在AOF关闭时才会用RDB文件恢复。</li><li>AOF持久化的优点：对服务器的性能影响小，速度快，时效性好，消耗的内存少；缺点：日志文件大，需要不断AOF重写，恢复速度慢。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（3）——内存淘汰策略</title>
      <link href="/redis_03/"/>
      <url>/redis_03/</url>
      
        <content type="html"><![CDATA[<h2 id="设置键的过期时间"><a href="#设置键的过期时间" class="headerlink" title="设置键的过期时间"></a>设置键的过期时间</h2><ul><li>使用<code>EXPIRE</code>或者<code>PEXPIRE</code>命令，经过指定的秒/毫秒数之后，服务器会自动删除过期的键。</li><li>Redis通过一个过期字典来保存所有键的过期时间，它的键为指向某个键的指针，它的值为该键的过期时间（一个毫秒精度的时间戳，为long long类型的整数）。</li><li>通过过期字典，可以得知给定的键是否存在于过期字典，如果存在，可知其过期时间是否在当前UNIX时间戳之前，从而判断键是否过期。</li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><ul><li>定时删除：设置键过期时间的同时设置一个定时器，定时器会在键过期的同时触发对键的删除操作。</li><li>惰性删除：放任过期的键不管，当获取键时会检查该键是否过期，如果过期则删除该键。</li><li>定期删除：每隔一段时间就对数据库中的键进行一次抽查，删除其中过期的键。</li><li>定时删除会占用大量的CPU时间，影响服务器的响应时间和吞吐量；惰性删除会浪费太多内存；定期删除是前两者的折中。Redis实际采用的是惰性删除和定期删除相结合的策略。</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><ul><li>惰性删除和定期删除只能删除部分过期的键，当缓存的数据超过设定的最大内存时，需要借助内存淘汰策略清理无效的键。Redis中有以下8种淘汰策略：<ul><li><code>volatile-lru</code>：从配置了过期时间的键中，删除最久未使用的键；</li><li><code>volatile-lfu</code>：从配置了过期时间的键中，删除使用频率最少的键；</li><li><code>volatile-ttl</code>：从配置了过期时间的键中，删除即将要过期的键；</li><li><code>volatile-random</code>：从配置了过期时间的键中，随机删除；</li><li><code>allkeys-lru</code>：从所有键中，删除最久未使用的键；</li><li><code>allkeys-lfu</code>：从所有键中，删除使用频率最少的键；</li><li><code>allkeys-random</code>：从所有键中，随机删除；</li><li><code>noeviction</code>：超过内存时报错，不会删除任何键。</li></ul></li><li>Redis的LRU是近似LRU，通过比较当前时间戳与键的时间戳之差来得到最久未使用的键，目的是节省内存、提高性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（2）——数据类型</title>
      <link href="/redis_02/"/>
      <url>/redis_02/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="Redis支持的数据类型及其底层实现"><a href="#Redis支持的数据类型及其底层实现" class="headerlink" title="Redis支持的数据类型及其底层实现"></a>Redis支持的数据类型及其底层实现</h3><table><thead><tr><th align="center">数据类型</th><th align="center">名称</th><th align="center">底层实现方式</th></tr></thead><tbody><tr><td align="center"><code>string</code></td><td align="center">字符串</td><td align="center">long类型的整数/简单动态字符串</td></tr><tr><td align="center"><code>list</code></td><td align="center">列表</td><td align="center">压缩列表/双端链表</td></tr><tr><td align="center"><code>hash</code></td><td align="center">哈希</td><td align="center">压缩列表/字典</td></tr><tr><td align="center"><code>set</code></td><td align="center">集合</td><td align="center">整数集合/字典</td></tr><tr><td align="center"><code>zset</code></td><td align="center">有序集合</td><td align="center">压缩列表/跳跃表和字典</td></tr></tbody></table><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ul><li>简单动态字符串（SDS）是Redis键和<code>string</code>类型值的底层实现方式之一。</li><li>每个SDS对象由三部分组成：记录字符串长度的<code>len</code>，char类型的数组<code>buf[]</code>，和记录<code>buf[]</code>中未使用的字节数量的<code>free</code>。</li><li>当SDS需要被修改时，先检查char数组空间是否满足修改后的需求，如不满足会先扩容，防止溢出。</li><li>当需要缩短SDS保存的字符串时，不会立即释放掉多余的内存空间，而是把未使用的字节数保存在<code>free</code>中，以便以后可能的内存空间增长，在有需要时才进行内存释放。</li><li>SDS的优势为：获取字符串长度的时间复杂度为O(1)；杜绝缓冲区溢出；减少修改字符串长度时所需的内存重分配次数；二进制安全；兼容部分C字符串函数。</li></ul><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><ul><li>压缩列表是<code>list</code>和<code>hash</code>的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么是长度比较短的字符串，就会使用压缩列表作为实现方式。</li><li>一个压缩列表包含其内存字节数、内存偏移量、节点数量等信息；一个压缩列表节点包含其前一个节点的长度、数据类型和长度、节点的值。</li><li><code>zset</code>对象满足元素数量小于128个、所有元素成员的长度小于64个字节时，会使用压缩列表作为底层实现方式。</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>Redis字典使用哈希表作为底层实现，使用<code>table</code>数组保存哈希表，<code>table</code>中每一个元素指向一个键值对<code>dictEntry</code>。</li><li>哈希表使用链地址法解决hash冲突，链表使用头插法将新节点添加到链表的头部。</li><li>一个字典包含两个哈希表，一般情况下只使用其中一个，另一个在扩容时会用到。</li></ul><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><ul><li>跳跃表是<code>zset</code>的底层实现方式之一，跳跃表基于有序单链表，在链表的基础上，有多个层，每层也都是有序链表，每个结点不只包含向同层下一个节点的指针，还可能包含指向下一层具有相同值的节点的指针，最底层包含全部元素。</li><li>跳跃表的优点：范围查找更方便；插入删除只需要修改相邻节点的指针，无需旋转；内存占用小；实现难度简单。</li><li>相比红黑树，插入速度快不需要旋转等操作，更容易实现，支持无锁操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（1）——基本概念</title>
      <link href="/redis_01/"/>
      <url>/redis_01/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一个开源的、基于内存、提供多种数据结构、支持持久化的非关系型数据库。</p><h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><ul><li>Redis绝大多数操作是纯内存操作，内存的读写速度远远大于硬盘的读写速度。</li><li>Redis采用多路复用的非阻塞IO机制，对数据的操作是单进程、单线程的，避免多线程中上下文切换造成的时间浪费。</li><li>数据结构简单、高效。</li></ul><h2 id="为什么选择Redis作为缓存"><a href="#为什么选择Redis作为缓存" class="headerlink" title="为什么选择Redis作为缓存"></a>为什么选择Redis作为缓存</h2><ul><li>相比Memcached，Redis的优势为：<ul><li>支持多种数据类型；</li><li>支持持久化数据；</li><li>支持更大的value（512MB）；</li><li>原生支持集群。</li></ul></li></ul><h2 id="旧版Redis单线程的原因"><a href="#旧版Redis单线程的原因" class="headerlink" title="旧版Redis单线程的原因"></a>旧版Redis单线程的原因</h2><ul><li>使用多线程带来的好处是提高CPU利用率，但Redis的瓶颈不在CPU，而在于网络带宽和内存大小。</li><li>避免线程切换带来的性能开销。</li><li>单线程无需考虑线程安全问题，简化数据结构和算法的实现。</li><li>采用多路复用IO技术，单线程就能处理多个IO事件。</li><li>注意：旧版Redis不是完全单线程的，只是网络IO和数据操作是单线程的。持久化机制、集群支撑模块等是多线程的。</li></ul><h2 id="新版Redis为何采用多线程"><a href="#新版Redis为何采用多线程" class="headerlink" title="新版Redis为何采用多线程"></a>新版Redis为何采用多线程</h2><ul><li>Redis 6.0版本使用多线程处理网络请求，但对数据的操作仍然是单线程的。</li><li>Redis的瓶颈在于网络IO的处理，尽管单线程的多路复用IO性能已经很好，但在并发量极高的场景下，仍然不够。采用多个IO线程来处理网络请求，可以提高网络请求的处理速度，并充分利用多核心CPU。</li><li>Redis 6.0默认是禁用多线程的，需要开启<code>io-threads-do-reads yes</code>并配置线程数。</li></ul><h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><ul><li>Redis基于Reactor模式开发了自己的网络事件处理器：<ul><li>文件事件处理器以单线程方式运行，通过I/O多路复用程序监听多个套接字，并根据套接字目前执行的任务为套接字关联不同的事件处理器。</li><li>文件事件分派器接收I/O多路复用程序传来的套接字，根据套接字产生的事件类型调用相应的事件处理器。</li><li>事件处理器包括命令请求处理器、命令回复处理器、连接应答处理器等。</li></ul></li><li>Redis的I/O多路复用程序有<code>select</code>、<code>epoll</code>、<code>evport</code>、<code>kqueue</code>等多个I/O多路复用库实现可选，会在编译时自动选择系统中性能最高的I/O多路复用库作为底层实现。</li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>缓存：Redis读写性能优异，且支持的数据类型丰富，适合做缓存。</li><li>分布式Session：用Redis集中处理Session，解决不同服务器间Session的通信问题。</li><li>分布式ID：Redis是单线程的，可以用自增命令来生成全局唯一ID。</li><li>分布式锁：利用<code>SETNX</code>或者<code>Redlock</code>做分布式锁。</li><li>排行榜：利用<code>zset</code>天生有序的特性，可以实现排行榜功能。</li><li>计数器：利用Redis原子自增或者自减，可以实现计数器功能。</li><li>消息队列：<code>list</code>数据结构基于双向链表，利用其先进先出的特性可以作为消息队列使用。但是与专业的MQ相比，存在很多缺陷：<ul><li>没有ACK机制，需要自己处理消息丢失的问题；</li><li>不支持一个消息被多个消费者消费。</li></ul></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li><code>SETNX key value</code>：只有当键不存在时才写入键值，如果键已经存在，则不做任何操作。通常需要<code>EXPIRE key seconds</code>命令来设置锁的过期时间，但如果<code>SETNX</code>操作成功，但<code>EXPIRE</code>设置失败，会导致死锁。</li><li><code>SET key value NX EX seconds</code>：Redis 2.6.12版本使用<code>SET</code>命令涵盖了<code>SETNX</code>的功能，避免了上述死锁的情况。</li><li><code>Redlock</code>是在分布式环境下更高级的分布式锁的实现，其流程为：<ul><li>客户端记录当前UNIX时间。</li><li>客户端依次尝试从N个Redis实例获取锁，获取锁时设置一个超时时间，避免Redis节点失效时客户端仍在等待锁。</li><li>计算获取锁花费的时间（用当前时间减去开始尝试获取锁时的时间），只有这个时间小于锁失效的时间才算获取这个节点的锁成功，只有当获取了至少<code>N/2+1</code>个实例上的锁才算获取分布式锁成功。</li><li>如果获取锁失败，客户端给每个实例解锁。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（11）</title>
      <link href="/lc_top_11/"/>
      <url>/lc_top_11/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p><p>LRU包含一个双向链表和一个哈希表，双向链表用于保存节点的顺序，哈希表使得查找效率在常数级时间复杂度。</p><ul><li>插入元素：首先检查LRU是否到达存储上限，若是则需要删除最久未使用的元素，将其从双向链表和哈希表中删除，再在双向链表头部添加新的元素；如果要插入的<code>key</code>已经存在，则更新其值并在双向链表中将其节点提前。</li><li>查找元素：如果元素存在，则需要在双向链表中将该元素的节点提前。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node head;</span><br><span class="line">        <span class="keyword">public</span> Node tail;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.prev = head;</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向双向链表头部添加元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">            x.next = head.next;</span><br><span class="line">            head.next.prev = x;</span><br><span class="line">            x.prev = head;</span><br><span class="line">            head.next = x;</span><br><span class="line">            <span class="keyword">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">            x.next.prev = x.prev;</span><br><span class="line">            x.prev.next = x.next;</span><br><span class="line">            <span class="keyword">this</span>.size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除尾部元素并返回该节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node x = tail.prev;</span><br><span class="line">            del(x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">public</span> DoubleList list;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node x = map.get(key);</span><br><span class="line">        list.del(x);</span><br><span class="line">        list.add(x);<span class="comment">//将节点前移</span></span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;<span class="comment">//更新节点，将节点前移</span></span><br><span class="line">            Node d = map.get(key);</span><br><span class="line">            list.del(d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size==capacity) &#123;<span class="comment">//删除末尾节点</span></span><br><span class="line">            Node d = list.pop();</span><br><span class="line">            map.remove(d.key);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, x);</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p><p>Trie树节点包括一个布尔类型的值，用来标记这个节点是否代表一个词的末尾，以及一个长度为N的数组表示所有可能出现的字符，例如这里需要26个元素代表26个小写字母。</p><ul><li>插入单词：把单词拆分成一个一个字符，首字母建立Trie根节点，依次遍历，如果字符的节点已经存在，什么都不做继续遍历，如果字符节点不存在，在当前树的对应节点中新建节点。到最后，标记为单词的末尾。</li><li>查询是否是单词：把单词拆分成一个一个字符，从头查询字符在树中对应子节点是否存在。如果不存在，返回<code>false</code>。最后要检查其末尾标记是否为真。</li><li>查询是否是前缀：与查询是否是单词类似，区别是无需判断是否有末尾的标记。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node[] ch;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ch = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node trie = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (trie.ch[c-<span class="string">&#x27;a&#x27;</span>]==<span class="keyword">null</span>) trie.ch[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            trie = trie.ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        trie.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node trie = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (trie.ch[c-<span class="string">&#x27;a&#x27;</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            trie = trie.ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Node trie = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (trie.ch[c-<span class="string">&#x27;a&#x27;</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            trie = trie.ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（10）</title>
      <link href="/lc_top_10/"/>
      <url>/lc_top_10/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>参见《剑指Offer》<a href="http://ster.im/jianzhioffer_4/#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">最长不含重复字符的子字符串</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                l = Math.max(l, map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, r-l+<span class="number">1</span>);</span><br><span class="line">            map.put(c, r);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-window-substring">76. 最小覆盖子串</a></p><p>使用滑动窗口模拟最小覆盖子串，用数组记录所需的字符数量和窗口中的字符数量。首先向右扩张窗口边界直到滑动窗口包含全部所需的字符，然后不断向右缩小左边界直到窗口中不满足全部所需字符，同时不断更新最小覆盖子串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// l和r用于保存当前最小覆盖子串的左右下标</span></span><br><span class="line">        <span class="keyword">int</span> l = -<span class="number">1</span>, r = -<span class="number">1</span>, minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// need用于统计所需要的字符，count用于计数所需字符总数</span></span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t.toCharArray()) &#123;</span><br><span class="line">            need[c]++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// window用于计数滑动窗口中的字符</span></span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;s.length()) &#123;</span><br><span class="line">            <span class="comment">// 扩张右边界</span></span><br><span class="line">            <span class="keyword">char</span> rc = s.charAt(j);</span><br><span class="line">            window[rc]++;</span><br><span class="line">            <span class="keyword">if</span> (window[rc]&lt;=need[rc]) count--;</span><br><span class="line">            <span class="comment">// 滑动窗口包含所有所需字符，开始缩减左边界</span></span><br><span class="line">            <span class="keyword">while</span> (count==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新最小覆盖子串的长度</span></span><br><span class="line">                <span class="keyword">if</span> (minLen&gt;j-i+<span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = j-i+<span class="number">1</span>;</span><br><span class="line">                    r = j;</span><br><span class="line">                    l = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(i);</span><br><span class="line">                window[lc]--;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (window[lc]&lt;need[lc]) count++;   </span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果l没有更新过，说明不存在覆盖子串</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;=<span class="number">0</span>? s.substring(l, r+<span class="number">1</span>): <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum">239. 滑动窗口最大值</a></p><p>参见《剑指Offer》<a href="http://ster.im/jianzhioffer_5/#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">滑动窗口的最大值</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast()&lt;nums[i]) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = queue.peek();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i-k]==queue.peekFirst()) queue.pollFirst();</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast()&lt;nums[i]) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = queue.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string">438. 找到字符串中所有字母异位词</a></p><p>此题与76题相似，不同的是只记录窗口中所需字符的数量，并且只当窗口大小与模式字符串相等时才判断是否是字母异位词，然后缩小左边界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: p.toCharArray()) &#123;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (need[rc]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                window[rc]++;</span><br><span class="line">                <span class="keyword">if</span> (window[rc]&lt;=need[rc]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">while</span> (count==p.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right-left==p.length()) &#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (need[lc]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    window[lc]--;</span><br><span class="line">                    <span class="keyword">if</span> (window[lc]&lt;need[lc]) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（9）</title>
      <link href="/lc_top_09/"/>
      <url>/lc_top_09/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></p><p>可以看作物品重量为完全平方数的完全背包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j*j&lt;=i; j++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/coin-change">322. 零钱兑换</a></p><p><code>dp[i]</code>表示当零钱总数为<code>i</code>时所需最少的硬币数。将<code>dp[i]</code>的值初始化为一个不可能取到的值以表示无法组成总金额。状态转移方程：<code>dp[i]=min(dp[i], dp[i-coin]+1)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin: coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;coin || dp[i-coin]==Integer.MAX_VALUE) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]&gt;amount? -<span class="number">1</span>: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p><p>本题是求是否存在子数组之和为数组总和的一半，可使用动态规划解决此类0-1背包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] bag = <span class="keyword">new</span> <span class="keyword">boolean</span>[target+<span class="number">1</span>];</span><br><span class="line">        bag[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=target; i&gt;=<span class="number">0</span>; i--) &#123;<span class="comment">//注意0-1背包问题需要从后往前扫描</span></span><br><span class="line">                <span class="keyword">if</span> (i&gt;=num) bag[i] |= bag[i-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bag[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/target-sum">494. 目标和</a></p><p>方法一：深度优先搜索</p><p>穷举每一个元素取正负符号的所有组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        dfs(<span class="number">0</span>, S);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum==<span class="number">0</span>) res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(i+<span class="number">1</span>, sum+nums[i]);</span><br><span class="line">        dfs(i+<span class="number">1</span>, sum-nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>本题是求数组中一部分元素之和减去其它元素之和等于<code>S</code>，即<code>part1 - part2 == S</code>，而<code>part1 + part2 == sum</code>，因此<code>2 * part1 == S + sum</code>，从而转化为求和为<code>(sum + S) / 2</code>的0-1背包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line">        <span class="keyword">if</span> ((sum+S)%<span class="number">2</span>==<span class="number">1</span> || S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i&gt;=num; i--) &#123;</span><br><span class="line">                dp[i] += dp[i-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="“股票交易”问题"><a href="#“股票交易”问题" class="headerlink" title="“股票交易”问题"></a>“股票交易”问题</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            profit = Math.max(profit, prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></p><p><code>dp[i][j]</code>表示第<code>i</code>天所能获得的最大收益，<code>j</code>表示当天最终是否持有股票。第<code>i</code>天未持有股票（<code>dp[i][0]</code>），可能是第<code>i-1</code>天也未持有，也可能是第<code>i-1</code>天持有但今日卖出。状态转移方程：<code>dp[i][0]=max(dp[i-1][0], dp[i-1][1]+prices[i])</code>；第<code>i</code>天持有股票（<code>dp[i][1]</code>），可能是第<code>i-1</code>天未持有但今日买入，也可能是第<code>i-1</code>天就持有今日未卖出。这里因为有冷却期，因此若今日买入，昨日不能卖出，此状态只与前一日有关。状态转移方程：<code>dp[i][1]=max(dp[i-1][1], dp[i-2][0]-prices[i])</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = -<span class="number">1</span> * prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">0</span>]-prices[i-<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="“打家劫舍”问题"><a href="#“打家劫舍”问题" class="headerlink" title="“打家劫舍”问题"></a>“打家劫舍”问题</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></p><p>状态转移方程：<code>dp[i] = max(dp[i-2]+nums[i], dp[i-1])</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">2</span>]+nums[i], dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></p><p>对每个结点有两种选择：偷或不偷。如果选择偷这个节点，那么可能获得的最大收益等于这个节点的收益加上不偷两个子节点的最大收益；如果选择不偷这个节点，那么可能的最大收益等于两个子节可偷可不偷的最大收益的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = robber(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robber(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] money = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] left = robber(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = robber(root.right);</span><br><span class="line">        money[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        money[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（8）</title>
      <link href="/lc_top_08/"/>
      <url>/lc_top_08/</url>
      
        <content type="html"><![CDATA[<h2 id="一维数组的动态规划"><a href="#一维数组的动态规划" class="headerlink" title="一维数组的动态规划"></a>一维数组的动态规划</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></p><p>参见《剑指Offer》<a href="http://ster.im/jianzhioffer_4/#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">连续子数组的最大和</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>], sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) sum = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sum += nums[i];</span><br><span class="line">            res = Math.max(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/climbing-stairs/submissions/">70. 爬楼梯</a></p><p>斐波那契数列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p><p><strong>卡特兰数</strong>：设以i为根节点的二叉搜索树数量为$g(i)$，以1~n为节点组成的二叉搜索树共有$f(n)$个，$f(n)=g(1)+g(2)+……+g(n)$；</p><p>以i为根节点时，左子树的二叉搜索树有$f(i-1)$个，右子树的二叉搜索树有$f(n-i)$个，因此$g(i)=f(i-1)*f(n-i)$；</p><p>综上，</p><p>$$f(n)=f(0)*f(n-1)+f(1)*f(n-2)+……+f(n-1)*f(0)$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray">152. 乘积最大子数组</a></p><p>状态转移方程：<code>dp[i] = max(dp[i-1]*nums[i], nums[i])</code>。由于存在负数，负数乘以最小值就变成了最大值，因此需要同时维护最小和最大值，当遍历到负数时交换两数进行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>, min = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = min;</span><br><span class="line">                min = max;</span><br><span class="line">                max = t;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max*num, num);</span><br><span class="line">            min = Math.min(min*num, num);</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">300. 最长上升子序列</a></p><p>用<code>dp[i]</code>来表示以第<code>i</code>个元素为结尾的最长递增子序列长度。遍历<code>nums[i]</code>，再遍历其之前的元素<code>nums[j]</code>，若<code>nums[j]&lt;nums[i]</code>，<code>dp[i]</code>可能的取值是<code>dp[j]+1</code>。时间复杂度$O(n^2)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j]&lt;nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的动态规划"><a href="#二维数组的动态规划" class="headerlink" title="二维数组的动态规划"></a>二维数组的动态规划</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximal-square">221. 最大正方形</a></p><p>用<code>dp[i][j]</code>来表示以<code>(i,j)</code>为右下角的正方形的最大边长。当格点为<code>1</code>时，它能形成正方形的最大边长取决于最短的一条边，即与左上、上和左格点的和的最小值，即<code>1 + min(dp[i-1][j-1]</code>、<code>dp[i][j-1]</code>、<code>dp[i-1][j])</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span> || j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + min(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                res = Math.max(res, dp[i][j] * dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(i, j), k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/burst-balloons">312. 戳气球</a></p><p>设在区间<code>[start, end]</code>中戳破的最后一个气球是第<code>k</code>个，那么这个区间的结果为<code>dp[start][k] + nums[start]*nums[k]*nums[end] + dp[k][end]</code>（不戳破两边的气球，如果<code>start+1==end</code>，则视为0）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] nums_ = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            nums_[i] = nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums_[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        nums_[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">2</span>; j&lt;n+<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=i+<span class="number">1</span>; k&lt;j; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = dp[i][k] + dp[k][j] + nums_[i]*nums_[k]*nums_[j];</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串相关问题"><a href="#字符串相关问题" class="headerlink" title="字符串相关问题"></a>字符串相关问题</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching">10. 正则表达式匹配</a></p><p>参考《剑指offer》<a href="http://ster.im/jianzhioffer_2/#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D">正则表达式匹配</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>) dp[i][j] = (i==<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j&gt;<span class="number">1</span>) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i][j-<span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">1</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>)==<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses">32. 最长有效括号</a></p><p><code>dp[i]</code>表示以<code>s[i]</code>结尾的子串的最长有效括号长度。如果<code>s[i]==&#39;(&#39;</code>，是无法构成有效括号的，因此<code>dp[i]=0</code>。如果<code>s[i]==&#39;)&#39;</code>，且<code>s[i-1]==&#39;(&#39;</code>，则它们构成一组有效括号，有效括号长度+2；如果<code>s[i-1]==&#39;)&#39;</code>，那么需要找到已经构成有效括号对之前的那个单括号，如果它是<code>(</code>那么可构成有效括号。之后，需要加上这之前已成为有效括号子串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示以s[i]结尾的子串的最长有效括号长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果末位是&#x27;(&#x27;，不存在有效括号子串</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; s.charAt(i)==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//与前一位构成有效括号，长度+2</span></span><br><span class="line">                    dp[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;=<span class="number">2</span>) dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//找到已构成有效括号对之前的最后一个单括号</span></span><br><span class="line">                    <span class="keyword">int</span> lastSingleBracket = i-dp[i-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (lastSingleBracket&gt;=<span class="number">0</span> &amp;&amp; s.charAt(lastSingleBracket)==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        dp[i] = <span class="number">2</span>+dp[i-<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">//如果该括号之前还存在有效括号子串，需要加上这段长度</span></span><br><span class="line">                        <span class="keyword">if</span> (lastSingleBracket&gt;=<span class="number">1</span>) dp[i] += dp[lastSingleBracket-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/edit-distance">72. 编辑距离</a></p><p><code>dp[i][j]</code>表示到<code>A[i]</code>和<code>B[j]</code>为止所需的最小操作次数。如果<code>A[i]</code>和<code>B[j]</code>相同，则无需操作，<code>dp[i][j] = dp[i-1][j-1]</code>。否则，有三种可能的操作方式：</p><ol><li>删除当前字符，相当于用<code>A[i-1]</code>继续与<code>B[j]</code>比较，同时操作数+1；</li><li>添加一个字符，相当于用<code>A[i]</code>与<code>B[j-1]</code>比较，同时操作数+1；</li><li>修改当前字符，A和B继续比较前面一个字符，同时操作数+1。</li></ol><p>从以上三种操作中找到使操作数最小的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/word-break">139. 单词拆分</a></p><p><code>dp[i]</code>表示字符串<code>s[:i]</code>是否能够拆分成单词表中的词。如果<code>dp[i]</code>能够拆分，并且<code>s[i:j]</code>是单词表中的单词，那么<code>dp[i+j]</code>也能够拆分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word: wordDict) &#123;</span><br><span class="line">            set.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[j]) <span class="keyword">continue</span>;</span><br><span class="line">                String w = s.substring(j, i);</span><br><span class="line">                dp[i] = set.contains(w);</span><br><span class="line">                <span class="keyword">if</span> (dp[i]) <span class="keyword">break</span>;<span class="comment">//已经可以拆分，略过其它情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（7）</title>
      <link href="/lc_top_07/"/>
      <url>/lc_top_07/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">public</span> StringBuilder sb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==digits.length()) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        String str = strs[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;str.length(); j++) &#123;</span><br><span class="line">            sb.append(str.charAt(j));</span><br><span class="line">            dfs(digits, i+<span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></p><p>用字符串容器中已有的左括号和右括号的数量来控制深度搜索的分支和出口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">public</span> StringBuilder sb;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        N = n;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.length()==<span class="number">2</span>*N) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;N) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            dfs(left+<span class="number">1</span>, right);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right&lt;left) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            dfs(left, right+<span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></p><p>对数组排序，防止出现重复的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; tmp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] candidates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">this</span>.candidates = candidates;</span><br><span class="line">        dfs(target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;candidates.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum-candidates[j]&lt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//提前剪枝</span></span><br><span class="line">            tmp.add(candidates[j]);</span><br><span class="line">            dfs(sum-candidates[j], j);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></p><p>全排列类问题，结果字符串需要包含所有的字符，因此要对字符串中每一个字符进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; tmp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        dfs();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size()==nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs();</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></p><p>子集类问题，已经顺序访问过的字符无需再次访问，因此用一个偏移量来控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; tmp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">if</span> (i==nums.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[j]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(nums[j]);</span><br><span class="line">            used[j] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(j+<span class="number">1</span>);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            used[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/word-search">79. 单词搜索</a></p><p>将已经搜索过的格点用<code>#</code>标记，防止重复进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.M = board.length;</span><br><span class="line">        <span class="keyword">this</span>.N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = dfs(i, j, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span> || y&lt;<span class="number">0</span> || x&gt;=M || y&gt;=N || i==word.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y]!=word.charAt(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i==word.length()-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span> t = board[x][y];</span><br><span class="line">        board[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = dfs(x-<span class="number">1</span>, y, i+<span class="number">1</span>) || dfs(x+<span class="number">1</span>, y, i+<span class="number">1</span>) || dfs(x, y-<span class="number">1</span>, i+<span class="number">1</span>) || dfs(x, y+<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">        board[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p><p>以值为<code>1</code>的格点为起点进行深度搜索，把相连接的<code>1</code>变为<code>0</code>以防止重复进入，一次深度搜索后就“沉没”一个岛屿。统计“沉没”的岛屿的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        <span class="keyword">this</span>.M = grid.length;</span><br><span class="line">        <span class="keyword">this</span>.N = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dfs(i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=M || j&gt;=N) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]!=<span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(i-<span class="number">1</span>, j);</span><br><span class="line">        dfs(i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j-<span class="number">1</span>);</span><br><span class="line">        dfs(i, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses">301. 删除无效的括号</a></p><p>先遍历数组，确定需要删除多少个<code>&#39;(&#39;</code>和<code>&#39;)&#39;</code>才能使字符串有效，然后深度搜索，直到删除的<code>&#39;(&#39;</code>和<code>&#39;)&#39;</code>达到数量要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder sb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left&gt;<span class="number">0</span>) left--;</span><br><span class="line">                <span class="keyword">else</span> right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check()) res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;sb.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;index &amp;&amp; sb.charAt(i)==sb.charAt(i-<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (sb.charAt(i)==<span class="string">&#x27;(&#x27;</span> &amp;&amp; left&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sb.deleteCharAt(i);</span><br><span class="line">                dfs(i, left-<span class="number">1</span>, right);</span><br><span class="line">                sb.insert(i, <span class="string">&quot;(&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.charAt(i)==<span class="string">&#x27;)&#x27;</span> &amp;&amp; right&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sb.deleteCharAt(i);</span><br><span class="line">                dfs(i, left, right-<span class="number">1</span>);</span><br><span class="line">                sb.insert(i, <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb.charAt(i)==<span class="string">&#x27;(&#x27;</span>) count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(i)==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p><p>两层递归，①先序遍历，将每个节点作为DFS的起始节点；②深度优先搜索找到和为<code>sum</code>的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        preOrder(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        preOrder(root.left, sum);</span><br><span class="line">        dfs(root, sum-root.val);</span><br><span class="line">        preOrder(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) dfs(root.left, sum-root.left.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) dfs(root.right, sum-root.right.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></p><p>使用深度优先搜索判断图中是否存在环。<code>courses[i]</code>有三种状态，<code>0</code>为初始状态，<code>1</code>表示当前正在搜索这门课程，如果此次搜索再度访问到它说明存在环，返回<code>false</code>，<code>-1</code>表示该门课程搜索完毕且未发现环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span>[][] R;</span><br><span class="line">    <span class="keyword">int</span>[] courses;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.N = numCourses;</span><br><span class="line">        <span class="keyword">this</span>.R = prerequisites;</span><br><span class="line">        <span class="keyword">this</span>.courses = <span class="keyword">new</span> <span class="keyword">int</span> [N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (courses[i]==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (courses[i]==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        courses[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] requests: R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requests[<span class="number">0</span>]==i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(requests[<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        courses[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></p><p>构造有向图，使用<code>HashMap&lt;String, List&lt;Node&gt;&gt;</code>存储所有节点，列表<code>List&lt;Node&gt;</code>存储与该节点相邻接的节点，同时记录它们之间的倍数关系。以每个问题的被除数作为深度优先搜索的起点，除数作为终点进行搜索，并且用一个<code>set</code>防止出现环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义图的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">double</span> multiple;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String id, <span class="keyword">double</span> multiple)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.multiple = multiple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, List&lt;Node&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按照相除关系构造图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.size(); i++) &#123;</span><br><span class="line">            String dividend = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String divisor = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 处理被除数</span></span><br><span class="line">            List&lt;Node&gt; dividend_list = map.getOrDefault(dividend, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            dividend_list.add(<span class="keyword">new</span> Node(divisor, values[i]));</span><br><span class="line">            map.put(dividend, dividend_list);</span><br><span class="line">            <span class="comment">// 处理除数，其与被除数的倍数为values[i]的倒数</span></span><br><span class="line">            List&lt;Node&gt; divisor_list = map.getOrDefault(divisor, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            divisor_list.add(<span class="keyword">new</span> Node(dividend, <span class="number">1.</span>/values[i]));</span><br><span class="line">            map.put(divisor, divisor_list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;queries.size(); i++) &#123;</span><br><span class="line">            String dividend = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String divisor = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">            res[i] = dfs(dividend, divisor, <span class="number">1.</span>, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(String dividend, String divisor, <span class="keyword">double</span> multi, Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果被除数不存在，或者已经遍历过（存在环），返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(dividend) || set.contains(dividend)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被除数等于除数，搜索结束，返回当前的倍数</span></span><br><span class="line">        <span class="keyword">if</span> (dividend.equals(divisor)) <span class="keyword">return</span> multi;</span><br><span class="line">        <span class="comment">// 把当前被除数放入set，防止出现环</span></span><br><span class="line">        set.add(dividend);</span><br><span class="line">        <span class="comment">// 深度搜索被除数的list</span></span><br><span class="line">        <span class="keyword">for</span> (Node node: map.get(dividend)) &#123;</span><br><span class="line">            <span class="keyword">double</span> tmp = dfs(node.id, divisor, multi*node.multiple, set);</span><br><span class="line">            <span class="keyword">if</span> (tmp != -<span class="number">1.</span>) <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（6）</title>
      <link href="/lc_top_06/"/>
      <url>/lc_top_06/</url>
      
        <content type="html"><![CDATA[<h2 id="前序、中序、后序遍历"><a href="#前序、中序、后序遍历" class="headerlink" title="前序、中序、后序遍历"></a>前序、中序、后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><p>二叉树的中序遍历，可以有递归和非递归两种写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root!=<span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span> || right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.val!=right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length==<span class="number">0</span> || inorder.length==<span class="number">0</span> || preorder.length!=inorder.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = buildTree(preorder, inorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl&gt;pr || il&gt;ir) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pl]);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (inorder[il+len]!=preorder[pl]) len++;</span><br><span class="line">        root.left = buildTree(preorder, inorder, pl+<span class="number">1</span>, pl+len, il, il+len-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, inorder, pl+<span class="number">1</span>+len, pr, il+len+<span class="number">1</span>, ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></p><p>二叉树展开为链表后，顺序与前序遍历相同。把左子树的展开替换到右子节点处即可得到链表。但如果直接用前序遍历，会导致丢失右子节点。因此采用后序遍历，从尾节点递归处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><p>对于一个节点，穿过该节点的最大路径和存在3种可能：</p><ul><li>该节点及其左、右子树；</li><li>包含该节点的左子树，及其父节点；</li><li>包含该节点的右子树，及其父节点。</li></ul><p>其中第一种情况不需要计算其父节点值，直接与当前最大值比较；后两种情况需要传出路径和，节点路径和不大于0时，该路径需要舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        res = Integer.MIN_VALUE;</span><br><span class="line">        pathSum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = pathSum(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = pathSum(root.right);</span><br><span class="line">        <span class="keyword">int</span> sum = root.val + left + right;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">        sum = root.val + Math.max(left, right);</span><br><span class="line">        <span class="keyword">return</span> sum&gt;<span class="number">0</span>? sum: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p><p>参见《剑指Offer》<a href="http://ster.im/jianzhioffer_6/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉树的最近公共祖先</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span> || root==p || root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></p><p>经过<code>root</code>节点的直径为其左右子树的高度和。深度优先搜索以每一个节点为根节点的子树，比较并保存最大直径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        max = Math.max(max, left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==<span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2==<span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(t1.val+t2.val);</span><br><span class="line">        root.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        root.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层次遍历</a></p><p>层次遍历通常会使用队列这一数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree">297. 二叉树的序列化与反序列化</a></p><p>方法一：DFS</p><p>按照先序遍历序列化和反序列化二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            serialize(root, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(root.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            serialize(root.left, sb);</span><br><span class="line">            serialize(root.right, sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">        String[] strs = data.substring(<span class="number">1</span>, data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> deserialize(strs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        String s = strs[index++];</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;null&quot;</span>)) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.parseInt(s));</span><br><span class="line">            node.left = deserialize(strs);</span><br><span class="line">            node.right = deserialize(strs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：BFS</p><p>参考《剑指offer》<a href="http://ster.im/jianzhioffer_3/#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">序列化二叉树</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(node.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] nodes = data.substring(<span class="number">1</span>, data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!nodes[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                TreeNode left = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[i]));</span><br><span class="line">                node.left = left;</span><br><span class="line">                queue.offer(left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!nodes[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                TreeNode right = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[i]));</span><br><span class="line">                node.right = right;</span><br><span class="line">                queue.offer(right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树相关"><a href="#二叉搜索树相关" class="headerlink" title="二叉搜索树相关"></a>二叉搜索树相关</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree">98. 验证二叉搜索树</a></p><p>二叉搜索树中左子树的所有节点值小于根节点的值，右子树的所有节点大于根节点的值，如果只递归比较根节点跟其左右子节点的值，会出现左子节点的右子节点值大于根节点值的情况，因此需要将根节点的值传递到下一层进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MAX_VALUE, Long.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> max, <span class="keyword">long</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val&lt;=min || root.val&gt;=max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, root.val, min) &amp;&amp; isValidBST(root.right, max, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p><p>反向中序遍历，更新节点值为累加和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（5）</title>
      <link href="/lc_top_05/"/>
      <url>/lc_top_05/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p><p>使用快速排序的<code>partition</code>函数求第K个最大的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findKthLargest(nums, nums.length-k, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (p&lt;k) <span class="keyword">return</span> findKthLargest(nums, k, p+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p&gt;k) <span class="keyword">return</span> findKthLargest(nums, k, lo, p-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//本题测试用例有极端情况（数组已经基本有序），此时快排时间复杂度达到O(n^2)，因此需要随机选择pivot</span></span><br><span class="line">        <span class="keyword">if</span> (lo&lt;hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = lo+random.nextInt(hi-lo);</span><br><span class="line">            swap(nums, lo, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;lo &amp;&amp; nums[--j]&gt;p);</span><br><span class="line">            <span class="keyword">while</span> (i&lt;hi &amp;&amp; nums[++i]&lt;p);</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, j, lo);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的排序"><a href="#二维数组的排序" class="headerlink" title="二维数组的排序"></a>二维数组的排序</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals">56. 合并区间</a></p><p>对每个区间按照首位元素排序。如果区间1的右边界大于区间2的左边界，则可以合并，右边界取两者右边界的较大者；否则区间2成为新的区间加入结果集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        res.offer(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = res.peekLast();</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">1</span>]&lt;intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                res.offer(intervals[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr[<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], curr[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/meeting-rooms-ii">253. 会议室 II</a></p><p>只需要考虑同时占用的会议室的最大值，无需考虑是哪个会议开始或结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(start);</span><br><span class="line">        Arrays.sort(end);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, cur = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start[i] &lt; end[j]) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">                res = Math.max(res, cur);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start[i] &gt; end[j]) &#123;</span><br><span class="line">                cur--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></p><p>先按照身高从高到低的顺序排列，相同的身高的按照第二项的值从小到大排序；首先安排身高高的，再将剩下的身高低的逐个插入有序的队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]==o2[<span class="number">0</span>]? o1[<span class="number">1</span>]-o2[<span class="number">1</span>]: o2[<span class="number">0</span>]-o1[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ArrayList&lt;<span class="keyword">int</span>[]&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p: people) &#123;</span><br><span class="line">            tmp.add(p[<span class="number">1</span>], p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[people.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;people.length; i++) &#123;</span><br><span class="line">            res[i] = tmp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">33. 搜索旋转排序数组</a></p><p>二分查找，根据<code>nums[mid]</code>与两边的大小关系，确定旋转发生在中点的哪一侧，缩小目标数所在的区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target) right = mid;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; nums[right] &gt;= target) left = mid;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>查找目标元素在数组中出现的左边界和右边界。参见《剑指offer》<a href="http://ster.im/jianzhioffer_5/#%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">数字在排序数组中出现的次数</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">int</span> l = getLeft();</span><br><span class="line">        <span class="keyword">int</span> r = getRight();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l==r) <span class="keyword">return</span> nums[l]==target? l: -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m]==target) r = m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&gt;target) r = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l==r) <span class="keyword">return</span> nums[l]==target? l: -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m]==target) l = m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&gt;target) r = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（4）</title>
      <link href="/lc_top_04/"/>
      <url>/lc_top_04/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><p>使用中心扩展法判断回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> maxLen;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            getPalindrome(s, i, i);</span><br><span class="line">            getPalindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> t = j - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &gt; maxLen) &#123;</span><br><span class="line">                maxLen = t;</span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></p><p>把每个字符串排序，按排序后的字符串作为键保存到哈希表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            String key = <span class="keyword">new</span> String(c);</span><br><span class="line">            List&lt;String&gt; tmp = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            tmp.add(strs[i]);</span><br><span class="line">            map.put(key, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String key: map.keySet()) &#123;</span><br><span class="line">            res.add(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></p><p>使用两个栈分别保存数字和字符。遍历字符串，遍历到<code>[</code>时，将记录的数字和字符串入栈并重置，此时<code>res</code>保存方括号内的字符串；遍历到<code>]</code>时，将数字栈的顶部元素弹出，它是目前<code>res</code>字符串需要重复的次数，再加上字符栈顶部元素构成新一轮的<code>res</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; num = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; str = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                num.push(count);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                str.push(res.toString());</span><br><span class="line">                res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                tmp.append(str.pop());</span><br><span class="line">                <span class="keyword">int</span> curNum = num.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;curNum; i++) &#123;</span><br><span class="line">                    tmp.append(res.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) count = count*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></p><p>使用中心扩展法判断回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            isPalindrome(s, i, i);</span><br><span class="line">            isPalindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></p><p>两个相等的数异或为0，0异或任意数等于它本身。利用此性质解本题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></p><p><code>n&amp;(n-1)</code>可以把<code>n</code>的最右边的1去掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=num; i++) &#123;</span><br><span class="line">            res[i] = count(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            num &amp;= num-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></p><p>求两数的异或，结果中为<code>1</code>的位数即为汉明距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = x^y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (xor!=<span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            xor = (xor&amp;(xor-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（3）</title>
      <link href="/lc_top_03/"/>
      <url>/lc_top_03/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></p><p>遍历数组，发现左括号则入栈，发现右括号，弹出栈顶元素并比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || c!= stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></p><p>使用辅助栈，保证辅助栈栈顶保存最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (min.isEmpty() || x&lt;min.peek()) min.push(x);</span><br><span class="line">        <span class="keyword">else</span> min.push(min.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) <span class="keyword">return</span> stack.peek();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) <span class="keyword">return</span> min.peek();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water">42. 接雨水</a></p><p>方法一：单调栈</p><p>用栈储存高度的下标，栈内元素对应的高度不严格单调递减。遍历高度数组，当发现当前高度大于栈顶元素，表示出现“积水槽”，此时计算储水的高度<code>h = min(height[stack.peek()], height[index]) - height[t]</code>，水槽的宽度<code>w = index-stack.peek()-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; height.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()]&lt;height[index]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> hi = Math.min(height[stack.peek()], height[index]) - height[t];</span><br><span class="line">                res += hi * (index-stack.peek()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>按列求雨水的高度。分别求出该列左右两侧的最高高度，两侧较低的值减去当前位置的高度即为雨水的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            left[i] = Math.max(height[i-<span class="number">1</span>], left[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            right[i] = Math.max(height[i+<span class="number">1</span>], right[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(left[i], right[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span> (h&gt;<span class="number">0</span>) res+=h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><p>单调栈存储下标，保持栈内元素对应高度不严格单调递增。向右遍历，当遇到新的高度低于栈顶元素的高度，则可以确定此时栈顶对应高度的右边界，而左边界是弹出栈顶元素后的新栈顶（如果新栈顶与原栈顶的高度相等，不影响最终计算结果）。</p><p>在原高度数组的前后各插入一个值为<code>0</code>的哨兵，可以实现代码的大幅度简化：一是栈不会为空，省去每次判断栈是否为空；二是右边界必然是最低值，便于处理遍历完<code>heights</code>后栈内剩余的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="comment">// 在heights前后各插入一个0</span></span><br><span class="line">        <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            h[i] = heights[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);<span class="comment">//避免判断栈是否为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (h[stack.peek()]&gt;h[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = h[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> size = height * width;</span><br><span class="line">                res = Math.max(res, size);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximal-rectangle">85. 最大矩形</a></p><p>沿用第84题的思路，对每一层都可以使用单调栈计算最大矩形。这里使用一个数组记录该层对应的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                heights[j+<span class="number">1</span>] = matrix[i][j]==<span class="string">&#x27;0&#x27;</span>? <span class="number">0</span>: heights[j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[stack.peek()]&gt;heights[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> size = height * width;</span><br><span class="line">                res = Math.max(res, size);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></p><p>使用单调栈存储气温的下标，保证栈内单调递减，一旦发现当日气温高于栈顶元素，则得到栈顶元素对应的结果值。将栈顶元素弹出，直到保持栈单调递减。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">if</span> (T.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[stack.peek()]&lt;T[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">                res[index] = i-index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（2）</title>
      <link href="/lc_top_02/"/>
      <url>/lc_top_02/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针操作链表"><a href="#双指针操作链表" class="headerlink" title="双指针操作链表"></a>双指针操作链表</h2><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第N个节点</a></p><p>快慢双指针，快指针先走<code>N</code>步，然后两指针一起走，直到快指针到达尾节点，这样慢指针下一位就是要删除的结点。需要先建立一个哑节点保存链表头部，以及防止链表只有1个节点导致空指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode pHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        pHead.next = head;</span><br><span class="line">        ListNode pFast = pHead;</span><br><span class="line">        ListNode pSlow = pHead;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pFast.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pSlow.next = pSlow.next.next;</span><br><span class="line">        <span class="keyword">return</span> pHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></p><p>快慢双指针，快指针每次走2步，慢指针每次走1步，如果存在环，则两指针必定相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表II</a></p><p>参考《剑指Offer》<a href="http://ster.im/jianzhioffer_2/#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9">链表中环的入口结点</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p><p>参考《剑指Offer》<a href="http://ster.im/jianzhioffer_4/#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">两个链表的第一个公共结点</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) a = headB;</span><br><span class="line">            <span class="keyword">else</span> a = a.next;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>) b = headA;</span><br><span class="line">            <span class="keyword">else</span> b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p><p>链表模拟加法，需要记录进位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ptr = dummy;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = l1==<span class="keyword">null</span>? <span class="number">0</span>: l1.val;</span><br><span class="line">            <span class="keyword">int</span> num2 = l2==<span class="keyword">null</span>? <span class="number">0</span>: l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = num1+num2+carry;</span><br><span class="line">            ptr.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) ptr.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p><p>参考归并排序的<code>merge</code>部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ptr = head;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val&lt;=l2.val) &#123;</span><br><span class="line">                ptr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>) ptr.next=l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span>) ptr.next=l1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></p><p>归并排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeKLists(lists, <span class="number">0</span>, lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l==r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        ListNode l1 = mergeKLists(lists, l, m);</span><br><span class="line">        ListNode l2 = mergeKLists(lists, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ptr = head;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val&lt;=l2.val) &#123;</span><br><span class="line">                ptr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>) ptr.next = l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span>) ptr.next = l1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></p><p>归并排序，先用快慢双指针把链表从中间断开，再使用合并排序链表的方式合并链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(left, right); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ptr = head;</span><br><span class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt;= right.val) &#123;</span><br><span class="line">                ptr.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) ptr.next = right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) ptr.next = left;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p><p>参考《剑指Offer》<a href="http://ster.im/jianzhioffer_2/#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode next = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></p><p>用快慢双指针找到链表中点并断开链表，反转其中一段链表，比较两段链表是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="comment">// 找到链表中点</span></span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        mid = reverseNode(mid);</span><br><span class="line">        <span class="comment">// 逐个比较两个链表节点</span></span><br><span class="line">        <span class="keyword">while</span> (mid!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid.val != head.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——HOT100面试题（1）</title>
      <link href="/lc_top_01/"/>
      <url>/lc_top_01/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></p><p>用哈希表存储出现过的数字，空间换时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-nums[i])) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]), i&#125;;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></p><p>可以将本题扩展到求两个有序数组中第<code>K</code>大的值。可以比较两个数组中的第<code>K/2</code>大的值（设为<code>mid1</code>和<code>mid2</code>），如果<code>mid1&lt;mid2</code>，那么<code>nums1</code>中位于<code>mid1</code>及其之前的所有数都不可能是第<code>K</code>大的数，这样就排除掉了<code>K/2</code>个数，下次讨论的范围为<code>nums1[K/2:], nums2[:]</code>（下标从0开始算）。直到<code>K==1</code>为止，只需要比较两个数组的头部元素大小即可找到所求的值。属于二分查找，时间复杂度$O(log(m+n))$。</p><p>特殊情况：</p><ul><li>如果两个数组中有一个数组为空，只需返回另一个数组的第<code>K</code>大的值。</li><li>如果一个数组长度小于<code>K/2</code>，就排除另一个数组前<code>K/2</code>个数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">        <span class="comment">// 计算中位数，避免分别讨论奇偶</span></span><br><span class="line">        <span class="keyword">int</span> mid1 = (len1+len2+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = (len1+len2+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (getKthNum(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, mid1) + getKthNum(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, mid2))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthNum</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> i, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个数组为空时，返回另一个数组的第K大的值</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length&lt;=i) <span class="keyword">return</span> nums2[j+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums2.length&lt;=j) <span class="keyword">return</span> nums1[i+k-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 递归终止条件：K==1</span></span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">        <span class="comment">// 如果一个数组不存在第K/2大的数，就除去另外一个数组的前K/2个数，这里用最大值来简化代码</span></span><br><span class="line">        <span class="keyword">int</span> num1 = i+k/<span class="number">2</span>-<span class="number">1</span>&gt;=nums1.length? Integer.MAX_VALUE: nums1[i+k/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> num2 = j+k/<span class="number">2</span>-<span class="number">1</span>&gt;=nums2.length? Integer.MAX_VALUE: nums2[j+k/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (num1&lt;=num2) <span class="keyword">return</span> getKthNum(nums1, i+k/<span class="number">2</span>, nums2, j, k-k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> getKthNum(nums1, i, nums2, j+k/<span class="number">2</span>, k-k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>前后双指针，计算并更新最大容积，并更新较矮的一侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            res = Math.max(res, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p><p>先排序数组，固定一个数，然后用前后双指针的方法找到三数之和为0的组合。注意避免重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//最小的数必须小于等于0才能使和为0</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>]==nums[i]) <span class="keyword">continue</span>;<span class="comment">//避免重复</span></span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span> (sum==<span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[k])));</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; nums[j]==nums[++j]);</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; nums[k]==nums[--k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; nums[j]==nums[++j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; nums[k]==nums[--k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/next-permutation">31. 下一个排列</a></p><ol><li>从后往前找到第一个升序数对，记数对中第一个数的下标为<code>k</code>；</li><li>在<code>k</code>之后找到最大的<code>j</code>使得<code>nums[k] &lt; nums[j]</code>；</li><li>交换<code>nums[j]</code>和<code>nums[k]</code>；</li><li>翻转<code>nums[k+1]</code>之后的序列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 从后往前找到第一个升序序列，其开始下标为k</span></span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数组完全逆序，返回升序排序后的结果</span></span><br><span class="line">        <span class="keyword">if</span> (k==-<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在nums[k+1:]找到最大的j使nums[j]&gt;nums[k]</span></span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换nums[k], nums[j]</span></span><br><span class="line">        swap(nums, j, k);</span><br><span class="line">        <span class="comment">// 翻转nums[k+1:]</span></span><br><span class="line">        reverse(nums, k+<span class="number">1</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(arr, i++, j--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></p><p>先将图像按照左对角线翻转，再按照垂直中线翻转，其效果等同于将图像顺时针旋转90°。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="comment">// 按照左对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照垂直中线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][n-j-<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/jump-game">55. 跳跃游戏</a></p><p>如果一个点可以到达，那么它之前的所有点都可以到达。遍历数组，更新可以到达的最远距离，如果当前位置超过了最远距离则返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> farest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; farest) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            farest = Math.max(i + nums[i], farest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></p><p>荷兰国旗问题。使用<code>p0</code>、<code>p2</code>两个指针分别从前后搜索<code>0</code>和<code>2</code>，以及一个指针从左往右遍历。遇到<code>0</code>就与<code>p0</code>指向的地址交换；遇到<code>2</code>就与<code>p2</code>指向的地址交换，但此时指针不前进，继续比较新值是否处在合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=p2; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = <span class="number">0</span>;</span><br><span class="line">                p0++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]==<span class="number">2</span>) &#123;</span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = <span class="number">2</span>;</span><br><span class="line">                p2--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence">128. 最长连续序列</a></p><p>使用一个哈希表来保存数组中出现过的数字，其值为该元素所在连续序列的长度。如果某个数字的前一位和后一位也存在哈希表中，说明可以组成一段连续序列，更新这个序列端点对应的长度，并更新最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left = map.getOrDefault(num-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> right = map.getOrDefault(num+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> len = left+right+<span class="number">1</span>;</span><br><span class="line">            map.put(num, len);</span><br><span class="line">            map.put(num-left, len);</span><br><span class="line">            map.put(num+right, len);</span><br><span class="line">            res = Math.max(res, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></p><p>参见《剑指Offer》<a href="http://ster.im/jianzhioffer_4/#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">数组中出现次数超过一半的数字</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vote = <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num==nums[i]) vote++;</span><br><span class="line">            <span class="keyword">else</span> vote--;</span><br><span class="line">            <span class="keyword">if</span> (vote==<span class="number">0</span>) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                vote = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></p><p>参见《剑指Offer》<a href="http://ster.im/jianzhioffer_5/#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">构建乘积数组</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">            p *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">240. 搜索二维矩阵 II</a></p><p>参见《剑指offer》<a href="http://ster.im/jianzhioffer_1/#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">二维数组中的查找</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]&gt;target) i--;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></p><p>双指针，一个指针顺序遍历，另一个指针保存所有不为0的数，然后将这个指针之后的位置填充0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j&lt;nums.length; j++) &#123;</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></p><p>由于数组元素位于1~n之间，可以把数组当作链表，将本题转化成寻找有环链表的环入口问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span> (fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span> (fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p><p>先使用哈希表把元素及其出现的次数保存起来，再使用小顶堆获取出现次数最多的K个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) map.put(num, map.getOrDefault(num, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(o2) - map.get(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            res[i] = minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></p><p>将原数组中所有正数作为数组的索引值，将这些索引值对应数组值取相反数，仍为正数的索引值即为消失的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为K的子数组</a></p><p>一段连续子数组（<code>nums[i:j]</code>）的和可以用<code>sum(nums[j]) - sum(nums[i])</code>得到。使用哈希表来保存前缀和及相等的前缀和出现的次数，判断是否存在前缀和之差为<code>k</code>的情况。哈希表中插入<code>(0, 1)</code>用于处理第一个数等于<code>k</code>的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum-k)) &#123;</span><br><span class="line">                res += map.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></p><p>一个指针从左到右遍历，不断与当前最大值比较，发现逆序就更新右边界；一个指针从右到左遍历，不断与当前最小值比较，发现逆序就更新左边界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>], min = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;=max) max = nums[i];</span><br><span class="line">            <span class="keyword">else</span> right = i;</span><br><span class="line">            <span class="keyword">if</span> (nums[nums.length-<span class="number">1</span>-i]&lt;=min) min = nums[nums.length-<span class="number">1</span>-i];</span><br><span class="line">            <span class="keyword">else</span> left = nums.length-<span class="number">1</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></p><p>不妨设<code>A</code>为需要做最多次的任务，计数为<code>k</code>。以<code>A</code>为分界点安排任务，如果其他任务恰好能全部插入到这个任务的冷却期中，此时总时间为<code>(k-1) * (n+1) + 1</code>。但若有复数个任务出现次数最多，则在最后一轮需要加上那些任务数。如果冷却时间少而任务多，间隔期间已经插满任务时还有剩余的任务，此时所花费时间就是任务总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: tasks) &#123;</span><br><span class="line">            count[c-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(count);</span><br><span class="line">        <span class="keyword">int</span> most = count[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">24</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (most==count[i]) last++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (n+<span class="number">1</span>) * (most-<span class="number">1</span>) + last;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res, tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——《剑指Offer》面试题（6）</title>
      <link href="/jianzhioffer_6/"/>
      <url>/jianzhioffer_6/</url>
      
        <content type="html"><![CDATA[<h2 id="两个面试案例"><a href="#两个面试案例" class="headerlink" title="两个面试案例"></a>两个面试案例</h2><h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><p>思路：需要考虑的点有：</p><ol><li>输入字符串为空的情况</li><li>带正负号的情况</li><li>字符串中存在非数字的情况</li><li>考虑<code>Integer</code>溢出的情况</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (l&lt;ch.length &amp;&amp; ch[l]==<span class="string">&#x27; &#x27;</span>) l++;<span class="comment">//找到第一个不为空的字符</span></span><br><span class="line">        <span class="keyword">if</span> (ch.length==l) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果字符串为空，返回0</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[l]==<span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[l]==<span class="string">&#x27;-&#x27;</span>||ch[l]==<span class="string">&#x27;+&#x27;</span>) l++;<span class="comment">//标记正负号</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, bound = Integer.MAX_VALUE/<span class="number">10</span>;<span class="comment">//防止数值越界的边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;ch.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[i]&lt;<span class="string">&#x27;0&#x27;</span>||ch[i]&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//出现非法字符，跳出</span></span><br><span class="line">            <span class="comment">//防止大数越界（-2147483648～2147483647）</span></span><br><span class="line">            <span class="keyword">if</span> (res&gt;bound || (res==bound &amp;&amp; ch[i]&gt;<span class="string">&#x27;7&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign&gt;<span class="number">0</span>?Integer.MAX_VALUE: Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + ch[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p>思路：二叉搜索树的左子节点小于根节点，右子节点大于根节点。如果根节点的值大于一个节点值而小于另一个节点值，那根节点就是所求的公共祖先。根据此性质递归求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span> || root==p || root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (p.val&lt;root.val &amp;&amp; q.val&lt;root.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (p.val&gt;root.val &amp;&amp; q.val&gt;root.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p>思路：</p><ol><li>如果root节点为空，返回null。</li><li>如果root节点为p或者q中的一个，返回其自身。</li><li>递归搜索root的左右节点。如果返回值为空，则表明p和q均不在这一侧的节点中，返回另一侧节点的搜索结果。</li><li>如果左右两侧返回的结果都为空，说明不存在公共祖先，返回null。</li><li>如果左右节点都有返回值，说明p和q分别在root的左右两侧，返回root。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span> || root==p || root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 树 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——《剑指Offer》面试题（5）</title>
      <link href="/jianzhioffer_5/"/>
      <url>/jianzhioffer_5/</url>
      
        <content type="html"><![CDATA[<h2 id="知识迁移能力"><a href="#知识迁移能力" class="headerlink" title="知识迁移能力"></a>知识迁移能力</h2><h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><p>思路：使用二分法查找数字在数组中出现的第一个位置和最后一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = getHead(array, k);</span><br><span class="line">        <span class="keyword">int</span> tail = getTail(array, k);</span><br><span class="line">        <span class="keyword">if</span> (head != -<span class="number">1</span> &amp;&amp; tail != -<span class="number">1</span>) <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHead</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt; k) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; k) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[mid-<span class="number">1</span>] == k) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTail</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt; k) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; k) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid+<span class="number">1</span> &lt; array.length &amp;&amp; array[mid+<span class="number">1</span>] == k) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h3><p>思路：二分查找，查找第一个数值和下标不相等的元素的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==mid) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的第k大的结点"><a href="#二叉搜索树的第k大的结点" class="headerlink" title="二叉搜索树的第k大的结点"></a>二叉搜索树的第k大的结点</h3><p>思路：使用中序遍历二叉搜索树得到的是有序的序列，由于本题要找第k大的节点，可以转变为右子树-&gt;根节点-&gt;左子树的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> TreeNode res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> res.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) res = root;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>思路：递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h3><p>思路：平衡二叉树左右子树高度差不超过1。可以递归比较二叉树的深度，但这样做会重复遍历多次子树，因此从下往上遍历，遇到不平衡的子树就返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left-right)&gt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a>数组中只出现一次的两个数字</h3><p>思路：一个数异或自己等于0。将数组从头到尾依次异或，得到两个只出现一次的数的异或。这个结果一定不为0，因此可根据结果的二进制中某一位“1”的位置将数组分为两组，一组数的二进制对应位置为1，另一组为0，再分别使用异或得到这两个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) xor ^= array[i];</span><br><span class="line">        <span class="keyword">int</span> index = getFirstBit1(xor);</span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBit1(array[i], index)) num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            <span class="keyword">else</span> num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstBit1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        num = num &gt;&gt; index;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中唯一只出现一次的数字"><a href="#数组中唯一只出现一次的数字" class="headerlink" title="数组中唯一只出现一次的数字"></a>数组中唯一只出现一次的数字</h3><p>思路：把数组中所有数字的二进制表示按位相加，如果某一位和能被3整除，说明哪个要找的数字的二进制那一位是0，否则是1。使用一个32位的整形数组来保存二进制位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bitmap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num&amp;<span class="number">1</span>)==<span class="number">1</span>) bitmap[<span class="number">31</span>-i]++;</span><br><span class="line">                num = num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">31</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap[i]%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                res += <span class="number">1</span>&lt;&lt;(<span class="number">31</span>-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h3><p>思路：对于排序数组，使用前后双指针包夹，如果和大于目标值，则缩右边；小于目标值则扩展左边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i],nums[j]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]+nums[j]&lt;target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h3><p>思路：使用双指针窗口扫描序列，并不断调整窗口大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        ArrayList&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>, r=<span class="number">1</span>, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=target/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum==target) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-l];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;r; i++) &#123;</span><br><span class="line">                    tmp[i-l] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(tmp);</span><br><span class="line">                sum-=l;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;target) &#123;</span><br><span class="line">                sum+=r;</span><br><span class="line">                r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum-=l;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h3><p>思路：先旋转整个句子，再旋转单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars= str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        Reverse(chars, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;=n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j==n || chars[j]==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                Reverse(chars, i, j-<span class="number">1</span>);</span><br><span class="line">                i = j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = str[start];</span><br><span class="line">            str[start]= str[end];</span><br><span class="line">            str[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p>思路：三次翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">if</span> (len&lt;<span class="number">1</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">int</span> k = n % len;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        reverseString(strs, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        reverseString(strs, <span class="number">0</span>, len-<span class="number">1</span>-k);</span><br><span class="line">        reverseString(strs, len-k, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(strs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = str[i];</span><br><span class="line">            str[i++] = str[j];</span><br><span class="line">            str[j--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><p>思路：单调队列，保证队列内的元素不递增，队列头部始终为当前滑动窗口的最大值，窗口滑动后，删除队列中所有小于新值的元素下标，并保证队列头部处于窗口中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast()&lt;nums[i]) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = queue.peekFirst();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i-k]==queue.peekFirst()) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast()&lt;nums[i]) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = queue.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h3><p>思路：单调队列，保证队列内的元素不递增，队列头部始终为当前滑动窗口的最大值，当删除元素时判断max队列头部元素是否是被删除的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        max = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; max.peekLast()&lt;value) &#123;</span><br><span class="line">            max.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        max.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (max.peekFirst()==res) max.poll();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象建模能力"><a href="#抽象建模能力" class="headerlink" title="抽象建模能力"></a>抽象建模能力</h2><h3 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h3><p>思路：动态规划，<code>dp[i][j]</code>表示<code>i</code>个骰子投出<code>j</code>点的组合数，每增加一粒骰子，就在原来的结果上分别加上1～6。n个骰子可以投出$6^n$种等可能组合（即为分母），共有$5\times n+1$种可能的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">6</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;=i*<span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">6</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j&lt;=k) <span class="keyword">break</span>;</span><br><span class="line">                    dp[i][j] += dp[i-<span class="number">1</span>][j-k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> len = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.length; i++) &#123;</span><br><span class="line">            res[i] = dp[n][n+i]*<span class="number">1.0</span>/len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h3><p>思路：忽略大小王，先看数组中是否存在重复的值，对子必然无法形成顺子；再记录最大值和最小值，比较两者的差值是否小于5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>, max = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(num)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                set.add(num);</span><br><span class="line">                min = Math.min(min, num);</span><br><span class="line">                max = Math.max(max, num);</span><br><span class="line">            &#125; <span class="keyword">else</span> count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max-min&lt;=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h3><p>思路：约瑟夫环问题，通过分析可以找到递推公式：</p><ol><li>最后一轮，剩下的元素下标为0，反推它上一轮（剩下2个元素）的下标：<code>index=(0+m)%2</code>；</li><li>倒数第二轮，剩下的元素下标为<code>index</code>，反推它上一轮（剩下2个元素）的下标：<code>(index+m)%3</code>；</li><li>以此类推，直到环中元素数量=<code>n</code>为止，就能直到它最初的下标。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            index = (index+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用数组或链表来模拟游戏过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) list.add(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            index = (index+m-<span class="number">1</span>)%list.size();</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h3><p>思路：用一个数保存之前遍历过的最小的数，每日所获得的最大利润等于当日股价减去这个最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxDiff = Math.max(prices[<span class="number">1</span>] - min, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i-<span class="number">1</span>] &lt; min) min = prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - min &gt; maxDiff) maxDiff = prices[i] - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发散思维能力"><a href="#发散思维能力" class="headerlink" title="发散思维能力"></a>发散思维能力</h2><h3 id="求-1-2-…-n"><a href="#求-1-2-…-n" class="headerlink" title="求 1+2+…+n"></a>求 1+2+…+n</h3><p>思路：首先想到利用递归求和。由于无法使用条件语句，可以巧妙利用短路的方法来实现递归终止条件。终止条件是<code>n&gt;=1</code>，当<code>n==0</code>时，发生短路直接返回<code>sum=0</code>，实现递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = (n&gt;<span class="number">0</span>) &amp;&amp; ((n+= sumNums(n-<span class="number">1</span>))&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p>思路：使用位运算。</p><ol><li>二进制按位相加，相当于按位异或，不考虑进位</li><li>进位值相当于按位与，再左移一位</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num1, carry = num2;</span><br><span class="line">        <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><p>思路：先从左到右遍历数组，累乘数组元素；再从右到左遍历数组，累乘数组元素；最后将两个累乘相乘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.length; i++) &#123;</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=A.length-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            B[j] *= base;</span><br><span class="line">            base *= A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——《剑指Offer》面试题（4）</title>
      <link href="/jianzhioffer_4/"/>
      <url>/jianzhioffer_4/</url>
      
        <content type="html"><![CDATA[<h2 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h2><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><p>思路：摩尔投票法。对于当前投票的目标数<code>num</code>，使用一个计数器<code>vote</code>，遍历数组，若当前元素等于<code>num</code>，<code>vote++</code>，否则<code>vote--</code>。若<code>vote==0</code>，更换投票的目标数。这样遍历完数组，最后留下的必然是出现次数最多的数。如果题目不能保证必定出现“出现次数超过一半的数”，需要额外计算众数出现的次数是否大于数组长度的一半。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> vote = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num==nums[i]) &#123;</span><br><span class="line">                vote++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vote--;</span><br><span class="line">                <span class="keyword">if</span> (vote==<span class="number">0</span>) &#123;</span><br><span class="line">                    num = nums[i];</span><br><span class="line">                    vote = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><p>思路一：利用快速排序思想，<code>partition</code>函数会返回一个索引，位于它之前的值都比索引所指向的值小，利用此方法找到最小的k个数时间复杂度为$O(n)$，但此方法会改变原数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (arr.length&lt;=k) <span class="keyword">return</span> arr;</span><br><span class="line">        getPivot(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPivot</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">        <span class="keyword">if</span> (p&lt;k) getPivot(arr, p+<span class="number">1</span>, r, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p&gt;k) getPivot(arr, l, p-<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序的partition函数，参考《算法》第四版的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i]&lt;pivot) <span class="keyword">if</span> (i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j]&gt;pivot) <span class="keyword">if</span> (j==lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：利用最大堆。创建一个保存k个元素的最大堆来保存最小的k个数，始终保持顶部元素为k个元素的最大值，当加入新元素时，只需与顶部元素比较。时间复杂度$O(n \log k)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (arr.length&lt;=k) <span class="keyword">return</span> arr;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size()&lt;k) maxHeap.offer(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxHeap.peek()&gt;i) &#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            res[i] = maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h3><p>思路：用一个大顶堆和一个小顶堆分别保存数据流中一半的数，始终保持大顶堆中的数字小于小顶堆中的数字，这样就可以获取位于中间的两个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 小顶堆，保证其中的元素都比大顶堆的大</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 大顶堆，保证其中的元素都比小顶堆的小</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">11</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1,Integer i2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i2-i1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为保证两个堆数据平均分配，第奇数个数放入大顶堆，第偶数个数放入小顶堆</span></span><br><span class="line">    <span class="comment">// 为保证大顶堆中的数永远小于小顶堆中的数，先把要放入大顶堆的数放入小顶堆，小顶堆弹出最小值入大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> Double (maxHeap.peek());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> Double (minHeap.peek()+maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><p>思路：如果前面数之和为负数，它对最大子数组和没有帮助，用当前元素的值作为新的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = Integer.MIN_VALUE, max = array[<span class="number">0</span>], n = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = array[i];</span><br><span class="line">            <span class="keyword">else</span> sum += array[i];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a>1~n整数中1出现的次数</h3><p>思路：以百位为例，要计算百位上数字1出现的次数，把百位之前的数字记为<code>a</code>，十位和个位组成的数字记为<code>b</code>。</p><ol><li>如果百位为0，百位1出现的次数取决于百位之前的数字，即<code>a*100</code>。</li><li>如果百位为1，百位1出现的次数既包括百位之前的数字，即<code>a*100</code>，也包括百位之后的数字，即<code>b+1</code>。</li><li>如果百位大于1，百位1出现的次数取决于百位之前的数字，即<code>(a+1)*100</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, before = <span class="number">0</span>, behind = <span class="number">0</span>, current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n/i!= <span class="number">0</span>) &#123;</span><br><span class="line">            before = n/(i*<span class="number">10</span>);</span><br><span class="line">            behind = n-(n/i)*i;</span><br><span class="line">            current = (n/i)%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (current==<span class="number">0</span>) res += i*before;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current==<span class="number">1</span>) res += i*before+behind+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += i*(before+<span class="number">1</span>);</span><br><span class="line">            i *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字序列中的某一位数字"><a href="#数字序列中的某一位数字" class="headerlink" title="数字序列中的某一位数字"></a>数字序列中的某一位数字</h3><p>思路：要确定数字序列第n位数，就先要确定n属于那一个数字（记为num）；首先要确定num是几位数。</p><ol><li>确定num是几位数。1位数包括1～9共9个数字，2位数包括10～99共90个数字，以此类推，n位数包括<code>10^(n-1)</code>开始到<code>10^n-1</code>共<code>9*10^(n-1)</code>个数字。假设通过此计算得到num是<code>digit</code>位数，该位数的第一个数为<code>start</code>。</li><li>通过n得知num是<code>digit</code>位数中的第几个，确定num。</li><li>将num转化为字符串，计算第n位是哪一个数字。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;count) &#123;</span><br><span class="line">            n -= count;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            count = start * digit * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = start + (n-<span class="number">1</span>)/digit;</span><br><span class="line">        String str = num+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> number = str.charAt((n-<span class="number">1</span>)%digit) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><p>思路：把数字转换为字符串，按照两数字组合后的顺序排序：如果<code>ab&gt;ba</code>，则<code>a&gt;b</code>，否则<code>a&lt;=b</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++) &#123;</span><br><span class="line">            str[i] = String.valueOf(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                String s1s2 = s1 + s2;</span><br><span class="line">                String s2s1 = s2 + s1;</span><br><span class="line">                <span class="keyword">return</span> s1s2.compareTo(s2s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String num: str) &#123;</span><br><span class="line">            sb.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h3><p>思路：动态规划。<code>dp[i]</code>表示从第一位数到到<code>num[i-1]</code>有几种翻译方法。如果这一位数无法和前一位数组成有效翻译，此时<code>dp[i]=dp[i-1]</code>；如果这一位可以与前一位一起翻译，此时<code>dp[i]=dp[i-2]+dp[i-1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = String.valueOf(num).toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[ch.length+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=ch.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[i-<span class="number">2</span>]==<span class="string">&#x27;1&#x27;</span> || (ch[i-<span class="number">2</span>]==<span class="string">&#x27;2&#x27;</span> &amp;&amp; ch[i-<span class="number">1</span>]&lt;=<span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ch.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h3><p>思路：动态规划，先初始化矩阵，记录最左一列和最上一行的初始值，然后遍历获得最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + res[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            res[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + res[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                res[i][j] = Math.max(res[i-<span class="number">1</span>][j], res[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h3><p>思路：滑动窗口。遍历字符串，向右扩展窗口的大小，并用一个哈希表记录字符串中每个字符出现的最后位置，当当前窗口中出现重复字符，依据哈希表中记录的位置缩小左边界，并更新最大长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                left = Math.max(left, map.get(c));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, right);</span><br><span class="line">            res = Math.max(res, right-left);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间效率与空间效率的平衡"><a href="#时间效率与空间效率的平衡" class="headerlink" title="时间效率与空间效率的平衡"></a>时间效率与空间效率的平衡</h2><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>思路：下一个丑数必定是从已有的丑数乘以2、3、5中的一个得到的最小值。维护三个指针，分别为乘以2、3、5得到的丑数，下一个丑数在这些指针指向的数乘以2/3/5产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">2</span>) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; index) &#123;</span><br><span class="line">            <span class="keyword">int</span> newUgly = Math.min(nums[p2]*<span class="number">2</span>, Math.min(nums[p3]*<span class="number">3</span>, nums[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (nums[p2]*<span class="number">2</span>==newUgly) p2++;</span><br><span class="line">            <span class="keyword">if</span> (nums[p3]*<span class="number">3</span>==newUgly) p3++;</span><br><span class="line">            <span class="keyword">if</span> (nums[p5]*<span class="number">5</span>==newUgly) p5++;</span><br><span class="line">            nums[i++] = newUgly;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串中第一个只出现一次的字符"><a href="#字符串中第一个只出现一次的字符" class="headerlink" title="字符串中第一个只出现一次的字符"></a>字符串中第一个只出现一次的字符</h3><p>思路：使用哈希表，空间换时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length()==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(chars[i])) &#123;</span><br><span class="line">                map.put(chars[i], map.get(chars[i])+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(chars[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;chars.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(chars[j])==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h3><p>思路：使用哈希表，空间换时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(ch)) map.put(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> map.put(ch, <span class="number">1</span>);</span><br><span class="line">        sb.append(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(sb.charAt(i))==<span class="number">1</span>) <span class="keyword">return</span> sb.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p>思路：归并排序，在将左子序列和右子序列合并时，如果右边指针所指向的数小于左边指针指向的数，那么左子序列中所有剩余的数与右边指针指向的数形成逆序对。只要在将右子序列中的数放入结果序列时计算逆序对即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, copy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] copy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l = mergeSort(nums, left, mid, copy);</span><br><span class="line">        <span class="keyword">int</span> r = mergeSort(nums, mid+<span class="number">1</span>, right, copy);</span><br><span class="line">        <span class="keyword">return</span> l+r+merge(nums, left, right, mid, copy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] copy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left; i&lt;=right; i++) &#123;</span><br><span class="line">            copy[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=left;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy[i]&lt;=copy[j]) &#123;</span><br><span class="line">                nums[k] = copy[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += mid-i+<span class="number">1</span>;<span class="comment">//比归并排序仅多了这一步</span></span><br><span class="line">                nums[k] = copy[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid) nums[k++] = copy[i++];</span><br><span class="line">        <span class="keyword">while</span> (j&lt;=right) nums[k++] = copy[j++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h3><p>思路：设链表A的长度为a+c，链表B的长度为b+c，其中c为公共部分。将A和B首尾相接，得到长为a+c+b的链表；同理将B和A首尾相接，得到长为b+c+a的链表，两个链表同时开始遍历，指针会在第一个公共节点相遇。如果两个链表不存在公共节点，两个指针会同时到达<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = pHead1, p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="keyword">null</span>) p1 = pHead2;</span><br><span class="line">            <span class="keyword">else</span> p1 = p1.next;</span><br><span class="line">            <span class="keyword">if</span> (p2 == <span class="keyword">null</span>) p2 = pHead1;</span><br><span class="line">            <span class="keyword">else</span> p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——《剑指Offer》面试题（3）</title>
      <link href="/jianzhioffer_3/"/>
      <url>/jianzhioffer_3/</url>
      
        <content type="html"><![CDATA[<h2 id="画图让抽象问题形象化"><a href="#画图让抽象问题形象化" class="headerlink" title="画图让抽象问题形象化"></a>画图让抽象问题形象化</h2><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>思路：使用递归，对左右子树分别取镜像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        root = reverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = reverse(root.left);</span><br><span class="line">        TreeNode right = reverse(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p>思路：</p><ol><li>判断是否同时为<code>null</code>或不为<code>null</code>。</li><li>判断根节点是否相等。</li><li>递归判断左右子树是否满足以上性质。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span> || right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(left.left, right.right) &amp;&amp; isSymmetrical(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><p>思路：此题的关键在于判断循环终止的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=n-<span class="number">1</span>, t=<span class="number">0</span>, b=m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;m*n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;=r; i++) &#123;</span><br><span class="line">                res[a] = matrix[t][i];</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=t; i&lt;=b; i++) &#123;</span><br><span class="line">                res[a] = matrix[i][r];</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (r&lt;l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=r; i&gt;=l; i--) &#123;</span><br><span class="line">                res[a] = matrix[b][i];</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=b; i&gt;=t; i--) &#123;</span><br><span class="line">                res[a] = matrix[i][l];</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例让抽象问题具体化"><a href="#举例让抽象问题具体化" class="headerlink" title="举例让抽象问题具体化"></a>举例让抽象问题具体化</h2><h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><p>思路：使用辅助栈保存最小值。当有新元素压入，将其与辅助栈栈顶值比较，若新元素较小，则将其压入辅助栈，否则复制栈顶元素，这样就保证辅助栈栈顶一直为最小值。当需要弹出元素时，最小栈也同时弹出栈顶元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (!helper.isEmpty() &amp;&amp; helper.peek()&lt;x) &#123;</span><br><span class="line">            helper.push(helper.peek());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        helper.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><p>思路：使用一个栈来模拟栈的压入、弹出序列。当有元素压入时，比较其与弹出序列相应的值，若相等则弹出并且弹出序列指针+1，否则继续压入元素。最后检查栈是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushed.length!=popped.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pushed.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pushed.length; i++) &#123;</span><br><span class="line">            stack.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; j&lt;popped.length &amp;&amp; popped[j]==stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><p>思路：即二叉树的层次遍历，使用队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.removeFirst();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分行从上往下打印二叉树"><a href="#分行从上往下打印二叉树" class="headerlink" title="分行从上往下打印二叉树"></a>分行从上往下打印二叉树</h3><p>思路：在层次遍历的基础上，使用两个标记：<code>toBePrinted</code>标记当前层剩余待打印元素的数量，<code>nextLevel</code>标记下一层需要打印的数量。当<code>toBePrinted==0</code>时，打印换行符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        <span class="keyword">int</span> toBePrinted = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextLevel = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.removeFirst();</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            toBePrinted--;</span><br><span class="line">            <span class="keyword">if</span> (toBePrinted==<span class="number">0</span>) &#123;</span><br><span class="line">                res.add(temp);</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                toBePrinted = nextLevel;</span><br><span class="line">                nextLevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h3><p>思路：使用两个栈分别保存奇数行和偶数行的节点。根节点入栈1，并弹出，其左右子节点先后入栈2，这样其弹出顺序就是先右后左；偶数行，弹出节点并将其右左子节点先后入栈1，这样其弹出顺序就是先左后右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack1.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                    TreeNode root = stack1.pop();</span><br><span class="line">                    temp.add(root.val);</span><br><span class="line">                    <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) stack2.push(root.left);</span><br><span class="line">                    <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) stack2.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">                    TreeNode root = stack2.pop();</span><br><span class="line">                    temp.add(root.val);</span><br><span class="line">                    <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) stack1.push(root.right);</span><br><span class="line">                    <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) stack1.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><p>思路：在后序遍历中，最末位的是根节点，序列中小于根节点值的是左子树，大于根节点值的是右子树，据此递归判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[r], m = l;</span><br><span class="line">        <span class="keyword">while</span> (sequence[m] &lt; root) m++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=m; j&lt;r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[j] &lt; root) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBST(sequence, l, m-<span class="number">1</span>) &amp;&amp; VerifySquenceOfBST(sequence, m, r-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>思路：DFS。访问到某一个节点，记录这个路径点，并把路径上的和与目标值比较，如果一个节点是叶子节点并且路径和等于目标，则输出，否则回到父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分解让复杂问题简单化"><a href="#分解让复杂问题简单化" class="headerlink" title="分解让复杂问题简单化"></a>分解让复杂问题简单化</h2><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><p>思路：</p><ol><li>复制节点，接在原节点的后面。</li><li>为复制节点复制<code>random</code>指针。</li><li>把复制后的节点拆出。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode pClone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            pClone.next = cur.next;</span><br><span class="line">            cur.next = pClone;</span><br><span class="line">            cur = pClone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode temp = cur.next;</span><br><span class="line">            cur.next = temp.next;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>思路：二叉搜索树的中序遍历是排序的，改造中序遍历使<code>root</code>节点转换为双向链表。保存头节点以形成环链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node prev;</span><br><span class="line">    <span class="keyword">public</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        prev.right = head;</span><br><span class="line">        head.left = prev;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        <span class="keyword">if</span> (prev!=<span class="keyword">null</span>) prev.right = root;</span><br><span class="line">        <span class="keyword">else</span> head = root;</span><br><span class="line">        root.left = prev;</span><br><span class="line">        prev = root;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p>思路：使用层次遍历将二叉树序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(node.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] nodes = data.substring(<span class="number">1</span>, data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!nodes[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                TreeNode left = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[i]));</span><br><span class="line">                node.left = left;</span><br><span class="line">                queue.offer(left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!nodes[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                TreeNode right = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[i]));</span><br><span class="line">                node.right = right;</span><br><span class="line">                queue.offer(right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p>思路：回溯。注意去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        Arrays.sort(ch);<span class="comment">//排序，避免重复</span></span><br><span class="line">        <span class="keyword">int</span>[] used = <span class="keyword">new</span> <span class="keyword">int</span>[ch.length];</span><br><span class="line">        dfs(ch, used, <span class="number">0</span>);</span><br><span class="line">        String[] ans = <span class="keyword">new</span> String[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++) &#123;</span><br><span class="line">            ans[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span>[] used, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.length()==ch.length) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;ch.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[j]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;<span class="number">0</span> &amp;&amp; ch[j-<span class="number">1</span>]==ch[j] &amp;&amp; used[j-<span class="number">1</span>]==<span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//去重</span></span><br><span class="line">            sb.append(ch[j]);</span><br><span class="line">            used[j] = <span class="number">1</span>;</span><br><span class="line">            dfs(ch, used, j);</span><br><span class="line">            used[j] = <span class="number">0</span>;</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——《剑指Offer》面试题（2）</title>
      <link href="/jianzhioffer_2/"/>
      <url>/jianzhioffer_2/</url>
      
        <content type="html"><![CDATA[<h2 id="代码的完整性"><a href="#代码的完整性" class="headerlink" title="代码的完整性"></a>代码的完整性</h2><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><p>思路：根据以下性质递归求解。</p><ol><li>n为正奇数时，$x^n = x^\frac{n}{2} \times x^\frac{n}{2} \times x$。</li><li>n为正偶数时，$x^n = x^\frac{n}{2} \times x^\frac{n}{2}$。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>/pow(x, n);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> pow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.</span>;</span><br><span class="line">        <span class="keyword">double</span> y = pow(x, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> y*y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y*y*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h3><p>思路：考虑到大数溢出情况，需要使用字符串代替数字类型，使用DFS全排列来解决此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; res;</span><br><span class="line">    <span class="keyword">public</span> StringBuilder sb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ans.length; i++) &#123;</span><br><span class="line">            ans[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==len) &#123;</span><br><span class="line">            <span class="keyword">while</span> (sb.length()&gt;<span class="number">0</span> &amp;&amp; sb.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.length()!=<span class="number">0</span>) res.add(Integer.parseInt(sb.toString()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            sb.append(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            dfs(len+<span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">if</span> (sb.length()!=<span class="number">0</span>) sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在O-1-时间内删除链表的节点"><a href="#在O-1-时间内删除链表的节点" class="headerlink" title="在O(1)时间内删除链表的节点"></a>在O(1)时间内删除链表的节点</h3><p>思路：</p><ol><li>如果该节点不是尾节点，将该节点的下一位节点值赋给它，它的<code>next</code>指针指向<code>next.next</code>；</li><li>如果链表中只有这一个节点，返回<code>null</code>；</li><li>如果该节点是尾节点，将它置为<code>null</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">if</span> (head.val==val) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head.next!=<span class="keyword">null</span> &amp;&amp; head.next.val!=val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h3><p>思路：设置双指针，一个指针指向当前节点，另一个指针搜索与当前节点不同的第一个节点。为了防止头节点被删除而导致空指针，先设置一个辅助头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next.next != <span class="keyword">null</span> &amp;&amp; next.val == next.next.val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (next.next != <span class="keyword">null</span> &amp;&amp; next.next.val == next.val) next = next.next;</span><br><span class="line">                prev.next = next.next;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><p>思路：给定字符串<code>s</code>和模式字符串<code>p</code>，设<code>dp[i][j]</code>表示<code>s[i]</code>和<code>p[j]</code>的匹配情况（这里<code>i</code>和<code>j</code>分别是字符串和模式字符串的下标）。</p><ol><li>初始状态：如果<code>s</code>为空，<code>p</code>为空，匹配成功，返回<code>true</code>；如果<code>s</code>非空，<code>p</code>为空，则匹配失败，返回<code>false</code>。其他情况需要进一步讨论。</li><li>如果<code>p[i]</code>不为<code>*</code>，那么它要么和<code>s</code>对应的字符相同，要么是<code>.</code>，此时它的匹配情况等于<code>dp[i-1][j-1]</code>，否则匹配失败。</li><li>如果<code>p[i]</code>为<code>*</code>，那么<code>p[i-1]</code>的字符可以出现0次，此时匹配情况等于<code>dp[i][j-2]</code>；或者<code>p[i-1]</code>的字符至少出现1次，此时比较<code>dp[i-1][j]</code>即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="comment">//dp[0][0]保存字符串长度为0的情形</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp[i][j]表示s[i-1]和p[j-1]是否匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>) &#123;<span class="comment">//判断初始情况</span></span><br><span class="line">                    dp[i][j] = (i==<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">//当p不是*时，比较两个字符是否匹配即可</span></span><br><span class="line">                        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//当p是*时</span></span><br><span class="line">                        <span class="comment">//可以匹配s中的0个字符，此时dp[i][j] = dp[i][j-2]</span></span><br><span class="line">                        <span class="keyword">if</span> (j&gt;<span class="number">1</span>) dp[i][j] |= dp[i][j-<span class="number">2</span>];</span><br><span class="line">                        <span class="comment">//可以匹配s中的多个字符，此时dp[i][j] = dp[i-1][j]</span></span><br><span class="line">                        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">1</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>)==<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><p>思路：需要判断<code>.</code>、<code>e</code>/<code>E</code>和<code>+</code>/<code>-</code>。</p><ol><li>小数点最多出现一次，且不能出现在<code>e</code>或<code>E</code>之后。</li><li><code>e</code>或<code>E</code>最多出现一次，且其前后要有一个合法的数。</li><li>正负号只能出现在整个数字的第一位或者<code>e</code>/<code>E</code>后的第一位。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.trim().toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (ch.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isNum = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>, hasP = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ch.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是否是数字</span></span><br><span class="line">            <span class="keyword">if</span> (ch[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i]&lt;=<span class="string">&#x27;9&#x27;</span>) isNum = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//判断正负号，要么出现在第一位，要么出现在e之后第一位</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch[i]==<span class="string">&#x27;+&#x27;</span> || ch[i]==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i!=<span class="number">0</span> &amp;&amp; ch[i-<span class="number">1</span>]!=<span class="string">&#x27;e&#x27;</span> &amp;&amp; ch[i-<span class="number">1</span>]!=<span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断E或者e，前面需要有合法数字，只能出现一次，并且重置isNum，保证e之后是合法数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch[i]==<span class="string">&#x27;E&#x27;</span> || ch[i]==<span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isNum || hasE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">                isNum = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断小数点，不能重复出现，不能出现在e之后</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch[i]==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasP || hasE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasP = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//其他非法字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>思路：使用前后双指针判断并交换奇偶数。</p><p>如果题目要求奇偶数的相对位置不变，则需要先遍历一遍数组，找到偶数的开始位置，然后两个指针分别记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; isOdd(nums[i])) i++;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; !isOdd(nums[j])) j--;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码的鲁棒性"><a href="#代码的鲁棒性" class="headerlink" title="代码的鲁棒性"></a>代码的鲁棒性</h2><h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><p>思路：使用快慢双指针，快指针先走k步，然后两个指针一起走，当快指针走到链表尾部时，慢指针所指向的就是倒数第k个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h3><p>思路：使用快慢双指针，快指针一次走2步，慢指针一次走1步。若链表存在环，则两指针必定相遇，此时慢指针到达环入口的距离等于从头节点到环入口的距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pFast = pHead;</span><br><span class="line">        ListNode pSlow = pHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            pFast = pFast.next.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pFast != pSlow);</span><br><span class="line">        pFast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (pFast != pSlow) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pSlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>思路1：递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode next = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p>思路：顺序遍历两个链表，将值较小的节点放入新的链表。当遍历完一个链表后将剩余的链表节点直接接入结果链表后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode newList = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = newList;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &gt; list2.val) &#123;</span><br><span class="line">                head.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) head.next = list2;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) head.next = list1;</span><br><span class="line">        <span class="keyword">return</span> newList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>思路：递归判断。</p><ol><li>判断B是否是A为根节点构成的树的子结构；</li><li>判断B是否是A的左子节点为根节点构成的树的子结构；</li><li>判断B是否是A的右子节点为根节点构成的树的子结构。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A==<span class="keyword">null</span> || B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(A.left, B.left) &amp;&amp; isSameTree(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> DFS </tag>
            
            <tag> 树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——《剑指Offer》面试题（1）</title>
      <link href="/jianzhioffer_1/"/>
      <url>/jianzhioffer_1/</url>
      
        <content type="html"><![CDATA[<p>刷题地址：</p><p><a href="https://www.nowcoder.com/ta/coding-interviews?page=1">牛客网</a></p><p><a href="https://leetcode-cn.com/problemset/lcof/">LeetCode</a></p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>思路：实现单例模式5种方法：饱汉式；饿汉式；双重校验锁；静态内部类；枚举类。其中常考的是双重校验锁和静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重校验锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一次判空，若存在实例就不需要获取锁，减少性能开销</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//第二次判空，避免生成多个Singleton实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>思路：设下标为<code>i</code>，下标i对应的数字为<code>nums[i]</code>，如果<code>nums[i]==i</code>，接着扫描下一个数字；如果<code>nums[i]!=i</code>，则将<code>nums[i]</code>交换到<code>i</code>的位置上。如果该位置上已经存在正确摆放的值，则这个值是重复的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[nums[i]]==nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>思路：从左下角或者右上角开始遍历（左下角的数，为该行最小值和该列最大值；右上角相反）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n &amp;&amp; j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]&lt;target) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>思路：先遍历一遍字符串，遇到空格就要使字符串的容量+2。一个指针<code>p</code>指向字符串有字符的末尾，一个指针<code>q</code>指向字符串容器的末尾，从后往前扫描，若<code>p</code>遇到空格，后指针依次填充<code>02%</code>，否则填充<code>p</code>指针指向的字符。当两指针相遇或者<code>p</code>扫描到字符串头部，结束遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=p; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span>) str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p&lt;q &amp;&amp; p&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(p--);</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                str.setCharAt(q--, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                str.setCharAt(q--, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                str.setCharAt(q--, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> str.setCharAt(q--, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>思路：利用栈后进先出的性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            res[i] = s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>思路：前序遍历的第一个值为根节点，中序遍历序列中位于根节点左边的是左子树的中序遍历，位于右边的是右子树的中序遍历。递归求解左右两子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length==<span class="number">0</span> || preorder.length!=inorder.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> reBuild(preorder, inorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reBuild</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[]in, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl&gt;pr || il&gt;ir) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[pl]);</span><br><span class="line">        <span class="keyword">if</span> (pl==pr) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (in[il+h]!=root.val) &#123;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = reBuild(pre, in, pl+<span class="number">1</span>, pl+h, il, il+h-<span class="number">1</span>);</span><br><span class="line">        root.right = reBuild(pre, in, pl+h+<span class="number">1</span>, pr, il+h+<span class="number">1</span>, ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h3><p>思路：</p><ol><li>如果一个节点有右子树，则它的中序遍历的下一个节点是它右子树的最左子节点；</li><li>如果它没有右子树，且它是其父节点的左子节点，它的下一个节点是它的父节点；</li><li>如果它没有右子树，且它是其父节点的右子节点，向上遍历找到一个是它父节点的左子节点的节点，所求的节点是其父节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) <span class="keyword">return</span> pNode;</span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode pRight = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pRight.left != <span class="keyword">null</span>) pRight = pRight.left;</span><br><span class="line">            <span class="keyword">return</span> pRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode == pNode.next.left) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>思路：一个栈<code>stack1</code>负责入栈，一个栈<code>stack2</code>负责出栈。当需要出栈时，元素先全部进入<code>stack2</code>栈，此时弹出的顺序与队列相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty()) <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>思路：可使用递归解决问题，但效率会非常低。本题只需要记录两个值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            b = a+b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h3><p>思路：本质上还是斐波那契数列问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target&lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target-<span class="number">2</span>)+JumpFloor(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找和排序"><a href="#查找和排序" class="headerlink" title="查找和排序"></a>查找和排序</h2><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><p>思路：二分查找，判断数组的旋转点在左半边还是右半边。注意处理特殊情况例如<code>[1, 1, 1, 0, 1]</code>，此时让右边界-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid]&lt;numbers[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid]&gt;numbers[right]) &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p>思路：使用DFS，递归查找该格子上下左右格子的数字是否符合要求，注意短路逻辑运算符能减少计算时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.M = board.length;</span><br><span class="line">        <span class="keyword">this</span>.N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = dfs(i, j, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=M || j&gt;=N) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span> (k&lt;word.length() &amp;&amp; board[i][j] != word.charAt(k)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (k==word.length()-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//找到路径</span></span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//将当前格子替换成其他字符，防止重复进入</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = dfs(i-<span class="number">1</span>, j, k+<span class="number">1</span>) || dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>) || dfs(i, j-<span class="number">1</span>, k+<span class="number">1</span>) || dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = tmp;<span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><p>思路：深度优先搜索，标记所有能进入的格子，然后遍历其数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> K;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = m;</span><br><span class="line">        <span class="keyword">this</span>.N = n;</span><br><span class="line">        <span class="keyword">this</span>.K = k;</span><br><span class="line">        <span class="keyword">this</span>.matrix = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="number">1</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=M || j&gt;=N) <span class="keyword">return</span>;<span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span> (!check(i, j)) <span class="keyword">return</span>;<span class="comment">//不符合要求的格子</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j]==<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//防止重复进入</span></span><br><span class="line">        matrix[i][j] = <span class="number">1</span>;<span class="comment">//标记可以进入此格</span></span><br><span class="line">        dfs(i-<span class="number">1</span>, j);</span><br><span class="line">        dfs(i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j-<span class="number">1</span>);</span><br><span class="line">        dfs(i, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            t += i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            t += j%<span class="number">10</span>;</span><br><span class="line">            j/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t&lt;=K;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划和贪婪算法"><a href="#动态规划和贪婪算法" class="headerlink" title="动态规划和贪婪算法"></a>动态规划和贪婪算法</h2><h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><p>思路：贪心算法。通过分析发现应当尽可能多的剪出长度为3的绳子；若全部剪成3的绳子之后剩余长度为1，则需要少剪一次3，改剪成2段长度为2的绳子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> exp = n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> rem = n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (rem==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, exp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rem==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, (exp-<span class="number">1</span>)) * <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, exp) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p>思路：<code>n&amp;(n-1)</code>会把<code>n</code>最低位的1变成0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            n = n&amp;(n-<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> DFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——腾讯面试精选50题（5）</title>
      <link href="/lc_tc_05/"/>
      <url>/lc_tc_05/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法和动态规划"><a href="#贪心算法和动态规划" class="headerlink" title="贪心算法和动态规划"></a>贪心算法和动态规划</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></p><p>思路：不难看出这题本质上就是斐波那契数列，也是动态规划的经典问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></p><p>思路：每日结束时有两种状态：持有股票和未持有股票。每日的状态取决于昨日的状态与今日是否买入或卖出股票。可得状态转移方程：<code>dp[i][0]=max(dp[i-1][0], dp[i-1][1]+prices[i])</code>，<code>dp[i][1]=max(dp[i-1][1], dp[i-1][0]-prices[i])</code>。</p><p>更多关于股票问题的动态规划解法详细可见<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/">LeetCode：一个方法团灭 6 道股票问题</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_i_1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">            dp_i_1 = Math.max(-prices[i], dp_i_1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></p><p>思路：只要第二天比第一天有涨，就可以卖出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&gt;prices[i-<span class="number">1</span>]) profit += prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/gray-code/">格雷编码</a></p><p>思路：格雷编码的位数每增加一，就在原有数的二进制表示最前面加1。对原序列逆序排列再加1，此时可以保证相邻两数的不同位只有1个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> plus = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size()-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                res.add(res.get(j)+plus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></p><p>思路：走到一个格子有两条路径：从它的左边一格或者从它的上边一格。由此可得状态转移方程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span> || n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;m; r++) matrix[r][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;n; c++) matrix[<span class="number">0</span>][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                matrix[i][j] = matrix[i-<span class="number">1</span>][j] + matrix[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p><a href="https://leetcode-cn.com/problems/subsets/">子集</a></p><p>思路：回溯算法，交换元素迭代后再交换回来，完成一次回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        subsets(nums, res, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;nums.length; j++) &#123;</span><br><span class="line">            temp.add(nums[j]);</span><br><span class="line">            subsets(nums, res, temp, j+<span class="number">1</span>);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></p><p>思路：回溯算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.length-<span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;nums.length; i++) &#123;</span><br><span class="line">                swap(nums, i, index);</span><br><span class="line">                permute(nums, index+<span class="number">1</span>, res);</span><br><span class="line">                swap(nums, i, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——腾讯面试精选50题（4）</title>
      <link href="/lc_tc_04/"/>
      <url>/lc_tc_04/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p><p>思路：使用深度优先搜索递归求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></p><p>思路：利用二叉搜索树的特性：每个节点的大小一定介于左孩子和右孩子之间，递归求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val&gt;p.val &amp;&amp; root.val&gt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val&lt;p.val &amp;&amp; root.val&lt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></p><p>思路：二叉搜索树的中序遍历是有序序列，使用递归进行中序遍历时，当计数到k时提前终止递归，返回当前的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span> || k&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        inOrder(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, k);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index==k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p><p>思路：使用递归的思想：如果根结点是p或q中的一个，那么它就是所求的最近公共祖先；然后搜索左右子树，如果p和q分别位于当前根结点的左右两边，那么此时的根结点就是最近公共祖先；如果p和q同时位于该节点的左子树或右子树，那么递归搜索那边的子树，直到找到公共祖先。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l != <span class="keyword">null</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></p><p>思路：对于一个根节点，如果最大和路径包含这个节点，有如下三种情况：</p><ol><li>根节点与左子树、右子树的和，这种情况就是完整的路径无法递归，直接与当前记录的最大值比较</li><li>根节点与左子树之和</li><li>根节点与右子树之和</li></ol><p>对左右子树使用递归求其路径最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getPathSum(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = Math.max(getPathSum(root.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxRight = Math.max(getPathSum(root.right), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxPath = root.val + Math.max(maxLeft, maxRight);</span><br><span class="line">        <span class="keyword">int</span> maxRoot = root.val + maxLeft + maxRight;</span><br><span class="line">        max = Math.max(max, Math.max(maxRoot, maxPath));</span><br><span class="line">        <span class="keyword">return</span> maxPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode-cn.com/problems/min-stack/">最小栈</a></p><p>思路：用一个辅助栈保存最小值。当有新值入栈时，检查该值是否比辅助栈栈顶值小，若是，则改值压入辅助栈，否则复制辅助栈栈顶值压入辅助栈。这样就保证辅助栈栈顶永远是最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (helper.isEmpty() || x&lt;helper.peek()) &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> helper.push(helper.peek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            helper.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stack.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p><p>思路：使用栈的后进先出思想：遇到左括号则入栈，遇到右括号如果则弹出栈顶，比较其是否成对。最后如果栈为空则返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch==<span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || ch!= stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/">LRU缓存机制</a></p><p>思路：Java语言的<code>LinkedHashMap</code>实现了可以用LRU排序的哈希表功能。它本质上是由哈希表+双向链表实现的。维护一个双向链表用于保持记录按照最近访问顺序排序，和一个哈希表来保存映射关系。若有读写操作，在双向链表中删除原节点，在头部插入新的节点；当加入新元素后会超过容量时，删除双向链表尾部的节点，同时在哈希表中删除对应的键值对，然后加入新元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造双向链表的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造双向链表数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node head;</span><br><span class="line">        <span class="keyword">private</span> Node tail;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="comment">// 创建头尾哑节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.prev = head;</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在头部添加元素，时间复杂度O(1)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">            x.prev = head;</span><br><span class="line">            x.next = head.next;</span><br><span class="line">            head.next.prev = x;</span><br><span class="line">            head.next = x;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除某一个节点，时间复杂度O(1)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">            x.prev.next = x.next;</span><br><span class="line">            x.next.prev = x.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除尾部的节点，并返回这个节点，时间复杂度O(1)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (tail.prev==head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node last = tail.prev;</span><br><span class="line">            remove(last);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取链表长度</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">            put(key, val);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache.size()==capacity) &#123;</span><br><span class="line">            Node last = cache.removeLast();</span><br><span class="line">            map.remove(last.key);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.add(node);</span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——腾讯面试精选50题（3）</title>
      <link href="/lc_tc_03/"/>
      <url>/lc_tc_03/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a></p><p>思路：一前一后双指针，直至两指针相遇，交换它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">反转字符串中的单词 III</a></p><p>思路：遍历字符串，遇到字母，把它添加到一个字符串缓存中，遇到空格，把字符串缓存提取出来翻转并放入结果字符串中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                res.append(reverse(word.toString())+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                word.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(reverse(word.toString()));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=c.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = c[l];</span><br><span class="line">            c[l] = c[r];</span><br><span class="line">            c[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/reverse-integer/">最长公共前缀</a></p><p>思路：选取第一个字符串为公共子串，然后遍历其他字串，维持或缩小公共前缀的长度，最终结果为全部字符串的公共子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line">            <span class="keyword">while</span> (str.indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length()-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></p><p>标签：字符串</p><p>思路：字符串模拟竖式乘法。长度为M的数字字符串num1和长度为N的数字字符串num2乘积的长度不超过M+N，其中num1[i]和num2[j]的乘积位于结果的[i+j, i+j+1]两位，将这些和累加可得结果。注意最终结果要去掉前面无意义的零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] char1 = num1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] char2 = num2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len1 = char1.length, len2 = char2.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len1+len2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len1-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=len2-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = res[i+j+<span class="number">1</span>]+(char1[i]-<span class="string">&#x27;0&#x27;</span>)*(char2[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                res[i+j+<span class="number">1</span>] = temp%<span class="number">10</span>;</span><br><span class="line">                res[i+j] += temp/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;res.length; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k==<span class="number">0</span> &amp;&amp; res[k]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sb.append(res[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p><p>思路：中心拓展法：回文子串有两种形式，一种是以一个字符为中心向两边拓展，一种是以一对相同的字符为中心向两边拓展。遍历字符串，记录回文子串的最长长度，并更新最长回文子串的起始位置和结束位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;<span class="comment">//记录回文子串起始和终止的下标</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = getPalindromeLength(str, i, i);<span class="comment">//奇数长度的回文子串</span></span><br><span class="line">            <span class="keyword">int</span> len2 = getPalindromeLength(str, i, i+<span class="number">1</span>);<span class="comment">//偶数长度的回文子串</span></span><br><span class="line">            len = Math.max(Math.max(len1, len2), len);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; (end-start+<span class="number">1</span>)) &#123;</span><br><span class="line">                start = i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取以str[i]、str[j]为中心的回文子串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPalindromeLength</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;str.length &amp;&amp; str[i]==str[j]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j-i-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></p><p>思路：要考虑的点：</p><ol><li>数字是否合法</li><li>正负号</li><li><code>Integer</code>溢出（测试用例中使用了即使是<code>Long</code>都会溢出的例子）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = chars.length, start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i]!=<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i]==<span class="string">&#x27;+&#x27;</span>||chars[i]==<span class="string">&#x27;-&#x27;</span>||(chars[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;chars[i]&gt;=<span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=start+<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j==n || chars[j]&gt;<span class="string">&#x27;9&#x27;</span> || chars[j]&lt;<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                end = j-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = myAtoi(chars, start, end);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> number = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[start]==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            start++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[start]==<span class="string">&#x27;+&#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end&amp;&amp;chars[start]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;chars[start]&gt;=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            number = number*<span class="number">10</span> + chars[start++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isNegative &amp;&amp; number &gt; Integer.MAX_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (isNegative &amp;&amp; -<span class="number">1</span>*number &lt; Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isNegative) <span class="keyword">return</span> (<span class="keyword">int</span>)number;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>*(<span class="keyword">int</span>)number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></p><p>思路：本题要求使用线性时间复杂度和不使用额外的空间复杂度。利用异或运算（相同为0，不同为1，以及0^n=n）来解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xorSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            xorSum ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xorSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/power-of-two/">2的幂</a></p><p>思路：利用2进制：2^n的2进制只有1位为1，其余为0；2^n-1的2进制全为1，但位数比2^n少一位。对他们求与运算为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;(n-<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——腾讯面试精选50题（2）</title>
      <link href="/lc_tc_02/"/>
      <url>/lc_tc_02/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">删除链表中的节点</a></p><p>思路：删除链表中的某一个节点的通常方法是要删除的节点的前一节点直接指向后一节点。这里无法向前访问节点，因此将后一节点的值赋予要删除的节点，并且该节点直接指向后后一节点（等于是删除了后一节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p><p>思路：设置一个哑节点作为原链表的头节点。将当前链表的<code>next</code>指针指向它前面的节点，然后迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><p>思路：比较两个链表的头节点，取出较小的接在合并链表节点的后面。当有一个链表已经为空时，非空的链表全部接入合并链表后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curr = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head.next = curr;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val&lt;l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>) curr.next=l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span>) curr.next=l1;</span><br><span class="line">        <span class="keyword">return</span> head.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></p><p>思路：链表A和链表B如果是等长的，那么它们一起遍历一定会遇到相交点。因此考虑使其长度等长：链表A遍历到尾节点后开始遍历链表B，同时链表B遍历完成后开始遍历链表A。它们的指针一定会在相交节点相遇（除非两个链表本身就是不相交的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode dummyA = headA;</span><br><span class="line">        ListNode dummyB = headB;</span><br><span class="line">        <span class="keyword">while</span> (headA != headB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (headA == <span class="keyword">null</span>) headA = dummyB;</span><br><span class="line">            <span class="keyword">else</span> headA = headA.next;</span><br><span class="line">            <span class="keyword">if</span> (headB == <span class="keyword">null</span>) headB = dummyA;</span><br><span class="line">            <span class="keyword">else</span> headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></p><p>思路：此题使用快慢双指针法。如果链表存在环，则两个指针必定会在某一个节点相遇，否则快指针会先到达尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sort-list/">排序链表</a></p><p>思路：题目要求时间复杂度在O(nlogn)，因此考虑使用归并排序。链表的归并排序在不使用递归的情况下可以做到常数级的空间复杂度。</p><ol><li>分割：使用快慢双指针，找到链表的中点并切断，直到分成长度为1的节点为止。然后进行合并操作。</li><li>合并：设置两个头指针，分别遍历两个链表，依次将节点合并；如果有一个链表已经遍历完，将另一个链表剩余的部分接在当前节点之后。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pFast = head.next;</span><br><span class="line">        ListNode pSlow = head;</span><br><span class="line">        <span class="keyword">while</span> (pFast != <span class="keyword">null</span> &amp;&amp; pFast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pFast = pFast.next.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = pSlow.next;</span><br><span class="line">        pSlow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt;= right.val) &#123;</span><br><span class="line">                curr.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) curr.next = right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) curr.next = left;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></p><p>标签：链表，双指针</p><p>思路：使用快慢双指针，若快指针走到链表尾节点，则表示不存在环；若存在环则两指针必定相遇，此时快指针回到头节点并与慢指针同速度遍历，两指针会在环入口相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rotate-list/">旋转链表</a></p><p>思路：与<a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a>类似，使用三次翻转来解答此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode cur = head;<span class="comment">// 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % len;<span class="comment">// 计算切分点</span></span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode res = reverseNode(head);<span class="comment">// 第一次翻转，翻转整个链表</span></span><br><span class="line">        cur = res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&gt;<span class="number">1</span>; i--) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur2 = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;<span class="comment">// 断链</span></span><br><span class="line">        ListNode res1 = reverseNode(res);<span class="comment">// 第二次翻转，翻转前k部分链表</span></span><br><span class="line">        ListNode res2 = reverseNode(cur2);<span class="comment">// 第三次翻转，翻转后k部分链表</span></span><br><span class="line">        cur = res1;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) cur = cur.next;</span><br><span class="line">        cur.next = res2;<span class="comment">// 重新链接</span></span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p><p>思路：两链表同时遍历，遇到空节点就补零。从最低位（即链表头部）相加，结果链表中每一位的值为<code>x+y+carry</code>的个位，如果发生进位，设置<code>carry=1</code>。如此遍历两个链表，最后检查是否<code>carry==1</code>，若是则添加最高位的1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = res;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (l1 == <span class="keyword">null</span>)? <span class="number">0</span>: l1.val;</span><br><span class="line">            <span class="keyword">int</span> y = (l2 == <span class="keyword">null</span>)? <span class="number">0</span>: l2.val;</span><br><span class="line">            <span class="keyword">int</span> num = x + y + carry;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                num = num % <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个排序链表</a></p><p>思路：将两个有序链表链表排序很简单。使用归并排序的思想，将多个链表先切分再两两合并，最终可得排序的链表。时间复杂度为O(n*log(k))，其中n为链表平均长度，k为链表个数；空间复杂度O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        ListNode leftNode = merge(lists, left, mid);</span><br><span class="line">        ListNode rightNode = merge(lists, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(leftNode, rightNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (list2==<span class="keyword">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1.val&gt;list2.val) &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记——腾讯面试精选50题（1）</title>
      <link href="/lc_tc_01/"/>
      <url>/lc_tc_01/</url>
      
        <content type="html"><![CDATA[<h2 id="数和数组"><a href="#数和数组" class="headerlink" title="数和数组"></a>数和数组</h2><p><a href="https://leetcode-cn.com/problems/nim-game/">Nim游戏</a></p><p>思路：如果堆中石头的数量不能被4整除，那先手方总能取得胜利。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/majority-element/">求众数</a></p><p>思路：摩尔投票法：相同加一票，不同减一票，票数为0时更换投票目标，最后的投票目标即为出现次数大于等于一半的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vote = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num==curr) vote++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (vote==<span class="number">0</span>) &#123;</span><br><span class="line">                    curr = num;</span><br><span class="line">                    vote++;</span><br><span class="line">                &#125; <span class="keyword">else</span> vote--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p><p>思路：负数不可能为回文数；将数字反转，判断数字与反转后的数字是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rev = reverseInt(x);</span><br><span class="line">        <span class="keyword">return</span> rev == x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseInt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            rev = rev*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">存在重复元素</a></p><p>思路：利用<code>set</code>不含重复元素的性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></p><p>思路：对数组从前到后进行遍历并求和，若前n项的和为负数，则该和对后面的求和最大值无增益，应舍弃，并将下一位的值作为新的和，若和为正数，则继续添加下一位的值。每次更新和时比较和的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> curSum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curSum&lt;=<span class="number">0</span>) curSum = nums[i];</span><br><span class="line">            <span class="keyword">else</span> curSum += nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></p><p>思路：利用慢指针i和快指针j，如果指向的两数相等则增加j以跳过重复项，否则令<code>nums[i+1]=nums[j]</code>，并递增i直到指针j到达末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[j]) &#123;</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></p><p>思路：由于<code>nums1</code>给了足够的空间，指针从后向前扫描，逐个比较<code>nums1</code>和<code>nums2</code>的末位元素的大小，若<code>nums1[i]&gt;nums2[i]</code>，将<code>nums1[i]</code>放入<code>nums1</code>的最末位。若指针扫描完<code>nums1</code>时<code>nums2</code>未扫描完，把<code>nums2</code>的剩余部分全部置入<code>nums1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m&gt;<span class="number">0</span> &amp;&amp; n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[m-<span class="number">1</span>]&gt;nums2[n-<span class="number">1</span>]) &#123;</span><br><span class="line">                nums1[index] = nums1[m-<span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index] = nums2[n-<span class="number">1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                nums1[i] = nums2[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p><p>思路：在<code>Integer</code>类型中，整数的范围是[−2^31, 2^31−1]。以正数为例，在使用10*REV+POP时，如果REV/10大于INT_MAX，则必定发生溢出；如果REV/10刚好等于INT_MAX，比较POP是否大于7（int最大正数个位数是7，最小负数个位数是8），若大于则溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> || rev == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; pop &gt;<span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> || rev == Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵 II</a></p><p>思路：模拟指针运行的路径。设定边界坐标：左<code>l</code>，右<code>r</code>，上<code>t</code>，下<code>b</code>。</p><ol><li>从左往右，l-&gt;r，横坐标不变，纵坐标变；</li><li>从上到下，t-&gt;b，纵坐标不变，横坐标变；</li><li>从右往左，r-&gt;l，横坐标不变，纵坐标变；</li><li>从下到上，b-&gt;t，纵坐标不变，横坐标变。</li></ol><p>循环的终止条件为计数器到达n*n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n-<span class="number">1</span>, t = <span class="number">0</span>, b = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n*n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;=r; i++) &#123;</span><br><span class="line">                res[t][i] = num++;</span><br><span class="line">            &#125;t++; <span class="comment">//从左往右</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=t; i&lt;=b; i++) &#123;</span><br><span class="line">                res[i][r] = num++;</span><br><span class="line">            &#125;r--; <span class="comment">//从上往下</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=r; i&gt;=l; i--) &#123;</span><br><span class="line">                res[b][i] = num++;</span><br><span class="line">            &#125;b--; <span class="comment">//从右往左</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=b; i&gt;=t; i--) &#123;</span><br><span class="line">                res[i][l] = num++;</span><br><span class="line">            &#125;l++; <span class="comment">//从下往上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">除自身以外数组的乘积</a></p><p>思路：首先从前往后遍历，第一个值设为1，之后为乘以前面一个元素的乘积，那么遍历一遍过后，数组中保存的是原数组对应位置元素左边元素的累乘。再从右往左如此遍历，则可以得到原数组对应位置元素右边元素的累乘。将这两个结果相乘，即得除自身以外元素的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            res[i] = k;</span><br><span class="line">            k *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=nums.length-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            res[j] *= k;</span><br><span class="line">            k *= nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p><p>思路：采用前后双指针扫描，计算此时的面积并记录最大值。由于面积取决于较低的一条边，更新横坐标时，为了尽快到达最大值，优先让较低的一条边向内靠拢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            res = Math.max(res, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></p><p>思路：先对数组排序。然后遍历数组，固定一个数，将其后的数字用前后双指针进行遍历，比较三数之和与目标值的大小，保存与目标值最接近的三数之和。时间复杂度：O(nlongn)+O(n^2)=O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;k) &#123;</span><br><span class="line">                <span class="keyword">int</span> threeSum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(threeSum-target)&lt;Math.abs(res-target)) res = threeSum;</span><br><span class="line">                <span class="keyword">if</span> (threeSum&lt;target) j++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (threeSum&gt;target) k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p><p>思路：创建一个小顶堆，将元素保存在堆中，保证堆的大小&lt;=k，这样位于堆顶的元素就是所求的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;k) minHeap.offer(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&gt;minHeap.peek()) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p><p>思路：使用二分查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo&lt;=hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo]&lt;=nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[lo]&lt;=target&amp;&amp;nums[mid]&gt;=target) hi=mid;</span><br><span class="line">                <span class="keyword">else</span> lo = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&lt;=target&amp;&amp;nums[hi]&gt;=target) lo = mid;</span><br><span class="line">                <span class="keyword">else</span> hi = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵</a></p><p>思路：参见《剑指offer》[顺时针打印矩阵]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m =matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 利用左上角坐标(start, start)来标记圈数</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start*<span class="number">2</span>&lt;m &amp;&amp; start*<span class="number">2</span>&lt;n) &#123;</span><br><span class="line">            res.addAll(printCircle(matrix, m, n, start));</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">printCircle</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> x = n-<span class="number">1</span>-start, y = m-<span class="number">1</span>-start;</span><br><span class="line">        <span class="comment">// left-&gt;right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=x; i++) &#123;</span><br><span class="line">            res.add(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//top-&gt;bottom</span></span><br><span class="line">        <span class="keyword">if</span> (start&lt;y) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;=y; i++) &#123;</span><br><span class="line">                res.add(matrix[i][x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//right-&gt;left</span></span><br><span class="line">        <span class="keyword">if</span> (start&lt;x &amp;&amp; start&lt;y) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=x-<span class="number">1</span>;i&gt;=start;i--) &#123;</span><br><span class="line">                res.add(matrix[y][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bottom-&gt;top</span></span><br><span class="line">        <span class="keyword">if</span> (start&lt;x &amp;&amp; start&lt;y-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=y-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--) &#123;</span><br><span class="line">                res.add(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></p><p>思路：考察对于特殊用例如边界值的处理以及对于算法的优化。</p><ol><li>先排除一些不存在解的情况，比如元素全部为正数，或者数组长度少于3的情况；</li><li>对数组排序，固定一个数，然后用前后双指针遍历数组，找到和为0的数组，加入解的集合；</li><li>在每一次指针变更时，要注意去除重复项。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;k &amp;&amp; nums[j+<span class="number">1</span>] == nums[j]) j++;</span><br><span class="line">                    <span class="keyword">while</span> (k&gt;j &amp;&amp; nums[k-<span class="number">1</span>] == nums[k]) k--;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) j++;</span><br><span class="line">                <span class="keyword">else</span> k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个有序数组的中位数</a></p><p>思路：题目要求时间复杂度O(logn)，因此只能使用二分查找。</p><p>把此题扩展到查找两个有序数组中第k大的数。如果两个数组长度和<code>m+n</code>为奇数，只需要求<code>k=(m+n+1)/2</code>；如果<code>m+n</code>是偶数，求出<code>k=(m+n+1)/2</code>和<code>k=(m+n+2)/2</code>的均值（m、n分别为数组A、数组B的长度；k从1开始计算，数组下标从0开始计算）。</p><p>比较两个有序数组的第<code>k/2</code>个数字。如果<code>A[k/2+1]&lt;B[k/2+1]</code>，说明<code>A[k/2+1]</code>以及位于它之前的A中的元素都不可能是第k个元素，把它们排除，然后继续按照此方法比较剩下的元素中第<code>k-k/2</code>个元素。</p><p>如果有一个数组为空了，那么另一个数组的第k个元素就是两个数组中的第k个元素。</p><p>如果<code>k=1</code>，则比较两个数组的头元素，取其中较小的那个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(findKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (k+<span class="number">1</span>)/<span class="number">2</span>));</span><br><span class="line">        &#125; <span class="comment">// k为奇数的情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, k/<span class="number">2</span>)+findKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (k+<span class="number">2</span>)/<span class="number">2</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="comment">// k为偶数的情况</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">// 如果有一个数组为空，取另一个数组的第k个元素</span></span><br><span class="line">        <span class="keyword">if</span> (m-i1&lt;=<span class="number">0</span>) <span class="keyword">return</span> nums2[i2+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (n-i2&lt;=<span class="number">0</span>) <span class="keyword">return</span> nums1[i1+k-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果k==1，取两数组头部元素中较小的那一个</span></span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[i1], nums2[i2]);</span><br><span class="line">        <span class="comment">// 比较第k/2个元素的大小</span></span><br><span class="line">        <span class="keyword">int</span> mid = k/<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当第k/2个元素的指针超过数组长度时，取那个数组的尾元素进行比较</span></span><br><span class="line">        <span class="keyword">int</span> j1 = Math.min(m-<span class="number">1</span>, i1+mid);</span><br><span class="line">        <span class="keyword">int</span> j2 = Math.min(n-<span class="number">1</span>, i2+mid);</span><br><span class="line">        <span class="comment">// 删除第k/2个元素较小的那个数组的前k/2个元素，同时缩小k</span></span><br><span class="line">        <span class="keyword">if</span> (nums1[j1]&lt;nums2[j2]) <span class="keyword">return</span> findKth(nums1, nums2, j1+<span class="number">1</span>, i2, k-j1-<span class="number">1</span>+i1);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums1, nums2, i1, j2+<span class="number">1</span>, k-j2-<span class="number">1</span>+i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle机器学习实战（6）——MNIST（下）</title>
      <link href="/kaggle_06/"/>
      <url>/kaggle_06/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ster.im/kaggle_04/">之前</a>已经使用TensorFlow的高层封装Keras运行过一次CNN，这次直接使用TensorFlow复现经典的LeNet-5来完成MNIST手写数字识别，顺便学习一下TensorFlow的基本使用方法。</p><h2 id="LeNet简介"><a href="#LeNet简介" class="headerlink" title="LeNet简介"></a>LeNet简介</h2><p>LeNet出自Yann LeCun于1998年发表的经典论文<a href="http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf">《Gradient-Based Learning Applied to Document Recognition》</a>，他首次使用卷积神经网络进行手写数字识别，并达到了惊人的99.2%的准确率。他在文章中详细阐述了卷积核以及降采样的用处，并因此被认为是卷积神经网络之父。由于当时受制于数据量与算力，卷积神经网络没能得到更进一步的发展，直到2012年的AlexNet横空出世，才让人们对CNN的认识达到了空前的高度。</p><p>该网络共有7层构成（不包括输入层）：</p><ul><li>输入层为经过处理的32×32×1的手写数字图像。</li><li>第1层为使用大小为5×5、深度为6的卷积层，不使用填充，步长为1，经过卷积处理的图像的边长变为((32－5)/1＋1＝28)。该层共有(5×5＋1)×6＝156)个参数。</li><li>第2层为使用2×2的平均池化层（降采样层），经过处理的图像的边长变为14。并用Sigmoid函数去线性化。</li><li>第3层为使用大小为5×5、深度为16的卷积层，但是每个卷积核与上一层的多个特征图谱相连接。经过卷积处理的图像的边长变为((14－5)/1＋1＝10)。该层共有1516个参数。</li><li>第4层为池化层，经过处理的图像的边长变为5。</li><li>第5层为使用大小为5×5、深度为120的卷积层，经过卷积处理的图像的边长变为((5－5)/1＋1＝1)，由于这一步实际上将图像展开为一维向量，可以视为全连接层。共有48120个参数。</li><li>第6层为全连接层，共有84个节点，使用Sigmoid激活函数。共有((120＋1)×84＝10164)个参数。</li><li>第7层为输出层，使用RBF函数，可认为输出的是输入图像与各数字ASCII编码图的相似度，越接近于0表示与该标准图像越接近。</li></ul><p>原论文中附有网络结构的图解，结合图片能对该网络有更好的认识。</p><p>现在结合Kaggle上的入门训练<a href="https://www.kaggle.com/c/digit-recognizer">《Digit Recognizer》</a>并使用TensorFlow加深对卷积神经网络的认识。本文参考了一篇kernel：<a href="https://www.kaggle.com/kakauandme/tensorflow-deep-nn">《TensorFlow deep NN》</a>，以及《TensorFlow实战Google深度学习框架》、《TensorFlow技术解析与实战》两本书。</p><h2 id="使用TensorFlow构建卷积神经网络"><a href="#使用TensorFlow构建卷积神经网络" class="headerlink" title="使用TensorFlow构建卷积神经网络"></a>使用TensorFlow构建卷积神经网络</h2><p>TensorFlow是目前运用最多的深度学习框架，每个人工智能学者当熟练运用之。而本次最简单的CNN只用到几个简单的API。更进一步的操作包括TensorBoard、RNN等有时间会进一步学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><p>虽然TensorFlow可以调用自带的数据集API来读取MNIST数据，但依然严格按照Kaggle提供的数据进行实践。Kaggle上的练习提供了42000个带标签的训练集样本和28000个测试集样本。每个样本具有784个特征。我们的模型接收具有4个维度的输入，第一维表示样本量，第二维和第三维表示图像的尺寸，第四维表示颜色通道数。我们需要将其转换为需要的数据类型，并进行标准化。最后，分割训练集和验证集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>)</span><br><span class="line">test = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y = train[<span class="string">&#x27;label&#x27;</span>].values</span><br><span class="line">train.drop([<span class="string">&#x27;label&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">train = train / <span class="number">255.</span></span><br><span class="line">test = test / <span class="number">255.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为合适的shape</span></span><br><span class="line">train = train.values.reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br><span class="line">test = test.values.reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对y进行one-hot编码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot_encoding</span>(<span class="params">y, C</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.eye(C)[y.reshape(-<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">y = one_hot_encoding(y, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆分训练集和验证集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(train, y, test_size=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>卷积神经网络经过20年的发展，相较1998年的LeNet，现常用的CNN已有较大变化：</p><ul><li>输入层图片大小从32×32×1改为28×28×1，直接使用标准MNIST数据；</li><li>使用最大池化代替平均池化；</li><li>激活函数从Sigmoid换成了ReLU，后者是目前最常用的激活函数；</li><li>在全连接层之间添加了一层Dropout，可以防止过拟合；</li><li>最后的多分类输出层使用Softmax函数。</li></ul><p>本次练习采用的模型为：CONV-&gt;MAX_POOL-&gt;CONV-&gt;MAX_POOL-&gt;FC-&gt;Dropout-&gt;FC-&gt;Softmax，具有7层深度的结构在能得到较高的准确率的同时，也能在一块普通GPU上很快跑完。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">LEARNING_RATE = <span class="number">1e-3</span> <span class="comment">#初始学习率</span></span><br><span class="line">KEEP_PROB = <span class="number">1.0</span> <span class="comment">#Dropout保留神经元的比例</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span> <span class="comment">#一个batch的大小</span></span><br><span class="line">EPOCHS = <span class="number">200</span> <span class="comment">#整个数据集迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义占位符，shape[0]设为None便于自定batch的大小</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=[<span class="literal">None</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">y_ = tf.placeholder(tf.float32, shape=[<span class="literal">None</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装接下来会重复使用的代码</span></span><br><span class="line"><span class="comment"># 随机初始化权重</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight</span>(<span class="params">shape</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.Variable(tf.truncated_normal(shape, mean=<span class="number">0</span>, stddev=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常量初始化偏置项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias</span>(<span class="params">shape</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.Variable(tf.constant(<span class="number">0.1</span>, shape=shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span>(<span class="params">X, W, strides=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(X, W, strides=[<span class="number">1</span>, strides, strides, <span class="number">1</span>], padding=<span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 池化层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool</span>(<span class="params">X, k=<span class="number">2</span>, strides=<span class="number">2</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(X, ksize=[<span class="number">1</span>, k, k, <span class="number">1</span>], strides=[<span class="number">1</span>, strides, strides, <span class="number">1</span>], padding=<span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">X, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(tf.nn.bias_add(X, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全连接层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense</span>(<span class="params">X, W, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> relu(tf.matmul(X, W), b)</span><br></pre></td></tr></table></figure><h3 id="层1：卷积层"><a href="#层1：卷积层" class="headerlink" title="层1：卷积层"></a>层1：卷积层</h3><p>第一层卷积层采用5×5的卷积核，深度为32，步长为1，使用全0填充使输出图像的维度与输入相同（<code>padding=&#39;SAME&#39;</code>）。输入数据的尺寸为（<code>BATCH_SIZE</code>×28×28×1），其中<code>BATCH_SIZE</code>为预先设置好的超参数。在大多数深度学习任务中，通常会使用mini-batch梯度下降，能够保证内存不溢出并提高收敛速度。由于MNIST是一个很小的数据集，因此将整个数据集用于一次迭代也是可行的。</p><p>卷积后，图像的尺寸为28×28×32。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W1 = weight([<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">32</span>])</span><br><span class="line">b1 = bias([<span class="number">32</span>])</span><br><span class="line">CONV1 = relu(conv(X, W1), b1)</span><br></pre></td></tr></table></figure><h3 id="层2：池化层"><a href="#层2：池化层" class="headerlink" title="层2：池化层"></a>层2：池化层</h3><p>第二层池化层采用2×2的最大池化，步长为2，使用全0填充。池化处理后图像的尺寸为14×14，深度为32。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POOL2 = pool(CONV1)</span><br></pre></td></tr></table></figure><h3 id="层3：卷积层"><a href="#层3：卷积层" class="headerlink" title="层3：卷积层"></a>层3：卷积层</h3><p>第三层卷积层采用5×5的卷积核，深度为64，步长为1，使用全0填充。卷积后，图像的尺寸为14×14×64。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W2 = weight([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">b2 = bias([<span class="number">64</span>])</span><br><span class="line">CONV3 = relu(conv(POOL2, W2), b2)</span><br></pre></td></tr></table></figure><h3 id="层4：池化层"><a href="#层4：池化层" class="headerlink" title="层4：池化层"></a>层4：池化层</h3><p>第四层池化层采用2×2的最大池化，步长为2，使用全0填充。池化处理后图像的尺寸为7×7，深度为64。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POOL4 = pool(CONV3)</span><br></pre></td></tr></table></figure><h3 id="层5：全连接层-Dropout"><a href="#层5：全连接层-Dropout" class="headerlink" title="层5：全连接层+Dropout"></a>层5：全连接层+Dropout</h3><p>该层为传统神经网络结构，首先需要将上一层输出的矩阵扁平化，再使用ReLU激活函数。然后使用Dropout稀疏化矩阵并且防止过拟合。<code>keep_prob</code>参数表示保留的神经元数目，例如该参数设置为0.7即表示有30%的神经元被抑制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展开</span></span><br><span class="line">Flatten = tf.reshape(POOL4,[-<span class="number">1</span>,<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</span><br><span class="line"></span><br><span class="line">W3 = weight([<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>,<span class="number">1024</span>])</span><br><span class="line">b3 = bias([<span class="number">1024</span>])</span><br><span class="line">FC5 = dense(Flatten, W3, b3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dropout</span></span><br><span class="line">Dropout = tf.nn.dropout(FC5, keep_prob=KEEP_PROB)</span><br></pre></td></tr></table></figure><h3 id="层6：全连接层"><a href="#层6：全连接层" class="headerlink" title="层6：全连接层"></a>层6：全连接层</h3><p>该层经过Softmax函数即可输出样本属于各个类别的概率，但由于损失函数需未经Softmax的输出值，这里暂时先不进行Softmax操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W4 = weight([<span class="number">1024</span>,<span class="number">10</span>])</span><br><span class="line">b4 = bias([<span class="number">10</span>])</span><br><span class="line">FC6 = tf.add(tf.matmul(Dropout, W4),b4)</span><br></pre></td></tr></table></figure><h3 id="训练及评估模型"><a href="#训练及评估模型" class="headerlink" title="训练及评估模型"></a>训练及评估模型</h3><p>对于多分类任务，通常使用交叉熵损失函数，TensorFlow有<code>softmax_cross_entropy_with_logits</code>和<code>sparse_softmax_cross_entropy_with_logits</code>两种封装好的损失函数，前者适用于one-hot编码后的标签输入，后者适用于原始标签输入。两者都会先对输入数据进行一层softmax，因此这里的<code>logits</code>需要接收未经过softmax层的上一层的输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义交叉熵损失函数</span></span><br><span class="line">cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=FC6))</span><br></pre></td></tr></table></figure><p>然后定义优化器，这里选择Adam优化器，参数一般只需设置初始学习率即可，其他保持默认设置。优化目标即为最小化损失函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义优化器与优化目标</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=LEARNING_RATE)</span><br><span class="line">train_step = optimizer.minimize(cross_entropy)</span><br></pre></td></tr></table></figure><p>然后使用准确率作为评估指标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义评估指标</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(FC6, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br></pre></td></tr></table></figure><p>使用<code>tf.Session</code>会话机制开始训练模型。设置每10个epoch输出一次在验证集上的准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 全局初始化参数</span></span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    <span class="comment"># mini-batch</span></span><br><span class="line">    epoch = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> epoch &lt;= EPOCHS:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train) // BATCH_SIZE + <span class="number">1</span>):</span><br><span class="line">            start = i*BATCH_SIZE</span><br><span class="line">            end = <span class="built_in">min</span>((i+<span class="number">1</span>)*BATCH_SIZE, <span class="built_in">len</span>(X_train))</span><br><span class="line">            train_step.run(feed_dict=&#123;X: X_train[start:end], y_: y_train[start:end]&#125;)</span><br><span class="line">        <span class="comment"># 每过10个epoch，输出一次当前的验证集精度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> epoch % <span class="number">10</span>:</span><br><span class="line">            dev_accuracy = accuracy.<span class="built_in">eval</span>(feed_dict=&#123;X:X_test, y_:y_test&#125;)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Epoch %d, validation accuracy: %g&quot;</span>%(epoch, dev_accuracy))</span><br><span class="line">        epoch += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>经过200个epoch的迭代，在验证集上的准确率达到了99.119%。想要进一步提高模型的性能，可以扩大训练集，例如使用数据增强对图片进行轻微的变形等，更直接的办法是把整个数据集作为训练集而不采用验证集。接下来用整个训练集重新训练模型，并在测试集上预测，最后上传至Kaggle查看得分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output = tf.nn.softmax(FC6)</span><br><span class="line">label = np.zeros(test.shape[<span class="number">0</span>])</span><br><span class="line">pred = tf.argmax(output, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    epoch = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> epoch &lt;= EPOCHS:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train) // BATCH_SIZE + <span class="number">1</span>):</span><br><span class="line">            start = i*BATCH_SIZE</span><br><span class="line">            end = <span class="built_in">min</span>((i+<span class="number">1</span>)*BATCH_SIZE, <span class="built_in">len</span>(train))</span><br><span class="line">            train_step.run(feed_dict=&#123;X: train[start:end], y_: y[start:end]&#125;)</span><br><span class="line">        epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test) // BATCH_SIZE + <span class="number">1</span>):</span><br><span class="line">        start = j*BATCH_SIZE</span><br><span class="line">        end = <span class="built_in">min</span>((j+<span class="number">1</span>)*BATCH_SIZE, <span class="built_in">len</span>(test))</span><br><span class="line">        label[start:end] = pred.<span class="built_in">eval</span>(feed_dict=&#123;X: test[start:end]&#125;)</span><br></pre></td></tr></table></figure><p>得到了测试集上的预测，然后导出预测的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label = label.astype(<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">ImageId = np.arange(<span class="number">1</span>, test.shape[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">submission = pd.DataFrame(&#123;<span class="string">&#x27;ImageId&#x27;</span>: ImageId, <span class="string">&#x27;Label&#x27;</span>: label&#125;)</span><br><span class="line">submission.to_csv(<span class="string">&quot;MNISTSubmission.csv&quot;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>在测试集上取得了0.98742的准确率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>这次实现的是最简单的卷积神经网络，更深、更加实用的CNN包括Inception、ResNet等有待进一步学习。</li><li>相比于易于使用的Keras，TensorFlow最大的优势是能够自定义网络（虽然本文没有体现）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle机器学习实战（5）——再探泰坦尼克</title>
      <link href="/kaggle_05/"/>
      <url>/kaggle_05/</url>
      
        <content type="html"><![CDATA[<p>之前已经看过一篇<a href="http://ster.im/kaggle_01/">Megan Risdal的kernel</a>，她使用R语言、随机森林进行了建模。那时我是个纯新手，连依葫芦画瓢都不会。现在通过周志华老师的《机器学习》、吴恩达老师的coursera课程、查阅相关文档掌握的调包侠知识，总算是可以把这个经典入门案例拿过来练练手。</p><p>关于EDA部分，由于和其他人的步骤大同小异，也没有新的发现，就略过不谈。在模型方面，首先是调用sklearn包中一些常见的分类器查看其分类效果，其次是使用Stacking方法进行集成，最后的结果会提交到kaggle上。</p><p>本文参考了4篇点赞数量较高的kernel：</p><ul><li>Anisotropic：<a href="https://www.kaggle.com/arthurtok/introduction-to-ensembling-stacking-in-python">《Introduction to Ensembling/Stacking in Python》</a></li><li>Megan Risdal：<a href="https://www.kaggle.com/mrisdal/exploring-survival-on-the-titanic">《Exploring Survival on the Titanic》</a></li><li>Manav Sehgal：<a href="https://www.kaggle.com/startupsci/titanic-data-science-solutions">《Titanic Data Science Solutions》</a></li><li>Yassine Ghouzam：<a href="https://www.kaggle.com/yassineghouzam/titanic-top-4-with-ensemble-modeling">《Titanic Top 4% with ensemble modeling》</a></li></ul><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegressionCV</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br></pre></td></tr></table></figure><p>对数据进行简单预处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&quot;train.csv&quot;</span>)</span><br><span class="line">test = pd.read_csv(<span class="string">&quot;test.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">y = train[<span class="string">&quot;Survived&quot;</span>]</span><br><span class="line">train = train.drop([<span class="string">&quot;Survived&quot;</span>], axis=<span class="number">1</span>)</span><br><span class="line">all_data = pd.concat([train, test])</span><br><span class="line">PassengerId = test[<span class="string">&quot;PassengerId&quot;</span>]</span><br><span class="line">all_data = all_data.drop([<span class="string">&quot;PassengerId&quot;</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练集和测试集共有&#123;0&#125;个样本和&#123;1&#125;个特征。&#x27;</span>.<span class="built_in">format</span>(all_data.shape[<span class="number">0</span>], all_data.shape[<span class="number">1</span>]))</span><br><span class="line">all_data.head()</span><br></pre></td></tr></table></figure><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><h3 id="查看缺失值"><a href="#查看缺失值" class="headerlink" title="查看缺失值"></a>查看缺失值</h3><p>使用<code>isnull()</code>方法查看缺失值，并按降序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>可以看到：<code>Cabin</code>具有1014个缺失值；<code>Age</code>具有263个缺失值；<code>Embarked</code>具有2个缺失值；<code>Fare</code>具有1个缺失值。我们将分别用不同的手段处理它们。</p><h3 id="处理’Cabin’的缺失值"><a href="#处理’Cabin’的缺失值" class="headerlink" title="处理’Cabin’的缺失值"></a>处理’Cabin’的缺失值</h3><p><code>Cabin</code>（客舱号）缺失值达到77%，我们可以考虑舍弃掉这个变量。仔细分析，可以理解成：不为空的表示该乘客有客舱，为空的表示没有客舱。因此，把这个变量转换为一个二值变量，即“有客舱”，就实现了对数据的利用。或许提取客舱号第一位的字母能更进一步的利用此条数据，但从他人的kernel中看出似乎没有太大的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;Cabin&quot;</span>] = all_data[<span class="string">&quot;Cabin&quot;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> <span class="built_in">type</span>(x) == <span class="built_in">float</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="处理’Age’的缺失值"><a href="#处理’Age’的缺失值" class="headerlink" title="处理’Age’的缺失值"></a>处理’Age’的缺失值</h3><p><code>Age</code>（年龄）缺失值达到了20%，已经超过可以舍弃的阈值了。但年龄绝对是一个非常重要的变量，因此要好好地去填充缺失值。一种方法是使用随机数填充，随机数的上下限是（均值±标准差）。另一种是使用其他变量（如票价、船舱等级）来“猜”年龄。</p><p>这里参照Anisotropic和Yassine Ghouzam，结合了两种方法。Yassine发现年龄与船舱等级、亲属数量有较强的相关性，因此找缺失年龄的样本是否具有与其同样<code>Pclass</code>、<code>SibSp</code>和<code>Parch</code>的样本，有的话就取这些样本年龄的中值，否则取所有样本年龄的中值。我在处理没有类似的样本时，取（均值±标准差）中的随机整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取空值的index</span></span><br><span class="line">index_NaN_age = <span class="built_in">list</span>(all_data[<span class="string">&quot;Age&quot;</span>][all_data[<span class="string">&quot;Age&quot;</span>].isnull()].index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认用随机数填充</span></span><br><span class="line">age_mean = all_data[<span class="string">&quot;Age&quot;</span>].mean()</span><br><span class="line">age_std = all_data[<span class="string">&quot;Age&quot;</span>].std()</span><br><span class="line">age_random_list = np.random.randint(age_mean-age_std, age_mean+age_std, size=<span class="built_in">len</span>(index_NaN_age))</span><br><span class="line">all_data[<span class="string">&quot;Age&quot;</span>][all_data[<span class="string">&quot;Age&quot;</span>].isnull()] = age_random_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当存在类似情况时，用类似样本的中位数填充空值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> index_NaN_age:</span><br><span class="line">    same_samples_age = all_data[<span class="string">&quot;Age&quot;</span>][((all_data[<span class="string">&quot;SibSp&quot;</span>] == all_data[<span class="string">&quot;SibSp&quot;</span>].iloc[i]) &amp; (all_data[<span class="string">&quot;Parch&quot;</span>] == all_data[<span class="string">&quot;Parch&quot;</span>].iloc[i]) &amp; (all_data[<span class="string">&quot;Pclass&quot;</span>] == all_data[<span class="string">&quot;Pclass&quot;</span>].iloc[i]))].median()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> np.isnan(same_samples_age):</span><br><span class="line">        all_data[<span class="string">&quot;Age&quot;</span>].iloc[i] = same_samples_age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否完全填充</span></span><br><span class="line"><span class="keyword">assert</span> all_data[<span class="string">&quot;Age&quot;</span>].isnull().<span class="built_in">sum</span>() == <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="处理’Embarked’和’Fare’的缺失值"><a href="#处理’Embarked’和’Fare’的缺失值" class="headerlink" title="处理’Embarked’和’Fare’的缺失值"></a>处理’Embarked’和’Fare’的缺失值</h3><p>这两项缺失值很少，可以逐个填充。</p><p>先来看<code>Embarked</code>（登船港口），只有两个缺失值。将他们挑出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛出两条缺失值</span></span><br><span class="line">all_data[all_data[<span class="string">&quot;Embarked&quot;</span>].isnull()]</span><br></pre></td></tr></table></figure><p>大多数人使用众数<code>S</code>填充，因为从<code>S</code>登船的占对大多数；而Megan Risdal则通过观察，选择了用<code>C</code>填充。</p><p>可以发现：她们票号一致，所以必然是同一个港口上船的。观察同为头等舱的三个港口上船乘客的票价的均值、中位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[all_data[<span class="string">&quot;Pclass&quot;</span>]==<span class="number">1</span>].groupby(<span class="string">&quot;Embarked&quot;</span>)[<span class="string">&quot;Fare&quot;</span>].describe()</span><br></pre></td></tr></table></figure><p>其实无论是用<code>C</code>还是<code>S</code>填充都是合理的。80刀的票价，在C港口登船的头等舱的所有票价中位于中位数附近，且与在S港口登船的头等舱票价均值相近（接近75%四分位点）。由于<code>S</code>是众数（无论实在样本里，还是在众多解答者的选择中），最终决定用<code>S</code>填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;Embarked&quot;</span>] = all_data[<span class="string">&quot;Embarked&quot;</span>].fillna(<span class="string">&quot;S&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于存在唯一缺失值的<code>Fare</code>，我先找了找存不存在与其<code>Ticket</code>一样的样本，没有找到。于是就找同为三等舱、S港口登船的样本的中位数来填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fare_med = all_data[<span class="string">&quot;Fare&quot;</span>][(all_data[<span class="string">&quot;Embarked&quot;</span>]==<span class="string">&#x27;S&#x27;</span>) &amp; (all_data[<span class="string">&quot;Pclass&quot;</span>]==<span class="number">3</span>)].median()</span><br><span class="line">all_data[<span class="string">&quot;Fare&quot;</span>] = all_data[<span class="string">&quot;Fare&quot;</span>].fillna(fare_med)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认所有缺失值处理完毕</span></span><br><span class="line">all_data.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="处理’Name’"><a href="#处理’Name’" class="headerlink" title="处理’Name’"></a>处理’Name’</h3><p>毫不奇怪地，大多数高分kernel都提取了姓名中的称谓，比如<code>Mr</code>、<code>Miss</code>等，其他一些稀少的称谓归为<code>Rare</code>一类，将称谓作为一个新的变量使用，并抛弃原“姓名”这个没有用的变量。这里需要使用到正则表达式，详细用法参见<a href="https://docs.python.org/3/library/re.html">python re的官方文档</a>。</p><p>数据的<code>Name</code>形如<code>Braund, Mr. Owen Harris</code>，我们要提取的<code>Mr.</code>这些称谓冠词的共同点是末尾有一个缩写点，所以用<code>re.search()</code>查找点号前的子串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span>(<span class="params">name</span>):</span></span><br><span class="line">    title_search = re.search(<span class="string">&#x27;([A-Za-z]+)\.&#x27;</span>, name)</span><br><span class="line">    <span class="keyword">if</span> title_search:</span><br><span class="line">        <span class="keyword">return</span> title_search.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">all_data[<span class="string">&quot;Title&quot;</span>] = all_data[<span class="string">&quot;Name&quot;</span>].apply(getTitle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看各种称谓出现的次数</span></span><br><span class="line">all_data[<span class="string">&quot;Title&quot;</span>].value_counts()</span><br></pre></td></tr></table></figure><p>我打算只保留”Mr”、”Miss”（同义词”Mlle”、”Ms” ）、”Mrs”（同义词”Mme”）、”Master”这四个比较常见的称谓，其他归入”Rare”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rare_title = [<span class="string">&quot;Dr&quot;</span>,<span class="string">&quot;Rev&quot;</span>,<span class="string">&quot;Col&quot;</span>,<span class="string">&quot;Major&quot;</span>,<span class="string">&quot;Don&quot;</span>,<span class="string">&quot;Jonkheer&quot;</span>,<span class="string">&quot;Sir&quot;</span>,<span class="string">&quot;Lady&quot;</span>,<span class="string">&quot;Countess&quot;</span>,<span class="string">&quot;Capt&quot;</span>,<span class="string">&quot;Dona&quot;</span>]</span><br><span class="line"></span><br><span class="line">all_data[<span class="string">&quot;Title&quot;</span>].replace(rare_title, <span class="string">&quot;Rare&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">all_data[<span class="string">&quot;Title&quot;</span>].replace([<span class="string">&quot;Mlle&quot;</span>,<span class="string">&quot;Ms&quot;</span>], <span class="string">&quot;Miss&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">all_data[<span class="string">&quot;Title&quot;</span>].replace([<span class="string">&quot;Mme&quot;</span>], <span class="string">&quot;Mrs&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否完成合并</span></span><br><span class="line">all_data[<span class="string">&quot;Title&quot;</span>].value_counts()</span><br></pre></td></tr></table></figure><p>对于<code>Name</code>变量的操作就到此为止。</p><h3 id="处理’SibSp’和’Parch’"><a href="#处理’SibSp’和’Parch’" class="headerlink" title="处理’SibSp’和’Parch’"></a>处理’SibSp’和’Parch’</h3><p>我所阅读的3篇kernel都是把这两项相加（还要把自己算进去），得到<code>familySize</code>（家庭人数）这一新特征，其中如果该新特征等于1，就表示是他是孤身一人登船，他遇难的概率会大大增加。这就是一个对预测生还率有用的变量。</p><p>参考Anisotropic和Manav Sehgal的解答，我会创建一个名为“孤身一人”的二值变量，其它变量均舍去。Yassine Ghouzam还考虑了人数大于4的大家庭，以后也可以考虑一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;FamilySize&quot;</span>] = all_data[<span class="string">&quot;SibSp&quot;</span>] + all_data[<span class="string">&quot;Parch&quot;</span>] + <span class="number">1</span></span><br><span class="line">all_data[<span class="string">&quot;IsAlone&quot;</span>] = <span class="number">0</span></span><br><span class="line">all_data.loc[all_data[<span class="string">&quot;FamilySize&quot;</span>] == <span class="number">1</span>, <span class="string">&quot;IsAlone&quot;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否为一人的人数</span></span><br><span class="line">all_data[<span class="string">&quot;IsAlone&quot;</span>].value_counts()</span><br></pre></td></tr></table></figure><h3 id="数据转化"><a href="#数据转化" class="headerlink" title="数据转化"></a>数据转化</h3><p>通过阅读了这几篇kernel，我发现部分解答对数据的处理存在如下共同点：</p><ul><li><code>Age</code>、<code>Fare</code>分段：这两项是连续的数值型数据，由于我们采用的集成模型大多数是基于决策树的，决策树模型本质上是将它当离散值处理的，因此手动将其分为我们想要的几段，可能会获得更好的性能。</li><li>将字符型变量标签编码，以及虚拟变量，由于模型在处理字符型变量时会自动转换为哑变量，这一步似乎不做也无妨？</li><li>由于最后选择的变量全是代表类别的离散型，无需做特征缩放。</li></ul><p>对连续值分段，pandas有<code>cut</code>和<code>qcut</code>两种方式可用，前者依据值本身的大小来确定切割点，后者依据出现的频率来确定切割点。参考Anisotropic和Manav Sehgal的解答，对<code>Age</code>采用<code>cut</code>划分为5个分段，对<code>Fare</code>采用<code>qcut</code>划分为4个分段。这一步帮助我们确定分割点，下一步是手动创建分割后的标签变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;AgeCut&quot;</span>] = pd.cut(all_data[<span class="string">&quot;Age&quot;</span>], <span class="number">5</span>)</span><br><span class="line">all_data[<span class="string">&quot;AgeCut&quot;</span>].value_counts()</span><br><span class="line"></span><br><span class="line">all_data[<span class="string">&quot;FareCut&quot;</span>] = pd.qcut(all_data[<span class="string">&quot;Fare&quot;</span>], <span class="number">4</span>)</span><br><span class="line">all_data[<span class="string">&quot;FareCut&quot;</span>].value_counts()</span><br></pre></td></tr></table></figure><p>年龄以16岁为一个阶梯，票价的分割点则是[7.896, 14.454, 31.275]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 年龄分段</span></span><br><span class="line">all_data.loc[all_data[<span class="string">&quot;Age&quot;</span>]&lt;<span class="number">16</span>, <span class="string">&quot;AgeGroup&quot;</span>] = <span class="number">0</span></span><br><span class="line">all_data.loc[(all_data[<span class="string">&quot;Age&quot;</span>]&gt;=<span class="number">16</span>) &amp; (all_data[<span class="string">&quot;Age&quot;</span>]&lt;<span class="number">32</span>), <span class="string">&quot;AgeGroup&quot;</span>] = <span class="number">1</span></span><br><span class="line">all_data.loc[(all_data[<span class="string">&quot;Age&quot;</span>]&gt;=<span class="number">32</span>) &amp; (all_data[<span class="string">&quot;Age&quot;</span>]&lt;<span class="number">48</span>), <span class="string">&quot;AgeGroup&quot;</span>] = <span class="number">2</span></span><br><span class="line">all_data.loc[(all_data[<span class="string">&quot;Age&quot;</span>]&gt;=<span class="number">48</span>) &amp; (all_data[<span class="string">&quot;Age&quot;</span>]&lt;<span class="number">64</span>), <span class="string">&quot;AgeGroup&quot;</span>] = <span class="number">3</span></span><br><span class="line">all_data.loc[all_data[<span class="string">&quot;Age&quot;</span>]&gt;=<span class="number">64</span>, <span class="string">&quot;AgeGroup&quot;</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 票价分段</span></span><br><span class="line">all_data.loc[all_data[<span class="string">&quot;Fare&quot;</span>]&lt;<span class="number">7.896</span>, <span class="string">&quot;FareGroup&quot;</span>] = <span class="number">0</span></span><br><span class="line">all_data.loc[(all_data[<span class="string">&quot;Fare&quot;</span>]&gt;=<span class="number">7.896</span>) &amp; (all_data[<span class="string">&quot;Fare&quot;</span>]&lt;<span class="number">14.454</span>), <span class="string">&quot;FareGroup&quot;</span>] = <span class="number">1</span></span><br><span class="line">all_data.loc[(all_data[<span class="string">&quot;Fare&quot;</span>]&gt;=<span class="number">14.454</span>) &amp; (all_data[<span class="string">&quot;Fare&quot;</span>]&lt;<span class="number">31.275</span>), <span class="string">&quot;FareGroup&quot;</span>] = <span class="number">2</span></span><br><span class="line">all_data.loc[all_data[<span class="string">&quot;Fare&quot;</span>]&gt;=<span class="number">31.275</span>, <span class="string">&quot;FareGroup&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取整</span></span><br><span class="line">all_data[<span class="string">&quot;AgeGroup&quot;</span>] = all_data[<span class="string">&quot;AgeGroup&quot;</span>].astype(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;FareGroup&quot;</span>] = all_data[<span class="string">&quot;FareGroup&quot;</span>].astype(<span class="string">&quot;int&quot;</span>)</span><br></pre></td></tr></table></figure><p>接着进行特征选择，把没有用的特征抛弃掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drop_features = [<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;Age&quot;</span>,<span class="string">&quot;SibSp&quot;</span>,<span class="string">&quot;Parch&quot;</span>,<span class="string">&quot;Ticket&quot;</span>,<span class="string">&quot;Fare&quot;</span>,<span class="string">&quot;FamilySize&quot;</span>,<span class="string">&quot;AgeCut&quot;</span>,<span class="string">&quot;FareCut&quot;</span>]</span><br><span class="line">all_data.drop(drop_features, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">all_data.head()</span><br></pre></td></tr></table></figure><p>剩下来的变量均为类别型变量，且不存在明确的顺序关系，因此将其虚拟化。由于<code>get_dummies()</code>仅将字符型变量虚拟化，因此一些变量需要手动转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 性别转换为二值变量</span></span><br><span class="line">all_data[<span class="string">&quot;Sex&quot;</span>] = all_data[<span class="string">&quot;Sex&quot;</span>].<span class="built_in">map</span>(&#123;<span class="string">&quot;female&quot;</span>: <span class="number">0</span>, <span class="string">&quot;male&quot;</span>: <span class="number">1</span>&#125;).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整型转换为字符型</span></span><br><span class="line">all_data[<span class="string">&quot;Pclass&quot;</span>] = all_data[<span class="string">&quot;Pclass&quot;</span>].astype(<span class="string">&quot;str&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;AgeGroup&quot;</span>] = all_data[<span class="string">&quot;AgeGroup&quot;</span>].astype(<span class="string">&quot;str&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;FareGroup&quot;</span>] = all_data[<span class="string">&quot;FareGroup&quot;</span>].astype(<span class="string">&quot;str&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟变量</span></span><br><span class="line">all_data = pd.get_dummies(all_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看虚拟化后的变量名</span></span><br><span class="line">all_data.columns</span><br></pre></td></tr></table></figure><p>至此我们已经完成了特征工程，我们把训练集和测试集分开，准备进行下一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分离训练集和测试集</span></span><br><span class="line">X_train = all_data[:y.shape[<span class="number">0</span>]]</span><br><span class="line">X_test = all_data[y.shape[<span class="number">0</span>]:]</span><br></pre></td></tr></table></figure><h2 id="运用单个模型"><a href="#运用单个模型" class="headerlink" title="运用单个模型"></a>运用单个模型</h2><p>作为一次机器学习训练，自然是把所有能用的分类模型都拿过来试一试。除了scikit-learn自带的几个模型之外，还使用了XGBoost和LightGBM这两个比赛中常用的集成模型。把每个模型都调用来比较一下，找到最优的分类器，看看其精度如何，最后和Stacking模型的精度比一比。</p><p>尝试使用的模型：</p><ul><li>逻辑回归</li><li>神经网络</li><li>CART</li><li>SVM</li><li>KNN</li><li>朴素贝叶斯</li><li>随机森林</li><li>极端随机树</li><li>AdaBoost</li><li>GBDT</li><li>XGBoost</li><li>LightGBM</li></ul><p>先使用默认参数都跑一遍，用交叉验证查看准确率的均值和标准差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">models = &#123;&#125;</span><br><span class="line">models[<span class="string">&#x27;LogisticRegression&#x27;</span>] = LogisticRegressionCV()</span><br><span class="line">models[<span class="string">&#x27;NeuralNetwork&#x27;</span>] = MLPClassifier()</span><br><span class="line">models[<span class="string">&#x27;CART&#x27;</span>] = DecisionTreeClassifier()</span><br><span class="line">models[<span class="string">&#x27;SVM&#x27;</span>] = SVC()</span><br><span class="line">models[<span class="string">&#x27;KNN&#x27;</span>] = KNeighborsClassifier()</span><br><span class="line">models[<span class="string">&#x27;NaiveBayes&#x27;</span>] = BernoulliNB()</span><br><span class="line">models[<span class="string">&#x27;RandomForest&#x27;</span>] = RandomForestClassifier()</span><br><span class="line">models[<span class="string">&#x27;ExtraTree&#x27;</span>] = ExtraTreesClassifier()</span><br><span class="line">models[<span class="string">&#x27;AdaBoost&#x27;</span>] = AdaBoostClassifier()</span><br><span class="line">models[<span class="string">&#x27;GBDT&#x27;</span>] = GradientBoostingClassifier()</span><br><span class="line">models[<span class="string">&#x27;XGBoost&#x27;</span>] = XGBClassifier()</span><br><span class="line">models[<span class="string">&#x27;LightGBM&#x27;</span>] = LGBMClassifier()</span><br><span class="line"></span><br><span class="line">kf = KFold(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    cv_result = cross_val_score(models[model], X_train, y, cv=kf, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s模型的交叉验证得分平均值%.2f%%，标准差%.2f%%。&#x27;</span> % (model, cv_result.mean()*<span class="number">100</span>, cv_result.std()*<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>这里没有设置随机数种子，因此每次跑模型，结果都是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LogisticRegression模型的交叉验证得分平均值80.47%，标准差3.86%。</span><br><span class="line">NeuralNetwork模型的交叉验证得分平均值80.81%，标准差4.46%。</span><br><span class="line">CART模型的交叉验证得分平均值80.36%，标准差3.30%。</span><br><span class="line">SVM模型的交叉验证得分平均值79.58%，标准差4.06%。</span><br><span class="line">KNN模型的交叉验证得分平均值79.13%，标准差4.39%。</span><br><span class="line">NaiveBayes模型的交叉验证得分平均值74.98%，标准差5.07%。</span><br><span class="line">RandomForest模型的交叉验证得分平均值80.93%，标准差3.55%。</span><br><span class="line">ExtraTree模型的交叉验证得分平均值80.59%，标准差3.24%。</span><br><span class="line">AdaBoost模型的交叉验证得分平均值79.01%，标准差4.40%。</span><br><span class="line">GBDT模型的交叉验证得分平均值81.71%，标准差3.35%。</span><br><span class="line">XGBoost模型的交叉验证得分平均值82.27%，标准差3.63%。</span><br><span class="line">LightGBM模型的交叉验证得分平均值81.15%，标准差3.81%。</span><br></pre></td></tr></table></figure><p>可以看出大多数模型的准确率在80%附近，XGBoost效果最好，可以进一步调参优化；朴素贝叶斯较差，可以放弃。</p><p>下面使用网格搜索法对随机森林、极端随机树、AdaBoost、GBDT、XGBoost、LightGBM进行调参。主要调试<code>n_estimators</code>，对于Boosting类的模型，还会调试<code>learnig_rate</code>这个参数，其余保持默认设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bagging_models = &#123;<span class="string">&#x27;RandomForest&#x27;</span>: RandomForestClassifier(), <span class="string">&#x27;ExtraTree&#x27;</span>: ExtraTreesClassifier()&#125;</span><br><span class="line">boosting_models = &#123;<span class="string">&#x27;AdaBoost&#x27;</span>: AdaBoostClassifier(), <span class="string">&#x27;GBDT&#x27;</span>: GradientBoostingClassifier(), <span class="string">&#x27;XGBoost&#x27;</span>: XGBClassifier(), <span class="string">&#x27;LightGBM&#x27;</span>: LGBMClassifier()&#125;</span><br><span class="line"></span><br><span class="line">bagging_params = &#123;<span class="string">&#x27;n_estimators&#x27;</span>: [<span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">800</span>]&#125;</span><br><span class="line">boosting_params = &#123;<span class="string">&#x27;n_estimators&#x27;</span>: [<span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">800</span>], <span class="string">&#x27;learning_rate&#x27;</span>:[<span class="number">0.005</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>]&#125;</span><br><span class="line"></span><br><span class="line">kf = KFold(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> bagging_models:</span><br><span class="line">    grid = GridSearchCV(estimator=bagging_models[model], param_grid=bagging_params, cv=kf, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    grid_result = grid.fit(X_train, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s模型的最优参数是%s，得分%.2f%%。&#x27;</span> % (model, grid_result.best_params_, grid_result.best_score_*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> boosting_models:</span><br><span class="line">    grid = GridSearchCV(estimator=boosting_models[model], param_grid=boosting_params, cv=kf, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    grid_result = grid.fit(X_train, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s模型的最优参数是%s，得分%.2f%%。&#x27;</span> % (model, grid_result.best_params_, grid_result.best_score_*<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>一次跑下来的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RandomForest模型的最优参数是&#123;&#x27;n_estimators&#x27;: 50&#125;，得分81.37%。</span><br><span class="line">ExtraTree模型的最优参数是&#123;&#x27;n_estimators&#x27;: 200&#125;，得分80.81%。</span><br><span class="line">AdaBoost模型的最优参数是&#123;&#x27;learning_rate&#x27;: 0.01, &#x27;n_estimators&#x27;: 800&#125;，得分80.25%。</span><br><span class="line">GBDT模型的最优参数是&#123;&#x27;learning_rate&#x27;: 0.1, &#x27;n_estimators&#x27;: 50&#125;，得分82.15%。</span><br><span class="line">XGBoost模型的最优参数是&#123;&#x27;learning_rate&#x27;: 0.005, &#x27;n_estimators&#x27;: 800&#125;，得分82.49%。</span><br><span class="line">LightGBM模型的最优参数是&#123;&#x27;learning_rate&#x27;: 0.01, &#x27;n_estimators&#x27;: 500&#125;，得分81.82%。</span><br></pre></td></tr></table></figure><p>如果使用单一模型，则XGBoost效果最好。接下来，尝试使用Stacking模型。</p><h2 id="运用Stacking模型"><a href="#运用Stacking模型" class="headerlink" title="运用Stacking模型"></a>运用Stacking模型</h2><p>之前在<a href="http://ster.im/kaggle_03/#%E8%BF%9B%E9%98%B6%EF%BC%9AStacking%E9%9B%86%E6%88%90%E6%A8%A1%E5%9E%8B">房价预测</a>中，接触到了Stacking这一kaggle神器，这次来亲手尝试一下，构造一个Stacking类，虽然代码是直接抄过来的。</p><p>原作者kernel地址：<a href="https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard">《Stacked Regressions : Top 4% on LeaderBoard》</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin, ClassifierMixin, clone</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackingAveragedModels</span>(<span class="params">BaseEstimator, ClassifierMixin, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, base_models, meta_model, n_folds=<span class="number">5</span></span>):</span></span><br><span class="line">        self.base_models = base_models</span><br><span class="line">        self.meta_model = meta_model</span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义fit方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">        self.base_models_ = [<span class="built_in">list</span>() <span class="keyword">for</span> x <span class="keyword">in</span> self.base_models]</span><br><span class="line">        self.meta_model_ = clone(self.meta_model)</span><br><span class="line">        kfold = KFold(n_splits=self.n_folds, shuffle=<span class="literal">True</span>, random_state=<span class="number">1</span>)</span><br><span class="line">        out_of_fold_predictions = np.zeros((X.shape[<span class="number">0</span>], <span class="built_in">len</span>(self.base_models)))</span><br><span class="line">        <span class="comment"># 用K折后的数据训练每一个初级分类器</span></span><br><span class="line">        <span class="keyword">for</span> i, model <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.base_models):</span><br><span class="line">            <span class="keyword">for</span> train_index, holdout_index <span class="keyword">in</span> kfold.split(X, y):</span><br><span class="line">                instance = clone(model)</span><br><span class="line">                self.base_models_[i].append(instance)</span><br><span class="line">                instance.fit(X.iloc[train_index], y.iloc[train_index])</span><br><span class="line">                y_pred = instance.predict(X.iloc[holdout_index])</span><br><span class="line">                out_of_fold_predictions[holdout_index, i] = y_pred</span><br><span class="line">        <span class="comment"># 使用次级分类器拟合初级分类器预测的结果</span></span><br><span class="line">        self.meta_model_.fit(out_of_fold_predictions, y)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义predict方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        meta_features = np.column_stack([np.column_stack([model.predict(X) <span class="keyword">for</span> model <span class="keyword">in</span> base_models]).mean(axis=<span class="number">1</span>) <span class="keyword">for</span> base_models <span class="keyword">in</span> self.base_models_])</span><br><span class="line">        <span class="keyword">return</span> self.meta_model_.predict(meta_features)</span><br></pre></td></tr></table></figure><p>Anisotropic使用的Stacking是以随机森林、极端随机树、AdaBoost、GBDT、SVM作为元分类器，XGBoost作为次级分类器。于是我这样做：随机森林、极端随机树、AdaBoost、GBDT、LightGBM作为元分类器，XGBoost作为次级分类器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rf = RandomForestClassifier(n_estimators=<span class="number">50</span>)</span><br><span class="line">et = ExtraTreesClassifier(n_estimators=<span class="number">200</span>)</span><br><span class="line">ab = AdaBoostClassifier(n_estimators=<span class="number">800</span>, learning_rate=<span class="number">0.01</span>)</span><br><span class="line">gb = GradientBoostingClassifier(n_estimators=<span class="number">50</span>, learning_rate=<span class="number">0.1</span>)</span><br><span class="line">xg = XGBClassifier(n_estimators=<span class="number">800</span>, learning_rate=<span class="number">0.005</span>)</span><br><span class="line">lg = LGBMClassifier(n_estimators=<span class="number">500</span>, learning_rate=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">stacked_averaged_models = StackingAveragedModels(base_models=(rf, et, ab, gb, lg), meta_model=xg)</span><br><span class="line">score = cross_val_score(stacked_averaged_models, X_train, y, cv=kf, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Stacking模型的交叉验证得分平均值%.2f%%，标准差%.2f%%。&#x27;</span> % (score.mean()*<span class="number">100</span>, score.std()*<span class="number">100</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stacking模型的交叉验证得分平均值81.37%，标准差3.92%。</span><br></pre></td></tr></table></figure><p>结果令人失望：验证集精度不如单一模型。无论如何，分别提交XGBoost和Stacking的结果看看测试集精度如何。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XGBoost</span></span><br><span class="line">xg = XGBClassifier(n_estimators=<span class="number">800</span>, learning_rate=<span class="number">0.005</span>)</span><br><span class="line">xg.fit(X_train, y)</span><br><span class="line">xg_pred = xg.predict(X_test)</span><br><span class="line">XGBoostSubmission = pd.DataFrame(&#123;<span class="string">&#x27;PassengerId&#x27;</span>: PassengerId, <span class="string">&#x27;Survived&#x27;</span>: xg_pred&#125;)</span><br><span class="line">XGBoostSubmission.to_csv(<span class="string">&quot;XGBoostSubmission.csv&quot;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stacking</span></span><br><span class="line">stacked_averaged_models.fit(X_train, y)</span><br><span class="line">stacking_pred = stacked_averaged_models.predict(X_test)</span><br><span class="line">StackingSubmission = pd.DataFrame(&#123;<span class="string">&#x27;PassengerId&#x27;</span>: PassengerId, <span class="string">&#x27;Survived&#x27;</span>: stacking_pred&#125;)</span><br><span class="line">StackingSubmission.to_csv(<span class="string">&quot;StackingSubmission.csv&quot;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>Stacking模型在测试集上的得分为0.77990；XGBoost模型在测试集上的得分为0.79904，位列前14.9%。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>泰坦尼克号生还预测是一个非常适合入门的机器学习项目。通过这一次实战训练，有以下收获：</p><ul><li>掌握pandas的数据清洗和特征工程方法。</li><li>熟悉sklearn的各种分类模型及其调参。</li><li>了解Stacking，虽然这个任务中性能似乎不如XGBoost，但可能适合别的任务。</li><li>在Kaggle阅读了越来越多的kernel，了解机器学习的前沿方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（8）——scikit-learn：模型评估与优化</title>
      <link href="/py_sklearn_4/"/>
      <url>/py_sklearn_4/</url>
      
        <content type="html"><![CDATA[<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="cross-val-score交叉验证"><a href="#cross-val-score交叉验证" class="headerlink" title="cross_val_score交叉验证"></a>cross_val_score交叉验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.model_selection.cross_val_score(estimator, X, y=<span class="literal">None</span>, groups=<span class="literal">None</span>, scoring=<span class="literal">None</span>, cv=<span class="string">&quot;warn&quot;</span>, n_jobs=<span class="literal">None</span>, verbose=<span class="number">0</span>, fit_params=<span class="literal">None</span>, pre_dispatch=<span class="string">&quot;2*n_jobs&quot;</span>, error_score=<span class="string">&quot;raise-deprecating&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>cross_val_score</code>将数据集分为<code>cv</code>折，每次取1折作为验证集，其他作为训练集进行预测，总共运行<code>cv</code>次，最后得到K次结果取其均值作为模型得分。由于该方法在分割数据集前不会对数据洗牌，常搭配<code>sklearn.model_selection.KFold</code>使用。关于<code>scoring</code>参数可选项，参见<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#model-evaluation">官方文档</a>。返回值是每次验证得分的数组，通常取其均值和标准差。</p><h3 id="GridSearchCV超参数调试"><a href="#GridSearchCV超参数调试" class="headerlink" title="GridSearchCV超参数调试"></a>GridSearchCV超参数调试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.model_selection.GridSearchCV(estimator, param_grid, scoring=<span class="literal">None</span>, fit_params=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>, iid=<span class="string">&quot;warn&quot;</span>, refit=<span class="literal">True</span>, cv=<span class="string">&quot;warn&quot;</span>, verbose=<span class="number">0</span>, pre_dispatch=<span class="string">&quot;2*n_jobs&quot;</span>, error_score=<span class="string">&quot;raise-deprecating&quot;</span>, return_train_score=<span class="string">&quot;warn&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>GridSearchCV</code>网格搜索法会根据输入的参数搜寻最优值，能大大便利模型调参。我们主要关心如下参数：</p><ul><li><code>estimator</code>：需要调参的estimator。</li><li><code>param_grid</code>：通常接收一个字典，键是参数名，值是对应参数名的待选参数值的列表。</li><li><code>scoring</code>：评分函数，和<code>cross_val_score</code>类似。</li></ul><p>定义好对象后，使用<code>fit()</code>方法进行网格搜索，通过如下属性查看最优参数：</p><ul><li><code>cv_results_</code>：字典类型，包含使用所给参数的不同组合得到的各项得分。</li><li><code>best_score_</code>：所给参数中的最高得分。</li><li><code>best_params_</code>：所给参数中的最高得分对应的键值对。</li></ul><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.pipeline.Pipeline(steps, memory=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>一般的机器学习项目里，通常要将数据先标准化，再拟合，有时还要在中间插上降维的过程。同样的步骤可能会在不同的数据集上重复使用。而使用<code>Pipeline</code>就可以将以上步骤像流水线一样完成，避免重复代码。</p><p><code>Pipeline</code>一般只接收一个列表参数，每个元素是一个类似于键值对的元祖，键为步骤名称，值为实例化的对象，例如<code>Pipeline([(&#39;norm&#39;, norm),(&#39;pca&#39;,pca),(&#39;svm&#39;, svm)])</code>。</p><h2 id="sklearn-metrics"><a href="#sklearn-metrics" class="headerlink" title="sklearn.metrics"></a>sklearn.metrics</h2><p>在scikit-learn中，要对一个拟合好的模型进行评估，有三种方法：</p><ul><li>使用各种estimator自带的<code>score</code>方法。一般来说，分类器的默认评估指标是正确率（accuracy），回归器的是拟合优度（R方）。</li><li>使用模型评估工具（例如<code>sklearn.model_selection.cross_val_score</code>）的<code>scoring</code>参数设置各种评估指标来交叉验证。</li><li>使用<code>sklearn.metrics</code>中的各种函数进行验证。</li></ul><p><code>sklearn.metrics</code>模块提供了非常多的评估函数，这些函数可以接收真实结果和预测结果并直接输出得分，另一种方法是使用<code>sklearn.metrics.make_scorer</code>打包供<code>scoring</code>参数调用。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="正确率（accuracy）"><a href="#正确率（accuracy）" class="headerlink" title="正确率（accuracy）"></a>正确率（accuracy）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.accuracy_score(y_true, y_pred, normalize=<span class="literal">True</span>, sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>分类模型默认的评价指标，该值为预测正确的样本数与总样本数的比值，适用于二分类和多分类，但缺点在于不适合样本类别分布不均的情况，并且在有些问题中无法满足特定需求（例如，检查癌症，宁可错查不可遗漏，这时适用召回率）。</p><h4 id="混淆矩阵（confusion-matrix）"><a href="#混淆矩阵（confusion-matrix）" class="headerlink" title="混淆矩阵（confusion matrix）"></a>混淆矩阵（confusion matrix）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.confusion_matrix(y_true, y_pred, labels=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>混淆矩阵适合查看各个类别被正确/错误分类的情况。</p><ul><li>True Positive（TP）：分类器正确分类的正例数据。</li><li>True Negative（TN）：分类器正确分类的负例数据。</li><li>False Positive（FP）：分类器错误标记为正例的负例数据。</li><li>False Negative（FN）：分类器错误标记为负例的正例数据。</li></ul><p>以下三种评价函数都是基于混淆矩阵。</p><h4 id="准确率（precision）、召回率（recall）、F1-score"><a href="#准确率（precision）、召回率（recall）、F1-score" class="headerlink" title="准确率（precision）、召回率（recall）、F1 score"></a>准确率（precision）、召回率（recall）、F1 score</h4><p>关于准确率（precision）和召回率（recall），可见<a href="http://ster.im/ng_02/#%E5%8D%95%E5%AE%9E%E6%95%B0%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87">此文章</a>。</p><p>F1-score是这两者的结合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.precision_recall_fscore_support(y_true, y_pred, beta=<span class="number">1.0</span>, labels=<span class="literal">None</span>, pos_label=<span class="number">1</span>, average=<span class="literal">None</span>, warn_for=(<span class="string">&quot;precision&quot;</span>, <span class="string">&quot;recall&quot;</span>, <span class="string">&quot;f-score&quot;</span>), sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>使用<code>classification_report</code>会输出准确率、召回率和F1-score。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.classification_report(y_true, y_pred, labels=<span class="literal">None</span>, target_names=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, digits=<span class="number">2</span>, output_dict=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="AUC值"><a href="#AUC值" class="headerlink" title="AUC值"></a>AUC值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.roc_auc_score(y_true, y_score, average=<span class="string">&quot;macro&quot;</span>, sample_weight=<span class="literal">None</span>, max_fpr=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>ROC曲线是以FPR（False Positive Rate）为横轴，TPR（True Positive Rate）为纵轴绘制的坐标图。AUC值为ROC曲线下方区域的面积。AUC值越大，分类器效果越好。</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><h4 id="平均绝对误差（mean-absolute-error）"><a href="#平均绝对误差（mean-absolute-error）" class="headerlink" title="平均绝对误差（mean absolute error）"></a>平均绝对误差（mean absolute error）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.mean_absolute_error(y_true, y_pred, sample_weight=<span class="literal">None</span>, multioutput=<span class="string">&quot;uniform_average&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="均方误差（mean-squared-error）"><a href="#均方误差（mean-squared-error）" class="headerlink" title="均方误差（mean squared error）"></a>均方误差（mean squared error）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.mean_squared_error(y_true, y_pred, sample_weight=<span class="literal">None</span>, multioutput=<span class="string">&quot;uniform_average&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="拟合优度（R方）"><a href="#拟合优度（R方）" class="headerlink" title="拟合优度（R方）"></a>拟合优度（R方）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.r2_score(y_true, y_pred, sample_weight=<span class="literal">None</span>, multioutput=<span class="string">&quot;uniform_average&quot;</span>)</span><br></pre></td></tr></table></figure><p>R方可以是负值，说明拟合效果很差。如果一个模型的预测结果恒为y的期望，则该模型的R方为0。</p><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><h4 id="调整兰德系数（Adjusted-Rand-index）"><a href="#调整兰德系数（Adjusted-Rand-index）" class="headerlink" title="调整兰德系数（Adjusted Rand index）"></a>调整兰德系数（Adjusted Rand index）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.adjusted_rand_score(labels_true, labels_pred)</span><br></pre></td></tr></table></figure><p>需要提供真实标签，取值位于-1到1之间，越高聚类效果越好。</p><h4 id="轮廓系数（silhouette-coefficient）"><a href="#轮廓系数（silhouette-coefficient）" class="headerlink" title="轮廓系数（silhouette coefficient）"></a>轮廓系数（silhouette coefficient）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.silhouette_score(X, labels, metric=<span class="string">&quot;euclidean&quot;</span>, sample_size=<span class="literal">None</span>, random_state=<span class="literal">None</span>, **kwds)</span><br></pre></td></tr></table></figure><p>该聚类评估指标无需真实标签，得分最高是1，最差是-1。</p><h4 id="Calinski-Harabaz-Index"><a href="#Calinski-Harabaz-Index" class="headerlink" title="Calinski-Harabaz Index"></a>Calinski-Harabaz Index</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.metrics.calinski_harabaz_score(X, labels)</span><br></pre></td></tr></table></figure><p>同样无需真实标签。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（7）——scikit-learn：聚类&amp;降维</title>
      <link href="/py_sklearn_3/"/>
      <url>/py_sklearn_3/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍以下几种聚类、降维算法在scikit-learn中的使用方法：</p><p>聚类：</p><ul><li>K-Means</li><li>DBSCAN</li></ul><p>降维：</p><ul><li>PCA</li><li>LDA</li></ul><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><h3 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h3><p>参数：</p><ul><li><code>n_clusters</code>：要分成的类别数，默认值为8。</li><li><code>init</code>：初始化聚类中心的方法，默认为<code>&quot;k-means++&quot;</code>，它将智能选择初始聚类中心；<code>&quot;random&quot;</code>将随机选择初始聚类中心；也可传入一组数组指定为初始聚类中心。</li><li><code>n_init</code>：用不同的初始化聚类中心运行算法的次数，默认10。</li><li><code>max_iter</code>：最大迭代次数，默认300。</li><li><code>tol</code>：容差，默认1e-4。</li><li><code>precompute_distances</code>：是否预先计算距离（更快但消耗更多内存）。选<code>&quot;auto&quot;</code>会在<code>n_samples * n_clusters &gt; 12</code>时不预先计算距离。</li><li><code>verbose</code>：是否冗余输出，默认0。</li><li><code>random_state</code>：随机数种子。</li><li><code>copy_x</code>：是否复制训练集，默认为<code>True</code>，如果为<code>False</code>则会直接在原数据上修改。</li><li><code>n_jobs</code>：使用的核心数。默认<code>None</code>为单核。</li><li><code>algorithm</code>：可选<code>&quot;auto&quot;</code>（默认）、<code>&quot;full&quot;</code>或<code>&quot;elkan&quot;</code>，<code>&quot;auto&quot;</code>自动选择<code>&quot;elkan&quot;</code>处理稠密数据，<code>&quot;full&quot;</code>处理稀疏数据。</li></ul><p>属性：</p><ul><li><code>cluster_centers_</code>：返回聚类中心。</li><li><code>labels_</code>：返回聚类后每个点的标签。</li><li><code>inertia_</code>：返回样本到最近聚类中心距离的平方和。</li><li><code>n_iter_</code>：返回迭代次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">KMeans(n_clusters=<span class="number">8</span>, init=<span class="string">&quot;k-means++&quot;</span>, n_init=<span class="number">10</span>, max_iter=<span class="number">300</span>, tol=<span class="number">0.0001</span>, </span><br><span class="line">       precompute_distances=<span class="string">&quot;auto&quot;</span>, verbose=<span class="number">0</span>, random_state=<span class="literal">None</span>, copy_x=<span class="literal">True</span>, </span><br><span class="line">       n_jobs=<span class="literal">None</span>, algorithm=<span class="string">&quot;auto&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h3><p>参数：</p><ul><li><code>eps</code>：两个样本被认为在同一邻域内的最大距离。默认为0.5。</li><li><code>min_samples</code>：如果一个点被视为核心点，它邻域内至少包含的点的数量（包括这个点本身）。默认为5。</li><li><code>metric</code>：距离度量函数，默认为<code>&quot;euclidean&quot;</code>欧式距离。</li><li><code>metric_params</code>：距离度量函数的附加参数。</li><li><code>algorithm</code>：计算近邻距离的算法，可选<code>&quot;auto&quot;</code>（默认）、<code>&quot;ball_tree&quot;</code>、<code>&quot;kd_tree&quot;</code>、<code>&quot;brute&quot;</code>，该参数类似于KNN。</li><li><code>leaf_size</code>：算法选择KD树或者球树时，该参数用于控制叶节点数量，默认值30。</li><li><code>p</code>：闵式距离的度量，p=1时为曼哈顿距离，p=2时为欧式距离。</li></ul><p>属性：</p><ul><li><code>core_sample_indices_</code>：返回核心点的index列表。</li><li><code>components_</code>：返回核心点的副本列表。</li><li><code>labels_</code>：返回聚类后每个点的标签，噪声点用-1表示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">DBSCAN(eps=<span class="number">0.5</span>, min_samples=<span class="number">5</span>, metric=<span class="string">&quot;euclidean&quot;</span>, metric_params=<span class="literal">None</span>, </span><br><span class="line">       algorithm=<span class="string">&quot;auto&quot;</span>, leaf_size=<span class="number">30</span>, p=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><p>参数：</p><ul><li><code>n_components</code>：降维之后保留的维数，如果不指定则该值取样本数和特征数间的较小值。可指定为一个整数，即所需保留的维数。如果设为<code>&quot;mle&quot;</code>且<code>svd_solver == &quot;full&quot;</code>，会采用MLE算法自动选择一个合适的维度。如果是一个浮点数且<code>svd_solver == &quot;full&quot;</code>，它代表降维后的能保留的信息比值。如果<code>svd_solver == &quot;arpack&quot;</code>，该值会被严格限制为小于样本数和特征数。</li><li><code>copy</code>：是否创建数据副本而不覆盖原数据，默认为<code>True</code>。</li><li><code>whiten</code>：是否白化，即去除降维后的特征之间的相关性并且方差相同。默认为<code>False</code>。</li><li><code>svd_solver</code>：SVD采用的算法，默认<code>&quot;auto&quot;</code>会根据输入数据自动挑选最优解，具体方法有<code>&quot;full&quot;</code>、<code>&quot;arpack&quot;</code>、<code>&quot;randomized&quot;</code>。</li><li><code>tol</code>：<code>svd_solver == &quot;arpack&quot;</code>时，奇异值的误差容忍度，默认0.。</li><li><code>iterated_power</code>：<code>svd_solver == &quot;randomized&quot;</code>时的迭代次数，默认<code>&quot;auto&quot;</code>。</li><li><code>random_state</code>：随机数种子。</li></ul><p>属性：</p><ul><li><code>components_</code>：主成分的轴的方向。</li><li><code>explained_variance_</code>：降维后各成分的方差。</li><li><code>explained_variance_ratio_</code>：降维后各成分的方差所占的比值。</li><li><code>singular_values_</code>：降维后主成分的奇异值。</li><li><code>mean_</code>：降维后主成分的经验均值。</li><li><code>n_components_</code>：降维之后保留的维数。</li><li><code>noise_variance_</code>：噪声协方差。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">PCA(n_components=<span class="literal">None</span>, copy=<span class="literal">True</span>, whiten=<span class="literal">False</span>, svd_solver=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">    tol=<span class="number">0.0</span>, iterated_power=<span class="string">&quot;auto&quot;</span>, random_state=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h3><p>参数;</p><ul><li><code>solver</code>：算法，可选<code>&quot;svd&quot;</code>（默认）、<code>&quot;lsqr&quot;</code>、<code>&quot;eigen&quot;</code></li><li><code>shrinkage</code>：正则化参数，默认<code>None</code>，可指定为0到1之间的浮点数，也可选<code>&quot;auto&quot;</code>自动选择。该参数在算法使用<code>&quot;svd&quot;</code>时无效。</li><li><code>priors</code>：类别的先验概率。</li><li><code>n_components</code>：降维之后保留的维数，必须小于<code>n_classes - 1</code>。</li><li><code>store_covariance</code>：是否计算类的协方差矩阵，默认为<code>False</code>。</li><li><code>tol</code>：奇异值的误差容忍度，默认1e-4。</li></ul><p>属性：</p><ul><li><code>coef_</code>：权重系数。</li><li><code>intercept_</code>：截距。</li><li><code>covariance_</code>：协方差矩阵。</li><li><code>explained_variance_ratio_</code>：降维后各成分的方差所占的比值。只有选择<code>&quot;svd&quot;</code>算法时可用。</li><li><code>means_</code>：类的均值。</li><li><code>priors_</code>：类的先验概率。</li><li><code>scalings_</code>：用于降维性能度量。</li><li><code>xbar_</code>：总体均值。</li><li><code>classes_</code>：独特的类别标签。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line">LinearDiscriminantAnalysis(solver=<span class="string">&quot;svd&quot;</span>, shrinkage=<span class="literal">None</span>, priors=<span class="literal">None</span>, </span><br><span class="line">                           n_components=<span class="literal">None</span>, store_covariance=<span class="literal">False</span>, tol=<span class="number">0.0001</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（6）——scikit-learn：分类模型</title>
      <link href="/py_sklearn_2/"/>
      <url>/py_sklearn_2/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍以下几种分类算法在scikit-learn中的使用方法：</p><p>基础模型：</p><ul><li>逻辑回归</li><li>神经网络</li><li>决策树</li><li>支持向量机</li><li>KNN</li><li>朴素贝叶斯</li></ul><p>集成模型：</p><ul><li>Bagging</li><li>随机森林</li><li>极端随机树</li><li>AdaBoost</li><li>GBDT</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试用例：鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入鸢尾花数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">X = StandardScaler().fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割训练集与测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p><code>LogisticRegressionCV</code>比<code>LogisticRegression</code>多出交叉验证求最佳正则项系数的功能，通常使用前者。其主要参数为：</p><ul><li><code>Cs</code>：浮点列表或者整型，如果为整型，则在1e-4和1e4间以对数步进取值。如同SVM中的C值，是正则项系数lambda的倒数，C越小，正则项对系数的惩罚性越强。</li><li><code>fit_intercept</code>：布尔型，是否考虑截距项。默认为<code>True</code>。</li><li><code>cv</code>：交叉验证折数，默认<code>None</code>代表3（0.20版本）。</li><li><code>penalty</code>：采用何种正则化，默认<code>&quot;l2&quot;</code>，可选<code>&quot;l1&quot;</code>，但注意使用<code>&quot;newton-cg&quot;</code>、<code>&quot;sag&quot;</code>和<code>&quot;lbfgs&quot;</code>这三种优化算法时仅支持<code>&quot;l2&quot;</code>。</li><li><code>scoring</code>：评分函数，默认使用<code>&quot;accuracy&quot;</code>准确度，详见<a href="">《SKlearn模型评估》</a>。</li><li><code>solver</code>：优化算法，可选<code>&quot;newton-cg&quot;</code>、<code>&quot;lbfgs&quot;</code>（默认）、<code>&quot;liblinear&quot;</code>、<code>&quot;sag&quot;</code>、<code>&quot;saga&quot;</code>。对于小数据集可选<code>&quot;liblinear&quot;</code>，巨型数据集选择随机梯度下降<code>&quot;sag&quot;</code>或<code>&quot;saga&quot;</code>更快；此外，进行多分类任务尽量不选择<code>&quot;liblinear&quot;</code>，因为其只能采用一对多的分类方式。</li><li><code>max_iter</code>：优化算法的最大迭代次数。</li><li><code>class_weight</code>：类别权重，默认视所有类别具有相同的权重，可选<code>&quot;balanced&quot;</code>自动按照类别频率分配权重，也可指定一个字典。</li><li><code>multi_class</code>：多分类时的分类策略，可选<code>&quot;ovr&quot;</code>（默认）、<code>&quot;multinomial&quot;</code>、<code>&quot;auto&quot;</code>。<code>&quot;ovr&quot;</code>即一对多，迭代快、准确性不如多对多；<code>&quot;multinomial&quot;</code>为多对多，迭代慢、准确度高。当优化算法使用<code>&quot;liblinear&quot;</code>时无法使用<code>&quot;multinomial&quot;</code>。</li><li><code>random_state</code>：随机数种子。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegressionCV</span><br><span class="line">clf = LogisticRegressionCV(Cs=<span class="number">10</span>, fit_intercept=<span class="literal">True</span>, cv=<span class="number">5</span>, dual=<span class="literal">False</span>, penalty=<span class="string">&quot;l2&quot;</span>, scoring=<span class="literal">None</span>, </span><br><span class="line">                           solver=<span class="string">&quot;lbfgs&quot;</span>, tol=<span class="number">0.0001</span>, max_iter=<span class="number">200</span>, class_weight=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>, </span><br><span class="line">                           verbose=<span class="number">0</span>, refit=<span class="literal">True</span>, multi_class=<span class="string">&quot;multinomial&quot;</span>, random_state=<span class="literal">None</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>scikit-learn中的多层感知机，即全连接神经网络。其具有如下参数：</p><ul><li><code>hidden_layer_sizes</code>：一个元组，代表每个隐藏层的神经元数，默认为(100,)。</li><li><code>activation</code>：激活函数，可选<code>&quot;identity&quot;</code>、<code>&quot;logistic&quot;</code>、<code>&quot;tanh&quot;</code>、<code>&quot;relu&quot;</code>（默认）。</li><li><code>solver</code>：优化算法，可选<code>&quot;lbfgs&quot;</code>、<code>&quot;sgd&quot;</code>、<code>&quot;adam&quot;</code>（默认）。默认的<code>&quot;adam&quot;</code>算法适合处理大数据集，而对于小数据集采用<code>&quot;lbfgs&quot;</code>可以更快收敛。</li><li><code>alpha</code>：L2正则项系数，默认为0.0001。</li><li><code>batch_size</code>：每个batch的大小，如果优化算法选择<code>&quot;lbfgs&quot;</code>将不使用batch。默认<code>&quot;auto&quot;</code>取200和样本总量间的最小值。</li><li><code>learning_rate</code>：优化算法选择<code>&quot;sgd&quot;</code>时有效，该参数用于控制学习率的衰减，默认<code>&quot;constant&quot;</code>采用恒定学习率，<code>&quot;invscaling&quot;</code>使用指数衰减，<code>&quot;adaptive&quot;</code>使用自适应学习率衰减。</li><li><code>learning_rate_init</code>：优化算法选择<code>&quot;sgd&quot;</code>或<code>&quot;adam&quot;</code>时的初始学习率。默认为0.001。</li><li><code>power_t</code>：优化算法选择<code>&quot;sgd&quot;</code>、学习率使用<code>&quot;invscaling&quot;</code>衰减时有效，用于设定迭代次数的指数。默认为0.5。</li><li><code>max_iter</code>：最大迭代次数，默认为200，当损失函数低于<code>tol</code>或者迭代次数到达这个值时模型停止迭代。对于<code>&quot;sgd&quot;</code>和<code>&quot;adam&quot;</code>算法，该迭代次数是指整个数据集的迭代次数（epoch），而不是batch的迭代次数。</li><li><code>shuffle</code>：仅在选择<code>&quot;sgd&quot;</code>和<code>&quot;adam&quot;</code>算法时有效，是否在每次迭代前对数据洗牌。默认为<code>True</code>。</li><li><code>random_state</code>：随机数种子。</li><li><code>tol</code>：容差，默认为1e-4，当学习率衰减不设为<code>&quot;adaptive&quot;</code>时，若连续<code>n_iter_no_change</code>次迭代造成的损失函数或验证得分提高低于这个值，则停止迭代。</li><li><code>verbose</code>：是否在标准输出中显示进度，默认为<code>False</code>。</li><li><code>warm_start</code>：是否热启动，默认为<code>False</code>，当选择<code>True</code>时会使用上一次拟合的参数作为初始参数。</li><li><code>momentum</code>：仅在选择<code>&quot;sgd&quot;</code>算法时有效。Momentum梯度下降的动量参数，在0.和1.之间，默认0.9。</li><li><code>nesterovs_momentum</code>：仅在选择<code>&quot;sgd&quot;</code>算法、<code>momentum</code>大于0时有效。是否使用Nesterov Momentum，默认为<code>True</code>。</li><li><code>early_stopping</code>：仅在选择<code>&quot;sgd&quot;</code>和<code>&quot;adam&quot;</code>算法时有效，当验证分数没有提高时是否提前终止训练。若选择<code>True</code>，它将自动留出10%的训练数据作为验证，并在连续<code>n_iter_no_change</code>次的验证分数没有至少提高<code>tol</code>时终止训练。默认为<code>False</code>。</li><li><code>validation_fraction</code>：<code>early_stopping</code>为<code>True</code>时有效，预留用于验证的训练数据的比例，默认0.1。</li><li><code>beta_1</code>：仅在选择<code>&quot;adam&quot;</code>算法时有效，adam算法中的一阶矩估计的指数衰减率beta1，默认值0.9。</li><li><code>beta_2</code>：仅在选择<code>&quot;adam&quot;</code>算法时有效，adam算法中的二阶矩估计的指数衰减率beta2，默认值0.999。</li><li><code>epsilon</code>：仅在选择<code>&quot;adam&quot;</code>算法时有效，adam算法中的epsilon，默认值1e-8。</li><li><code>n_iter_no_change</code>：仅在选择<code>&quot;sgd&quot;</code>和<code>&quot;adam&quot;</code>算法时有效，连续<code>n_iter_no_change</code>次迭代造成的损失函数或验证得分提高低于<code>tol</code>，则停止迭代。默认为10。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line">clf = MLPClassifier(hidden_layer_sizes=(<span class="number">100</span>, ), activation=<span class="string">&quot;relu&quot;</span>, solver=<span class="string">&quot;adam&quot;</span>, alpha=<span class="number">0.0001</span>, </span><br><span class="line">                    batch_size=<span class="string">&quot;auto&quot;</span>, learning_rate=<span class="string">&quot;constant&quot;</span>, learning_rate_init=<span class="number">0.001</span>, </span><br><span class="line">                    power_t=<span class="number">0.5</span>, max_iter=<span class="number">1000</span>, shuffle=<span class="literal">True</span>, random_state=<span class="literal">None</span>, tol=<span class="number">0.0001</span>, </span><br><span class="line">                    verbose=<span class="literal">False</span>, warm_start=<span class="literal">False</span>, momentum=<span class="number">0.9</span>, nesterovs_momentum=<span class="literal">True</span>, </span><br><span class="line">                    early_stopping=<span class="literal">False</span>, validation_fraction=<span class="number">0.1</span>, beta_1=<span class="number">0.9</span>, beta_2=<span class="number">0.999</span>, </span><br><span class="line">                    epsilon=<span class="number">1e-08</span>, n_iter_no_change=<span class="number">10</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>CART用于分类，其参数与CART回归类似：</p><ul><li><code>criterion</code>：分枝的标准，默认<code>&quot;gini&quot;</code>为基尼不纯度，可选<code>&quot;entropy&quot;</code>信息增益。</li><li><code>splitter</code>：分枝的策略，默认<code>&quot;best&quot;</code>在所有划分点中找出最优的划分点，适合样本量不大的情况。样本量巨大时建议选择<code>&quot;random&quot;</code>，在部分划分点中找局部最优的划分点。</li><li><code>max_depth</code>：限制树的最大深度，默认值为<code>None</code>，即分割至所有叶节点都是纯的或者少于<code>min_samples_split</code>个样本。如果样本和特征很多时可以适当限制树的最大深度。</li><li><code>min_samples_split</code>：分割一个节点所需的最小样本数，默认为2，当样本量非常大时可以增加这个值。</li><li><code>min_samples_leaf</code>：叶节点上所需的最小样本数，当某个叶节点样本数少于这个值时会被剪枝。默认为1，当样本量非常大时可以增加这个值。</li><li><code>min_weight_fraction_leaf</code>：叶节点样本权重和所需的最小值，默认为0即视样本具有相同的权重。</li><li><code>max_features</code>：分枝时考虑的特征数量最大值，默认<code>None</code>即该值等于特征数量。可以指定整数或者浮点数（表示占特征总数的比例）。也可选<code>&quot;sqrt&quot;</code>（特征数的开根）、<code>&quot;auto&quot;</code>（同前）、<code>&quot;log2&quot;</code>（特征数的以2为底的对数）。如果特征数较多可以考虑限制以加快模型拟合。</li><li><code>random_state</code>：随机数种子。</li><li><code>max_leaf_nodes</code>：叶节点数量最大值，默认<code>None</code>不对叶节点数量做限制，如果特征较多可以加以限制。</li><li><code>min_impurity_decrease</code>：默认为0.，如果分枝导致不纯度的减少大于等于该值，则节点将被分枝。</li><li><code>min_impurity_split</code>：默认为1e-7，如果某节点的不纯度超过这个阈值，则该节会分枝，否则该节点为叶节点。</li><li><code>class_weight</code>：接收字典或字典的列表来指定各类别的的权重，也可指定为<code>&quot;balanced&quot;</code>，使用类别出现频率的倒数作为权重。使用默认的<code>None</code>将视所有类别具有相同的权重。</li><li><code>presort</code>：是否对数据进行预排序，以加快寻找最佳分割点。默认为<code>False</code>。当使用小数据集或对深度作限制时，设置为<code>True</code>可能会加速训练，但对于大型数据集则反而会变慢。</li></ul><p>调参的主要对象为<code>max_depth</code>、<code>min_samples_split</code>、<code>min_samples_leaf</code>、<code>max_features</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">clf = DecisionTreeClassifier(criterion=<span class="string">&quot;gini&quot;</span>, splitter=<span class="string">&quot;best&quot;</span>, max_depth=<span class="literal">None</span>, min_samples_split=<span class="number">2</span>, </span><br><span class="line">                             min_samples_leaf=<span class="number">1</span>, min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="literal">None</span>, </span><br><span class="line">                             random_state=<span class="literal">None</span>, max_leaf_nodes=<span class="literal">None</span>, min_impurity_decrease=<span class="number">0.0</span>, </span><br><span class="line">                             min_impurity_split=<span class="literal">None</span>, class_weight=<span class="literal">None</span>, presort=<span class="literal">False</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><p>部分参数如下：</p><ul><li><code>C</code>：惩罚系数C，默认值为1.0。</li><li><code>kernel</code>：核函数，默认使用<code>&quot;rbf&quot;</code>径向基函数，可选<code>&quot;linear&quot;</code>、<code>&quot;poly&quot;</code>、<code>&quot;sigmoid&quot;</code>、<code>&quot;precomputed&quot;</code>或者一个可调用的函数。</li><li><code>degree</code>：多项式核函数的维度d，仅在核函数选择<code>&quot;poly&quot;</code>时有效。默认值为3。</li><li><code>gamma</code>：<code>&quot;rbf&quot;</code>、<code>&quot;poly&quot;</code>、<code>&quot;sigmoid&quot;</code>的系数gamma，默认为<code>&quot;auto&quot;</code>，取特征数量的倒数，如果使用<code>&quot;scale&quot;</code>，则取特征数量乘以变量二阶矩再取倒数。</li><li><code>coef0</code>：核函数中的独立项，仅在核函数选择<code>&quot;poly&quot;</code>、<code>&quot;sigmoid&quot;</code>时有效。默认值为0.0。</li><li><code>shrinking</code>：是否使用shrinking heuristic方法，默认为<code>True</code>。</li><li><code>probability</code>：是否使用概率估计，默认为<code>False</code>。</li><li><code>tol</code>：停止训练的误差精度，默认值为1e-3。</li><li><code>cache_size</code>：核函数缓存大小。</li><li><code>class_weight</code>：接收字典或字典的列表来指定各类别的的权重，也可指定为<code>&quot;balanced&quot;</code>，使用类别出现频率的倒数作为权重。使用默认的<code>None</code>将视所有类别具有相同的权重。</li><li><code>max_iter</code>：最大迭代次数，默认为-1即无限制。</li><li><code>decision_function_shape</code>：多分类策略，可选<code>&quot;ovo&quot;</code>或<code>&quot;ovr&quot;</code>（默认）。</li><li><code>random_state</code>：随机数种子。</li></ul><p>最重要的两个调参对象是<code>gamma</code>和<code>C</code>。gamma越大，支持向量越少，gamma越小，支持向量越多。C可理解为逻辑回归中正则项系数lambda的倒数，C过大容易过拟合，C过小容易欠拟合。通常采用<a href="http://ster.im/py_sklearn_4/#GridSearchCV%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95">网格搜索法</a>进行调参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">clf = SVC(C=<span class="number">1.0</span>, kernel=<span class="string">&quot;rbf&quot;</span>, degree=<span class="number">3</span>, gamma=<span class="string">&quot;auto&quot;</span>, coef0=<span class="number">0.0</span>, shrinking=<span class="literal">True</span>, </span><br><span class="line">          probability=<span class="literal">False</span>, tol=<span class="number">0.001</span>, cache_size=<span class="number">200</span>, class_weight=<span class="literal">None</span>, verbose=<span class="literal">False</span>, </span><br><span class="line">          max_iter=-<span class="number">1</span>, decision_function_shape=<span class="string">&quot;ovr&quot;</span>, random_state=<span class="literal">None</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>部分参数如下：</p><ul><li><code>n_neighbors</code>：最近邻单元的个数K，默认为5。</li><li><code>weights</code>：是否考虑邻居的权重，默认值<code>&quot;uniform&quot;</code>视每个邻居的权重相等，<code>&quot;distance&quot;</code>则给较近的单元更大的权重（取距离的倒数），也可以指定一个可调用的函数。</li><li><code>algorithm</code>：计算最近邻的算法，默认<code>&quot;auto&quot;</code>自动挑选模型认为最合适的，可选<code>&quot;ball_tree&quot;</code>、<code>&quot;kd_tree&quot;</code>、<code>&quot;brute&quot;</code>。</li><li><code>leaf_size</code>：叶节点数量，默认值30，只有在<code>algorithm</code>选择球树或者KD树时有效。</li><li><code>p</code>：闵式距离的度量，p=1时为曼哈顿距离，p=2时为欧式距离（默认）。</li></ul><p><code>n_neighbors</code>是最需要关注的超参数，其次<code>weights</code>和<code>p</code>也可以适当调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">clf = KNeighborsClassifier(n_neighbors=<span class="number">5</span>, weights=<span class="string">&quot;uniform&quot;</span>, algorithm=<span class="string">&quot;auto&quot;</span>, leaf_size=<span class="number">30</span>, </span><br><span class="line">                           p=<span class="number">2</span>, metric=<span class="string">&quot;minkowski&quot;</span>, metric_params=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>scikit-learn提供了以下三种朴素贝叶斯模型：</p><h3 id="高斯模型"><a href="#高斯模型" class="headerlink" title="高斯模型"></a>高斯模型</h3><p>当特征是连续变量时常采用高斯模型。其参数：</p><ul><li><code>priors</code>：先验概率，如果指定为一个形如(n_classes, )的数组，则不根据数据调整先验概率。</li><li><code>var_smoothing</code>：为稳定性而加入的方差，默认为1e-9。</li></ul><h3 id="多项式模型"><a href="#多项式模型" class="headerlink" title="多项式模型"></a>多项式模型</h3><p>当特征是离散变量时常采用多项式模型。其参数：</p><ul><li><code>alpha</code>：平滑参数，默认值为1.0。</li><li><code>fit_prior</code>：是否要考虑先验概率，如果选择<code>False</code>，对所有类别使用一致的先验概率。</li><li><code>class_prior</code>：先验概率，如果指定为一个形如(n_classes, )的数组，则不根据数据调整先验概率。</li></ul><h3 id="伯努利模型"><a href="#伯努利模型" class="headerlink" title="伯努利模型"></a>伯努利模型</h3><p>当特征是布尔型变量时常采用伯努利模型。其参数：</p><ul><li><code>alpha</code>：平滑参数，默认值为1.0。</li><li><code>binarize</code>：对特征进行二值化的阈值，默认为0.0，如果设为<code>None</code>则假定输入特征已经二值化。</li><li><code>fit_prior</code>：是否要考虑先验概率，如果选择<code>False</code>，对所有类别使用一致的先验概率。</li><li><code>class_prior</code>：先验概率，如果指定为一个形如(n_classes, )的数组，则不根据数据调整先验概率。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">clf = GaussianNB(priors=<span class="literal">None</span>, var_smoothing=<span class="number">1e-09</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="集成模型：Bagging"><a href="#集成模型：Bagging" class="headerlink" title="集成模型：Bagging"></a>集成模型：Bagging</h2><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>参数：</p><ul><li><code>base_estimator</code>：基模型，默认<code>None</code>代表决策树，可选择其它基础回归模型对象。</li><li><code>n_estimators</code>：基模型的数量，默认为10。</li><li><code>max_samples</code>：用于训练基模型的从X_train中抽取样本的数量，可以是整数代表数量，也可以是浮点数代表比例，默认为1.0。</li><li><code>max_features</code>：用于训练基模型的从X_train中抽取特征的数量，可以是整数代表数量，也可以是浮点数代表比例，默认为1.0。</li><li><code>bootstrap</code>：对于样本是否有放回抽样，默认为<code>True</code>。</li><li><code>bootstrap_features</code>：对于特征是否有放回抽样，默认为<code>False</code>。</li><li><code>oob_score</code>：是否使用包外样本估计泛化误差。</li><li><code>warm_start</code>：默认为<code>False</code>，如果选择<code>True</code>，下一次训练以上一次模型的参数为初始参数。</li></ul><p>对于所有的集成模型，最需要关注的超参数是<code>n_estimators</code>，即基模型的数量，通常需要使用网格搜索法寻找最优解；其他的参数通常保持默认即可取得较好的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line">clf = BaggingClassifier(base_estimator=<span class="literal">None</span>, n_estimators=<span class="number">10</span>, max_samples=<span class="number">1.0</span>, max_features=<span class="number">1.0</span>, </span><br><span class="line">                        bootstrap=<span class="literal">True</span>, bootstrap_features=<span class="literal">False</span>, oob_score=<span class="literal">False</span>, warm_start=<span class="literal">False</span>, </span><br><span class="line">                        n_jobs=<span class="literal">None</span>, random_state=<span class="literal">None</span>, verbose=<span class="number">0</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>参数：</p><ul><li><code>n_estimators</code>：树的数量，默认为10。</li><li><code>criterion</code>：分枝的标准，默认”gini”为基尼不纯度，可选”entropy”信息增益。</li><li><code>max_depth</code>：限制树的最大深度，默认值为<code>None</code>，表示一直分枝直到所有叶节点都是纯的，或者所有叶节点的样本数小于<code>min_samples_split</code>。</li><li><code>min_samples_split</code>：分割一个节点所需的最小样本数，默认为2。</li><li><code>min_samples_leaf</code>：叶节点上所需的最小样本数，叶节点样本数少于这个值时会被剪枝。默认为1。</li><li><code>min_weight_fraction_leaf</code>：叶节点样本权重和所需的最小值，默认为0即视样本具有相同的权重。</li><li><code>max_features</code>：分枝时考虑的特征数量最大值，默认<code>&quot;auto&quot;</code>相当于<code>&quot;sqrt&quot;</code>。可以指定整数或者浮点数（表示占特征总数的比例）。也可选<code>&quot;sqrt&quot;</code>（特征数的开根）、<code>&quot;log2&quot;</code>（特征数的对数）、<code>None</code>（等于特征数）。</li><li><code>max_leaf_nodes</code>：叶节点数最大值，默认<code>None</code>不对叶节点数量做限制。</li><li><code>min_impurity_decrease</code>：默认为0，如果分枝导致不纯度的减少大于等于该值，则节点将被分枝。</li><li><code>min_impurity_split</code>：默认为1e-7，如果某节点的不纯度超过这个阈值，则该节会分枝，否则该节点为叶节点。</li><li><code>bootstrap</code>：对于样本是否有放回抽样，默认为<code>True</code>。如果为<code>False</code>，则使用整个数据集构建每个树。</li><li><code>oob_score</code>：是否使用包外样本估计R方。默认为<code>False</code>。</li><li><code>random_state</code>：随机数种子。</li><li><code>warm_start</code>：默认为<code>False</code>，如果选择<code>True</code>，下一次训练以上一次模型的参数为初始参数。</li><li><code>class_weight</code>：接收字典或字典的列表来指定各类别的的权重，也可指定为<code>&quot;balanced&quot;</code>，使用类别出现频率的倒数作为权重；指定为<code>&quot;balanced_subsample&quot;</code>则每棵树使用其抽样样本计算权重。使用默认的<code>None</code>将视所有类别具有相同的权重。</li></ul><p>除了<code>n_estimators</code>之外，还可以考虑适当调整<code>max_depth</code>、<code>min_samples_split</code>、<code>min_samples_leaf</code>、<code>max_features</code>这些决策树的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">clf = RandomForestClassifier(n_estimators=<span class="number">10</span>, criterion=<span class="string">&quot;gini&quot;</span>, max_depth=<span class="literal">None</span>, min_samples_split=<span class="number">2</span>, </span><br><span class="line">                             min_samples_leaf=<span class="number">1</span>, min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                             max_leaf_nodes=<span class="literal">None</span>, min_impurity_decrease=<span class="number">0.0</span>, min_impurity_split=<span class="literal">None</span>, </span><br><span class="line">                             bootstrap=<span class="literal">True</span>, oob_score=<span class="literal">False</span>, n_jobs=<span class="literal">None</span>, random_state=<span class="literal">None</span>, verbose=<span class="number">0</span>, </span><br><span class="line">                             warm_start=<span class="literal">False</span>, class_weight=<span class="literal">None</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h3 id="极端随机树"><a href="#极端随机树" class="headerlink" title="极端随机树"></a>极端随机树</h3><p>Extra Tree和随机森林的区别较小，参数几乎一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line">clf = ExtraTreesClassifier(n_estimators=<span class="number">10</span>, criterion=<span class="string">&quot;gini&quot;</span>, max_depth=<span class="literal">None</span>, min_samples_split=<span class="number">2</span>, </span><br><span class="line">                           min_samples_leaf=<span class="number">1</span>, min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                           max_leaf_nodes=<span class="literal">None</span>, min_impurity_decrease=<span class="number">0.0</span>, min_impurity_split=<span class="literal">None</span>, </span><br><span class="line">                           bootstrap=<span class="literal">False</span>, oob_score=<span class="literal">False</span>, n_jobs=<span class="literal">None</span>, random_state=<span class="literal">None</span>, </span><br><span class="line">                           verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>, class_weight=<span class="literal">None</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="集成模型：Boosting"><a href="#集成模型：Boosting" class="headerlink" title="集成模型：Boosting"></a>集成模型：Boosting</h2><h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><p>参数：</p><ul><li><code>base_estimator</code>：弱分类器，可指定为任意分类模型对象，默认为<code>None</code>，即<code>DecisionTreeClassifier</code>（<code>max_depth=1</code>）。</li><li><code>n_estimators</code>：最大迭代次数，即弱学习器的最大个数，默认为50。</li><li><code>learning_rate</code>：每个弱学习器的权重缩减系数，介于0.和1.之间，默认为1.。</li><li><code>algorithm</code>：算法，可选<code>&quot;SAMME&quot;</code>, <code>&quot;SAMME.R&quot;</code>。默认使用的SAMME.R算法收敛速度通常比SAMME算法快，在迭代次数较少的情况下能取得更低的测试误差。</li><li><code>random_state</code>：随机数种子。</li></ul><p><code>n_estimators</code>和<code>learning_rate</code>两个参数相互牵制，通常会一起进行调参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line">clf = AdaBoostClassifier(base_estimator=<span class="literal">None</span>, n_estimators=<span class="number">50</span>, learning_rate=<span class="number">1.0</span>, </span><br><span class="line">                         algorithm=<span class="string">&quot;SAMME.R&quot;</span>, random_state=<span class="literal">None</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h3 id="Gradient-Boosting回归"><a href="#Gradient-Boosting回归" class="headerlink" title="Gradient Boosting回归"></a>Gradient Boosting回归</h3><p>其中决策树部分的参数不列举。</p><ul><li><code>loss</code>：损失函数，默认值<code>&quot;deviance&quot;</code>使用对数损失函数，可选<code>&quot;exponential&quot;</code>，它是Adaboost的损失函数。</li><li><code>learning_rate</code>：每棵树的权重缩减系数，默认为0.1，与<code>n_estimators</code>相互牵制，是调参的重点。</li><li><code>n_estimators</code>：最大迭代次数，默认为100。</li><li><code>subsample</code>：子采样率，用于训练每棵树的样本占样本总数的比例，默认为1.0，如使用小于1.0的值，该模型就为随机梯度提升，会减少方差、增大偏差。</li><li><code>init</code>：默认为<code>None</code>，可指定具有<code>fit</code>和<code>predict</code>方法的预测器对象，它用于初始化参数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">clf = GradientBoostingClassifier(loss=<span class="string">&quot;deviance&quot;</span>, learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">100</span>, subsample=<span class="number">1.0</span>, </span><br><span class="line">                                 criterion=<span class="string">&quot;friedman_mse&quot;</span>, min_samples_split=<span class="number">2</span>, min_samples_leaf=<span class="number">1</span>, </span><br><span class="line">                                 min_weight_fraction_leaf=<span class="number">0.0</span>, max_depth=<span class="number">3</span>, min_impurity_decrease=<span class="number">0.0</span>, </span><br><span class="line">                                 min_impurity_split=<span class="literal">None</span>, init=<span class="literal">None</span>, random_state=<span class="literal">None</span>, max_features=<span class="literal">None</span>, </span><br><span class="line">                                 verbose=<span class="number">0</span>, max_leaf_nodes=<span class="literal">None</span>, warm_start=<span class="literal">False</span>, presort=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                                 validation_fraction=<span class="number">0.1</span>, n_iter_no_change=<span class="literal">None</span>, tol=<span class="number">0.0001</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（5）——scikit-learn：回归模型</title>
      <link href="/py_sklearn_1/"/>
      <url>/py_sklearn_1/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍以下几种回归算法在scikit-learn中的使用方法：</p><p>基础模型：</p><ul><li>线性回归（包含岭回归、Lasso回归、弹性网络回归）</li><li>树回归</li><li>支持向量机回归</li><li>K近邻回归</li></ul><p>集成模型：</p><ul><li>随机森林回归</li><li>极端随机树回归</li><li>AdaBoost回归</li><li>Gradient Boosting回归</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试用例：波士顿房价数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入波士顿房价数据集</span></span><br><span class="line">boston = load_boston()</span><br><span class="line">X = boston.data</span><br><span class="line">y = boston.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">X = StandardScaler().fit_transform(X)</span><br><span class="line">y = StandardScaler().fit_transform(y.reshape(-<span class="number">1</span>, <span class="number">1</span>)).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割训练集与测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h2><h3 id="最小二乘法线性回归"><a href="#最小二乘法线性回归" class="headerlink" title="最小二乘法线性回归"></a>最小二乘法线性回归</h3><p>最基本的线性回归法，它接收如下的几个参数：</p><ul><li>fit_intercept：是否考察截距项b，默认为<code>True</code>。</li><li>normalize：是否先对数据进行Z-score标准化，默认为<code>False</code>。</li><li>copy_X：默认为<code>True</code>则复制X，否则直接在原X上覆写。</li><li>n_jobs：使用的处理器核数，默认<code>None</code>表示单核。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">reg = LinearRegression(fit_intercept=<span class="literal">True</span>, normalize=<span class="literal">False</span>, copy_X=<span class="literal">True</span>, n_jobs=<span class="literal">None</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test) <span class="comment">#回归模型score返回的是R方，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各特征的系数w</span></span><br><span class="line">reg.coef_</span><br><span class="line"><span class="comment"># 截距b</span></span><br><span class="line">reg.intercept_</span><br></pre></td></tr></table></figure><h3 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h3><p>带L2正则项的线性回归，相比<code>LinearRegression</code>主要多一个正则项系数$\alpha$的参数。</p><p>与<code>Ridge</code>相比，<code>RidgeCV</code>内置了交叉验证，会自动帮我们筛出$\alpha$的最优解，省去了超参数调试的麻烦，因此通常采用后者。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeCV</span><br><span class="line">reg = RidgeCV(alphas=(<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>), fit_intercept=<span class="literal">True</span>, normalize=<span class="literal">False</span>, </span><br><span class="line">              scoring=<span class="literal">None</span>, cv=<span class="number">5</span>, gcv_mode=<span class="literal">None</span>, store_cv_values=<span class="literal">False</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则项系数alpha</span></span><br><span class="line">reg.alpha_</span><br></pre></td></tr></table></figure><h3 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h3><p>带L1正则项的线性回归，常用来估计稀疏参数的高维线性模型。</p><p>供有<code>Lasso</code>、<code>LassoCV</code>、<code>LassoLars</code>、<code>LassoLarsCV</code>、<code>LassoLarsIC</code>五种可供选择，带<code>CV</code>的即自动选择最优的正则项系数，带<code>Lars</code>的采用最小角回归法而不带<code>Lars</code>的采用坐标轴下降法进行损失函数优化。<code>LassoLarsIC</code>采用AIC（Akaike信息准则）或BIC（Bayes信息准则）确定正则项系数。在大多数回归任务中，首选<code>LassoCV</code>，次选<code>LassoLarsCV</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LassoCV</span><br><span class="line">reg = LassoCV(eps=<span class="number">0.001</span>, n_alphas=<span class="number">100</span>, alphas=<span class="literal">None</span>, fit_intercept=<span class="literal">True</span>, </span><br><span class="line">              normalize=<span class="literal">False</span>, precompute=<span class="string">&quot;auto&quot;</span>, max_iter=<span class="number">1000</span>, tol=<span class="number">0.0001</span>, </span><br><span class="line">              copy_X=<span class="literal">True</span>, cv=<span class="number">5</span>, verbose=<span class="literal">False</span>, n_jobs=<span class="literal">None</span>, </span><br><span class="line">              positive=<span class="literal">False</span>, random_state=<span class="literal">None</span>, selection=<span class="string">&quot;cyclic&quot;</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h3 id="弹性网络回归"><a href="#弹性网络回归" class="headerlink" title="弹性网络回归"></a>弹性网络回归</h3><p>同时带有L1和L2正则项的线性回归，使用<code>l1_ratio</code>这一权重参数来分配L1和L2正则项的比重。常用<code>ElasticNetCV</code>，它会自动选择正则项系数和平衡权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNetCV</span><br><span class="line">reg = ElasticNetCV(l1_ratio=<span class="number">0.5</span>, eps=<span class="number">0.001</span>, n_alphas=<span class="number">100</span>, alphas=<span class="literal">None</span>, </span><br><span class="line">                   fit_intercept=<span class="literal">True</span>, normalize=<span class="literal">False</span>, precompute=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                   max_iter=<span class="number">1000</span>, tol=<span class="number">0.0001</span>, cv=<span class="number">5</span>, copy_X=<span class="literal">True</span>, verbose=<span class="number">0</span>, </span><br><span class="line">                   n_jobs=<span class="literal">None</span>, positive=<span class="literal">False</span>, random_state=<span class="literal">None</span>, selection=<span class="string">&quot;cyclic&quot;</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><p>其他线性模型，敬请参阅<a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.linear_model">官方文档：线性回归</a>。</p><h2 id="树回归"><a href="#树回归" class="headerlink" title="树回归"></a>树回归</h2><p>CART用于回归时，参数与分类器类似，它可以接收如下的参数：</p><ul><li><code>criterion</code>：分枝的标准，默认<code>&quot;mse&quot;</code>为均方差，可选<code>&quot;friedman_mse&quot;</code>（Friedman均方差）或者<code>&quot;mae&quot;</code>（绝对平均误差）。通常采用默认值。</li><li><code>splitter</code>：分枝的策略，默认<code>&quot;best&quot;</code>在所有划分点中找出最优的划分点，适合样本量不大的情况。样本量巨大时建议选择<code>&quot;random&quot;</code>，在部分划分点中找局部最优的划分点。</li><li><code>max_depth</code>：限制树的最大深度，默认值为<code>None</code>。如果样本和特征很多时可以适当限制树的最大深度。</li><li><code>min_samples_split</code>：分割一个节点所需的最小样本数，默认为2，当样本量非常大时可以增加这个值。</li><li><code>min_samples_leaf</code>：叶节点上所需的最小样本数，叶节点样本数少于这个值时会被剪枝。默认为1，当样本量非常大时可以增加这个值。</li><li><code>min_weight_fraction_leaf</code>：叶节点样本权重和所需的最小值，默认为0即视样本具有相同的权重。</li><li><code>max_features</code>：分枝时考虑的特征数量最大值，默认<code>&quot;auto&quot;</code>即该值等于特征数量。可以指定整数或者浮点数（表示占特征总数的比例）。也可选<code>&quot;sqrt&quot;</code>（特征数的开根）、<code>&quot;log2&quot;</code>（特征数的对数）、<code>None</code>（等于特征数）。如果特征数较多可以考虑限制以加快模型拟合。</li><li><code>random_state</code>：随机数种子。</li><li><code>max_leaf_nodes</code>：叶节点数最大值，默认<code>None</code>不对叶节点数量做限制，如果特征较多可以加以限制。</li><li><code>min_impurity_decrease</code>：默认为0.，如果分枝导致不纯度的减少大于等于该值，则节点将被分枝。</li><li><code>min_impurity_split</code>：默认为1e-7，如果某节点的不纯度超过这个阈值，则该节会分枝，否则该节点为叶节点。</li><li><code>presort</code>：是否对数据进行预排序，以加快寻找最佳分割点。默认为<code>False</code>。当使用小数据集或对深度作限制时，设置为<code>True</code>可能会加速训练，但对于大型数据集则反而会变慢。</li></ul><p>我们超参数调优的主要对象为<code>max_depth</code>、<code>min_samples_split</code>、<code>min_samples_leaf</code>、<code>max_features</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">reg = DecisionTreeRegressor(criterion=<span class="string">&quot;mse&quot;</span>, splitter=<span class="string">&quot;best&quot;</span>, max_depth=<span class="literal">None</span>, </span><br><span class="line">                            min_samples_split=<span class="number">2</span>, min_samples_leaf=<span class="number">1</span>, </span><br><span class="line">                            min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="literal">None</span>, </span><br><span class="line">                            random_state=<span class="literal">None</span>, max_leaf_nodes=<span class="literal">None</span>, </span><br><span class="line">                            min_impurity_decrease=<span class="number">0.0</span>, min_impurity_split=<span class="literal">None</span>, </span><br><span class="line">                            presort=<span class="literal">False</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="支持向量机回归"><a href="#支持向量机回归" class="headerlink" title="支持向量机回归"></a>支持向量机回归</h2><p>部分参数如下：</p><ul><li><code>kernel</code>：核函数，默认使用<code>&quot;rbf&quot;</code>径向基函数，可选<code>&quot;linear&quot;</code>、<code>&quot;poly&quot;</code>、<code>&quot;sigmoid&quot;</code>、<code>&quot;precomputed&quot;</code>或者一个可调用的函数。</li><li><code>degree</code>：多项式核函数的维度d，仅在核函数选择<code>&quot;poly&quot;</code>时有效。默认值为3。</li><li><code>gamma</code>：<code>&quot;rbf&quot;</code>、<code>&quot;poly&quot;</code>、<code>&quot;sigmoid&quot;</code>的系数gamma，默认为<code>&quot;auto&quot;</code>，取特征数量的倒数。</li><li><code>coef0</code>：核函数中的独立项，仅在核函数选择<code>&quot;poly&quot;</code>、<code>&quot;sigmoid&quot;</code>时有效。默认值为0.0。</li><li><code>tol</code>：停止训练的误差精度，默认值为1e-3。</li><li><code>C</code>：惩罚系数C，默认值为1.0。</li><li><code>max_iter</code>：最大迭代次数，默认为-1即无限制。</li></ul><p>最重要的两个调参对象是<code>gamma</code>和<code>C</code>。gamma越大，支持向量越少，gamma越小，支持向量越多。C可理解为逻辑回归中正则项系数lambda的倒数，C过大容易过拟合，C过小容易欠拟合。通常采用<a href="http://ster.im/py_sklearn_4/#GridSearchCV%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95">网格搜索法</a>进行调参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line">reg = SVR(kernel=<span class="string">&quot;rbf&quot;</span>, degree=<span class="number">3</span>, gamma=<span class="string">&quot;auto&quot;</span>, coef0=<span class="number">0.0</span>, </span><br><span class="line">          tol=<span class="number">0.001</span>, C=<span class="number">1.0</span>, epsilon=<span class="number">0.1</span>, shrinking=<span class="literal">True</span>, </span><br><span class="line">          cache_size=<span class="number">200</span>, verbose=<span class="literal">False</span>, max_iter=-<span class="number">1</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="K近邻回归"><a href="#K近邻回归" class="headerlink" title="K近邻回归"></a>K近邻回归</h2><p>部分参数如下：</p><ul><li><code>n_neighbors</code>：最近邻单元的个数K。</li><li><code>weights</code>：是否考虑邻居的权重，默认值<code>&quot;uniform&quot;</code>视每个邻居的权重相等，<code>&quot;distance&quot;</code>则给较近的单元更大的权重（取距离的倒数），也可以指定一个可调用的函数。</li><li><code>algorithm</code>：计算最近邻的算法，默认<code>&quot;auto&quot;</code>自动挑选模型认为最合适的，可选<code>&quot;ball_tree&quot;</code>、<code>&quot;kd_tree&quot;</code>、<code>&quot;brute&quot;</code>。</li><li><code>leaf_size</code>：叶节点数量，默认值30，只有在<code>algorithm</code>选择球树或者KD树时有效。</li><li><code>p</code>：闵式距离的度量，p=1时为曼哈顿距离，p=2时为欧式距离（默认）。</li></ul><p><code>n_neighbors</code>是最需要关注的超参数，其次<code>weights</code>和<code>p</code>也可以适当调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">reg = KNeighborsRegressor(n_neighbors=<span class="number">5</span>, weights=<span class="string">&quot;uniform&quot;</span>, algorithm=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                          leaf_size=<span class="number">30</span>, p=<span class="number">2</span>, metric=<span class="string">&quot;minkowski&quot;</span>, metric_params=<span class="literal">None</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="集成回归模型：Bagging"><a href="#集成回归模型：Bagging" class="headerlink" title="集成回归模型：Bagging"></a>集成回归模型：Bagging</h2><h3 id="Bagging回归"><a href="#Bagging回归" class="headerlink" title="Bagging回归"></a>Bagging回归</h3><p>参数：</p><ul><li><code>base_estimator</code>：基模型，默认<code>None</code>代表决策树，可选择其它基础回归模型对象。</li><li><code>n_estimators</code>：基模型的数量，默认为10。</li><li><code>max_samples</code>：用于训练基模型的从X_train中抽取样本的数量，可以是整数代表数量，也可以是浮点数代表比例，默认为1.0。</li><li><code>max_features</code>：用于训练基模型的从X_train中抽取特征的数量，可以是整数代表数量，也可以是浮点数代表比例，默认为1.0。</li><li><code>bootstrap</code>：对于样本是否有放回抽样，默认为<code>True</code>。</li><li><code>bootstrap_features</code>：对于特征是否有放回抽样，默认为<code>False</code>。</li><li><code>oob_score</code>：是否使用包外样本估计泛化误差。</li><li><code>warm_start</code>：默认为<code>False</code>，如果选择<code>True</code>，下一次训练以上一次模型的参数为初始参数。</li></ul><p>对于所有的集成模型，最需要关注的超参数是<code>n_estimators</code>，即基模型的数量，通常需要使用网格搜索法寻找最优解；其他的参数通常保持默认即可取得较好的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line">reg = BaggingRegressor(base_estimator=<span class="literal">None</span>, n_estimators=<span class="number">10</span>, max_samples=<span class="number">1.0</span>, </span><br><span class="line">                       max_features=<span class="number">1.0</span>, bootstrap=<span class="literal">True</span>, bootstrap_features=<span class="literal">False</span>, </span><br><span class="line">                       oob_score=<span class="literal">False</span>, warm_start=<span class="literal">False</span>, random_state=<span class="literal">None</span>, verbose=<span class="number">0</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h3 id="随机森林回归"><a href="#随机森林回归" class="headerlink" title="随机森林回归"></a>随机森林回归</h3><p>参数：</p><ul><li><code>n_estimators</code>：树的数量，默认为10。</li><li><code>criterion</code>：分枝的标准，默认<code>&quot;mse&quot;</code>为均方差，可选<code>&quot;mae&quot;</code>（绝对平均误差）。</li><li><code>max_depth</code>：限制树的最大深度，默认值为<code>None</code>，表示一直分枝直到所有叶节点都是纯的，或者所有叶节点的样本数小于<code>min_samples_split</code>。</li><li><code>min_samples_split</code>：分割一个节点所需的最小样本数，默认为2。</li><li><code>min_samples_leaf</code>：叶节点上所需的最小样本数，叶节点样本数少于这个值时会被剪枝。默认为1。</li><li><code>min_weight_fraction_leaf</code>：叶节点样本权重和所需的最小值，默认为0即视样本具有相同的权重。</li><li><code>max_features</code>：分枝时考虑的特征数量最大值，默认<code>&quot;auto&quot;</code>即该值等于特征数量。可以指定整数或者浮点数（表示占特征总数的比例）。也可选<code>&quot;sqrt&quot;</code>（特征数的开根）、<code>&quot;log2&quot;</code>（特征数的对数）、<code>None</code>（等于特征数）。</li><li><code>max_leaf_nodes</code>：叶节点数最大值，默认<code>None</code>不对叶节点数量做限制。</li><li><code>min_impurity_decrease</code>：默认为0，如果分枝导致不纯度的减少大于等于该值，则节点将被分枝。</li><li><code>min_impurity_split</code>：默认为1e-7，如果某节点的不纯度超过这个阈值，则该节会分枝，否则该节点为叶节点。</li><li><code>bootstrap</code>：对于样本是否有放回抽样，默认为<code>True</code>。如果为<code>False</code>，则使用整个数据集构建每个树。</li><li><code>oob_score</code>：是否使用包外样本估计R方。默认为<code>False</code>。</li><li><code>random_state</code>：随机数种子。</li><li><code>warm_start</code>：默认为<code>False</code>，如果选择<code>True</code>，下一次训练以上一次模型的参数为初始参数。</li></ul><p>除了<code>n_estimators</code>之外，还可以考虑适当调整<code>max_depth</code>、<code>min_samples_split</code>、<code>min_samples_leaf</code>、<code>max_features</code>这些决策树的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">reg = RandomForestRegressor(n_estimators=<span class="number">10</span>, criterion=<span class="string">&quot;mse&quot;</span>, max_depth=<span class="literal">None</span>, </span><br><span class="line">                            min_samples_split=<span class="number">2</span>, min_samples_leaf=<span class="number">1</span>, </span><br><span class="line">                            min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                            max_leaf_nodes=<span class="literal">None</span>, min_impurity_decrease=<span class="number">0.0</span>, </span><br><span class="line">                            min_impurity_split=<span class="literal">None</span>, bootstrap=<span class="literal">True</span>, oob_score=<span class="literal">False</span>, </span><br><span class="line">                            random_state=<span class="literal">None</span>, verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各特征的重要性</span></span><br><span class="line">reg.feature_importances_</span><br></pre></td></tr></table></figure><h3 id="极端随机树回归"><a href="#极端随机树回归" class="headerlink" title="极端随机树回归"></a>极端随机树回归</h3><p>Extra Tree和随机森林的区别较小，参数几乎一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesRegressor</span><br><span class="line">reg = ExtraTreesRegressor(n_estimators=<span class="number">10</span>, criterion=<span class="string">&quot;mse&quot;</span>, max_depth=<span class="literal">None</span>, </span><br><span class="line">                          min_samples_split=<span class="number">2</span>, min_samples_leaf=<span class="number">1</span>, </span><br><span class="line">                          min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                          max_leaf_nodes=<span class="literal">None</span>, min_impurity_decrease=<span class="number">0.0</span>, </span><br><span class="line">                          min_impurity_split=<span class="literal">None</span>, bootstrap=<span class="literal">False</span>, oob_score=<span class="literal">False</span>, </span><br><span class="line">                          random_state=<span class="literal">None</span>, verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h2 id="集成回归模型：Boosting"><a href="#集成回归模型：Boosting" class="headerlink" title="集成回归模型：Boosting"></a>集成回归模型：Boosting</h2><h3 id="AdaBoost回归"><a href="#AdaBoost回归" class="headerlink" title="AdaBoost回归"></a>AdaBoost回归</h3><p>参数：</p><ul><li><code>base_estimator</code>：弱回归学习器，可指定为任意回归模型对象，默认为<code>None</code>，即<code>DecisionTreeRegressor</code>（<code>max_depth=3</code>）。</li><li><code>n_estimators</code>：最大迭代次数，即弱学习器的最大个数，默认为50。</li><li><code>learning_rate</code>：每个弱学习器的权重缩减系数，介于0.和1.之间，默认为1.。</li><li><code>loss</code>：每次迭代后更新权重时采用的损失函数，默认为<code>&quot;linear&quot;</code>，可选<code>&quot;square&quot;</code>、<code>&quot;exponential&quot;</code>，通常使用默认值。</li><li><code>random_state</code>：随机数种子。</li></ul><p><code>n_estimators</code>和<code>learning_rate</code>两个参数相互牵制，通常会一起进行调参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostRegressor</span><br><span class="line">reg = AdaBoostRegressor(base_estimator=<span class="literal">None</span>, n_estimators=<span class="number">50</span>, learning_rate=<span class="number">1.0</span>, loss=<span class="string">&quot;linear&quot;</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure><h3 id="Gradient-Boosting回归"><a href="#Gradient-Boosting回归" class="headerlink" title="Gradient Boosting回归"></a>Gradient Boosting回归</h3><p>其中决策树部分的参数不列举。</p><ul><li><code>loss</code>：损失函数，默认值<code>&quot;ls&quot;</code>代表最小二乘回归，可选<code>&quot;lad&quot;</code>（最小绝对偏差）、<code>&quot;huber&quot;</code>（前两者的结合）和<code>&quot;quantile&quot;</code>（分位数回归）。</li><li><code>learning_rate</code>：每棵树的权重缩减系数，默认为0.1，与<code>n_estimators</code>相互牵制，是调参的重点。</li><li><code>n_estimators</code>：最大迭代次数，默认为100。</li><li><code>subsample</code>：子采样率，用于训练每棵树的样本占样本总数的比例，默认为1.0，如使用小于1.0的值，该模型就为随机梯度提升，会减少方差、增大偏差。</li><li><code>init</code>：默认为<code>None</code>，可指定具有<code>fit</code>和<code>predict</code>方法的预测器对象，它用于初始化参数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line">reg = GradientBoostingRegressor(loss=<span class="string">&quot;ls&quot;</span>, learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">100</span>, </span><br><span class="line">                                subsample=<span class="number">1.0</span>, criterion=<span class="string">&quot;friedman_mse&quot;</span>, min_samples_split=<span class="number">2</span>, </span><br><span class="line">                                min_samples_leaf=<span class="number">1</span>, min_weight_fraction_leaf=<span class="number">0.0</span>, max_depth=<span class="number">3</span>, </span><br><span class="line">                                min_impurity_decrease=<span class="number">0.0</span>, min_impurity_split=<span class="literal">None</span>, init=<span class="literal">None</span>, </span><br><span class="line">                                random_state=<span class="literal">None</span>, max_features=<span class="literal">None</span>, alpha=<span class="number">0.9</span>, verbose=<span class="number">0</span>, </span><br><span class="line">                                max_leaf_nodes=<span class="literal">None</span>, warm_start=<span class="literal">False</span>, presort=<span class="string">&quot;auto&quot;</span>, </span><br><span class="line">                                validation_fraction=<span class="number">0.1</span>, n_iter_no_change=<span class="literal">None</span>, tol=<span class="number">0.0001</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（4）——scikit-learn：快速入门</title>
      <link href="/py_sklearn_0/"/>
      <url>/py_sklearn_0/</url>
      
        <content type="html"><![CDATA[<p>scikit-learn是用python进行机器学习项目的最重要的模块，它对主要的机器学习模型进行了封装，支持分类、回归、聚类、降维等机器学习任务，涵盖了树、支持向量机、神经网络等主流机器学习模型，并且提供了特征缩放、模型评估等功能。一个优秀的数据科学工作者应当熟练掌握它。</p><p>scikit-learn的<a href="https://scikit-learn.org/stable/">官方文档地址</a>，<a href="http://sklearn.apachecn.org/">官方中文文档地址</a>。</p><p>scikit-learn内容较多，将分为5篇文章分步阐述：</p><ul><li>数据载入、预处理（标准化、归一化、特征转换）、保存与恢复</li><li>回归（线性模型，树回归，SVM回归，KNN回归，集成回归模型）</li><li>分类（逻辑回归，决策树，贝叶斯分类器，神经网络，SVM，KNN，集成分类模型）</li><li>聚类（K-Means、DBSCAN）、降维（PCA、LDA）</li><li>模型评估与优化</li></ul><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>为了帮助新手快速入门机器学习项目，scikit-learn内建了许多经典的机器学习数据集。注意有部分较大的数据集在首次使用时需要联网下载。</p><p>列举其中一些数据集如下：</p><table><thead><tr><th align="left">数据集</th><th align="left">说明</th><th align="center">类型</th></tr></thead><tbody><tr><td align="left"><code>datasets.load_boston</code></td><td align="left">波士顿房价数据集</td><td align="center">回归</td></tr><tr><td align="left"><code>datasets.load_breast_cancer</code></td><td align="left">威斯康辛州乳腺癌数据集</td><td align="center">二分类</td></tr><tr><td align="left"><code>datasets.load_digits</code></td><td align="left">8×8手写数字数据集</td><td align="center">多分类</td></tr><tr><td align="left"><code>datasets.load_iris</code></td><td align="left">鸢尾花数据集</td><td align="center">多分类</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入内建数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"><span class="comment"># 获得ndarray格式的变量X和标签y</span></span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"><span class="comment"># 获得数据维度</span></span><br><span class="line">n_samples, n_features = iris.data.shape</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在<a href="http://ster.im/py_pd/">《Python机器学习库笔记（3）——pandas》</a>一节中，已经利用pandas库对数据集完成去重、填充缺失值等工作。此外还需使用scikit-learn中的<code>preprocessing</code>模块来对数据做进一步的处理。</p><h3 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h3><p>数据标准化和归一化是将数据映射到一个小的浮点数范围内，以便模型能快速收敛。</p><p>标准化有多种方式，常用的一种是min-max标准化（对象名为<code>MinMaxScaler</code>），该方法使数据落到[0,1]区间：</p><p>$$x’=\frac{x-x_{min}}{x_{max}-x_{min}}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># min-max标准化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">sc = MinMaxScaler()</span><br><span class="line">sc.fit(X)</span><br><span class="line">sc.transform(X)</span><br></pre></td></tr></table></figure><p>另一种是Z-score标准化（对象名为<code>StandardScaler</code>），该方法使数据满足标准正态分布：</p><p>$$x’=\frac{x-\bar{X}}{S}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Z-score标准化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">StandardScaler().fit_transform(X) <span class="comment">#将fit和transform组合执行</span></span><br></pre></td></tr></table></figure><p>归一化（对象名为<code>Normalizer</code>，默认为L2归一化）：</p><p>$$x’=\frac{x}{\sqrt{\Sigma^m_jx[j]^2}}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L2归一化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Normalizer</span><br><span class="line">Normalizer().fit_transform(X)</span><br></pre></td></tr></table></figure><h3 id="数据二值化"><a href="#数据二值化" class="headerlink" title="数据二值化"></a>数据二值化</h3><p>使用阈值过滤器将数据转化为布尔值，即为二值化。使用<code>Binarizer</code>对象实现数据的二值化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二值化，阈值设置为3</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line">Binarizer(threshold=<span class="number">3</span>).fit_transform(X)</span><br></pre></td></tr></table></figure><h3 id="标签编码"><a href="#标签编码" class="headerlink" title="标签编码"></a>标签编码</h3><p>使用<code>LabelEncoder</code>将不连续的数值或文本变量转化为有序的数值型变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标签编码</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">LabelEncoder().fit_transform([<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h3><p>对于无序的离散型特征，其数值大小并没有意义，需要对其进行one-hot编码，将其特征的m个可能值转化为m个二值化特征。可以利用<code>OneHotEncoder</code>对象实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 独热编码</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">OneHotEncoder().fit_transform(y.reshape(-<span class="number">1</span>,<span class="number">1</span>)).toarray()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>OneHotEncoder</code>无法对字符串类型进行转换，须先进行<code>LabelEncoder</code>将其转化为数字，或者尝试用<code>pandas.get_dummies()</code>来完成这一步工作。</p><h2 id="数据集拆分"><a href="#数据集拆分" class="headerlink" title="数据集拆分"></a>数据集拆分</h2><p>为了进行模型评估，将训练数据集拆分成训练集和测试集，可使用<code>train_test_split</code>，它接收如下参数：</p><ul><li><code>train_data</code>：用于拆分的数据集的特征集X。</li><li><code>train_target</code>：用于拆分的数据集的标签y。</li><li><code>test_size</code>：如果是浮点数，表示测试集样本占比；如果是整数，表示测试集样本的数量。</li><li><code>random_state</code>：随机数种子。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机拆分20%数据作为测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>在scikit-learn中，所有模型都是<code>BaseEstimator</code>的子类，他们都有同样的接口供调用。监督学习模型都具有以下的方法：</p><ul><li><code>fit</code>：对数据进行拟合。</li><li><code>set_params</code>：设定模型参数。</li><li><code>get_params</code>：返回模型参数。</li><li><code>predict</code>：在指定的数据集上预测。</li><li><code>score</code>：返回预测器的得分。</li></ul><p>鸢尾花数据集是一个分类任务，故以决策树模型为例，采用默认参数拟合模型，并对验证集预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 决策树分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">model = DecisionTreeClassifier()</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"><span class="comment"># 在测试集上预测</span></span><br><span class="line">model.predict(X_test)</span><br><span class="line"><span class="comment"># 测试集上的得分（默认为准确率）</span></span><br><span class="line">model.score(X_test, y_test)</span><br></pre></td></tr></table></figure><p>scikit-learn中所有模型的调用方式都类似。关于其他模型以及模型的参数用法，可参阅我的相关文章：</p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>评估模型的常用方法为K折交叉验证，它将数据集划分为K个大小相近的子集（K通常取10），每次选择其中(K-1)个子集的并集做为训练集，余下的做为测试集，总共得到K组训练集&amp;测试集，最终返回这K次测试结果的得分，取其均值可作为选定最终模型的指标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交叉验证</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line">cross_val_score(model, X, y, scoring=<span class="literal">None</span>, cv=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：由于之前采用了<code>train_test_split</code>分割数据集，它默认对数据进行了洗牌，所以这里可以直接使用<code>cv=10</code>来进行10折交叉验证（<code>cross_val_score</code>不会对数据进行洗牌）。如果之前未对数据进行洗牌，则要搭配使用<code>KFold</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line">n_folds = <span class="number">10</span></span><br><span class="line">kf = KFold(n_folds, shuffle=<span class="literal">True</span>).get_n_splits(X)</span><br><span class="line">cross_val_score(model, X, y, scoring=<span class="literal">None</span>, cv = kf)</span><br></pre></td></tr></table></figure><p>关于模型评估的更多信息，详见<a href="http://ster.im/py_sklearn_4">这篇文章</a>。</p><h2 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h2><p>在训练模型后可将模型保存，以免下次重复训练。一种方法是采用python标准库中的<code>pickle</code>，另一种是使用sklearn的<code>joblib</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">joblib.dump(model,<span class="string">&#x27;myModel.pkl&#x27;</span>)</span><br><span class="line"><span class="comment"># 载入模型</span></span><br><span class="line">model=joblib.load(<span class="string">&#x27;myModel.pkl&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（3）——pandas</title>
      <link href="/py_pd/"/>
      <url>/py_pd/</url>
      
        <content type="html"><![CDATA[<p>Pandas全称”Python Data Analysis Library”，是python的数据分析库。</p><p>本文仅列举在各类机器学习项目中常用的一些功能。更多功能详见<a href="http://pandas.pydata.org/pandas-docs/stable/">官方文档</a>。</p><p>本文参考了官方文档的<a href="http://pandas.pydata.org/pandas-docs/stable/10min.html">《10分钟速成pandas》</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Pandas提供两种数据类型：Series和DataFrame。</p><p>Series是带索引的一维数据结构，如果未指定索引，则以数字自动生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个Series</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,np.nan,<span class="number">6</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><p>DataFrame是二维数据结构，数据以行和列构成，每一行和每一列都是Series对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个DataFrame</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>), columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可从字典对象创建DataFrame</span></span><br><span class="line">dates = pd.date_range(<span class="string">&#x27;20180101&#x27;</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span> : pd.date_range(<span class="string">&#x27;20180101&#x27;</span>, periods=<span class="number">6</span>),</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span> : np.random.randn(<span class="number">6</span>),</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span> : s.values,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span> : np.array([<span class="number">3</span>] * <span class="number">6</span>, dtype=<span class="string">&#x27;int32&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span> : pd.Categorical([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;train&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;train&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;train&quot;</span>]),</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span> : <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><h3 id="描述性统计"><a href="#描述性统计" class="headerlink" title="描述性统计"></a>描述性统计</h3><p>Pandas的一大功能是对数据进行探索性数据分析（Exploratory Data Analysis）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据表维度</span></span><br><span class="line">df.shape</span><br><span class="line"><span class="comment"># 查看前5行数据</span></span><br><span class="line">df.head(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 查看末尾5行数据</span></span><br><span class="line">df.tail(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 查看行标签</span></span><br><span class="line">df.index</span><br><span class="line"><span class="comment"># 查看列标签</span></span><br><span class="line">df.columns</span><br><span class="line"><span class="comment"># 查看数据表的值</span></span><br><span class="line">df.values</span><br><span class="line"><span class="comment"># 查看每列的数据类型</span></span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是由行标签构成的列，一张表可以有不止一个索引列。未指定索引列时，默认使用从0开始的行号作为索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看索引列</span></span><br><span class="line">df.index</span><br><span class="line"><span class="comment"># 设置索引列</span></span><br><span class="line">df.set_index(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="comment"># 重置索引列</span></span><br><span class="line">df.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="统计量"><a href="#统计量" class="headerlink" title="统计量"></a>统计量</h3><p>诸如求和（<code>sum</code>）等方法只对数值型的列有效，而求众数（<code>mode</code>）等方法对字符型的列也有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主要统计信息</span></span><br><span class="line">df.describe()</span><br><span class="line"><span class="comment"># 求和，默认axis=0按列求和</span></span><br><span class="line">df.<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 非缺失值计数</span></span><br><span class="line">df.count()</span><br><span class="line"><span class="comment"># 均值</span></span><br><span class="line">df.mean()</span><br><span class="line"><span class="comment"># 标准差</span></span><br><span class="line">df.std()</span><br><span class="line"><span class="comment"># 中位数</span></span><br><span class="line">df.median()</span><br><span class="line"><span class="comment"># 众数</span></span><br><span class="line">df.mode()</span><br><span class="line"><span class="comment"># 偏度</span></span><br><span class="line">df.skew()</span><br><span class="line"><span class="comment"># 峰度</span></span><br><span class="line">df.kurt()</span><br></pre></td></tr></table></figure><h3 id="协方差、相关系数"><a href="#协方差、相关系数" class="headerlink" title="协方差、相关系数"></a>协方差、相关系数</h3><p>DataFrame对象调用这两个方法会对全部数值型的列相互进行计算。Series对象调用这两个方法需要指定另一个Series对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame协方差矩阵</span></span><br><span class="line">df.cov()</span><br><span class="line"><span class="comment"># DataFrame相关系数矩阵</span></span><br><span class="line">df.corr()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Series协方差</span></span><br><span class="line">df[<span class="string">&#x27;B&#x27;</span>].cov(df[<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"><span class="comment"># Series相关系数</span></span><br><span class="line">df[<span class="string">&#x27;B&#x27;</span>].corr(df[<span class="string">&#x27;C&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>DataFrame有两种排序方法：<code>sort_values</code>按照值排序，<code>sort_index</code>按照索引号排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按索引标签排序，默认axis=0为对行排序，ascending=True为升序</span></span><br><span class="line">df.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 按指定列的值排序</span></span><br><span class="line">df.sort_values(by=[<span class="string">&#x27;B&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h3 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h3><p>直接索引：使用类似字典的索引方法得到的是列，使用切片得到的是行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选中一列（2种方法）</span></span><br><span class="line">df[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">df.A <span class="comment">#不推荐</span></span><br><span class="line"><span class="comment"># 选中多列</span></span><br><span class="line">df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]</span><br><span class="line"><span class="comment"># 切片选中多行</span></span><br><span class="line">df[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#不包括冒号后的那一行</span></span><br></pre></td></tr></table></figure><p>此外还有<code>loc</code>和<code>iloc</code>两种方法用于选中操作，<code>loc</code>是基于索引标签的，而<code>iloc</code>基于位置（即行号）的。</p><p><code>loc</code>：传入的第一个参数是索引列的标签。当索引是默认的行号时，要注意和<code>iloc</code>的区别。此方法切片时，注意冒号左右两边的行都会被选取到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一行</span></span><br><span class="line">df.loc[<span class="number">1</span>] <span class="comment">#注意：这里的整型数字并非行号，而是代表索引标签</span></span><br><span class="line"><span class="comment"># 切片选择指定的行和列</span></span><br><span class="line">df.loc[<span class="number">1</span>:<span class="number">3</span>, <span class="string">&#x27;B&#x27;</span>:<span class="string">&#x27;E&#x27;</span>] <span class="comment">#包括冒号后的那一行</span></span><br><span class="line"><span class="comment"># 选择不连续的多行和多列</span></span><br><span class="line">df.loc[[<span class="number">1</span>, <span class="number">3</span>], [<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]] <span class="comment">#包括冒号后的那一行</span></span><br><span class="line"><span class="comment"># 获取特定位置的值（2种方法）</span></span><br><span class="line">df.loc[<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">df.at[<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>iloc</code>：传入的第一个参数是索引所在的位置，即行号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择第n行</span></span><br><span class="line">df.iloc[<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 切片选择</span></span><br><span class="line">df.iloc[<span class="number">3</span>:<span class="number">5</span>, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 选中指定位置</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="comment"># 获取特定位置的值（2种方法）</span></span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">df.iat[<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h3><p>可以用逻辑运算符连接多个条件表达式以进行复合筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选</span></span><br><span class="line">df[df.B &gt; <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 复合筛选</span></span><br><span class="line">df[(df.B &gt; <span class="number">0</span>) &amp; (df.E==<span class="string">&#x27;test&#x27;</span>) ]</span><br><span class="line"><span class="comment"># 用isin筛选某列中包含指定元素的条目</span></span><br><span class="line">df[df[<span class="string">&#x27;E&#x27;</span>].isin([<span class="string">&#x27;train&#x27;</span>])]</span><br><span class="line"><span class="comment"># 筛选并选中指定的列</span></span><br><span class="line">df.loc[df.B &gt; <span class="number">0</span>, [<span class="string">&#x27;C&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>对数据表进行分组，可以直观显示所需的部分数据、对部分数据运用函数或者利用所需数据构建新的数据表。可以利用<code>groupby</code>方法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df4 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span> : np.random.randn(<span class="number">8</span>),</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span> : np.random.randn(<span class="number">8</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按一列分组并求和</span></span><br><span class="line">df4.groupby(<span class="string">&#x27;A&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按多列分组并求和</span></span><br><span class="line">df4.groupby([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><p>选中元素之后可以进行诸如赋值、改变数据类型等操作。</p><p><strong>注意</strong>：涉及到对数据进行更改的方法，都会有<code>inplace</code>这个参数，默认值为<code>False</code>，不对原对象修改，创建副本并返回修改后的新值，设置为<code>True</code>时则不创建新的对象，直接对原始对象进行修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据表转置</span></span><br><span class="line">df.T</span><br><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].dtype</span><br><span class="line"><span class="comment"># 更改数据类型</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="comment"># 查看唯一值</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].unique()</span><br><span class="line"><span class="comment"># 查看空值</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].isnull()</span><br><span class="line"><span class="comment"># 更改列名</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].rename(<span class="string">&#x27;newC&#x27;</span>)</span><br><span class="line"><span class="comment"># 对该列去重（保留第一次出现的值）</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].drop_duplicates()</span><br><span class="line"><span class="comment"># 全部替换</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>].replace(<span class="number">8.</span>, <span class="number">9.</span>)</span><br><span class="line"><span class="comment"># 统计各唯一值出现的次数</span></span><br><span class="line">df[<span class="string">&#x27;E&#x27;</span>].value_counts()</span><br><span class="line"><span class="comment"># 字符串操作，以大小写为例</span></span><br><span class="line">df[<span class="string">&#x27;E&#x27;</span>].<span class="built_in">str</span>.upper()</span><br><span class="line"><span class="comment"># 将所有值应用同一个函数</span></span><br><span class="line">df[<span class="string">&#x27;B&#x27;</span>].apply(<span class="keyword">lambda</span> x:x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="合并数据表"><a href="#合并数据表" class="headerlink" title="合并数据表"></a>合并数据表</h2><p>Pandas提供了<code>concat</code>、<code>append</code>、<code>merge</code>三种方法进行数据表合并。</p><p><code>concat</code>：一种基本的数据表合并方式，支持横向和纵向合并。它主要接收以下参数：</p><ul><li><code>axis</code>：合并的方向，默认为0表示纵向合并。</li><li><code>ignore_index</code>：是否重置索引，默认为<code>False</code>，这时保留原数据表的索引，设置为<code>True</code>则重置为新的索引。</li><li><code>join</code>：默认为<code>outer</code>，表示取并集，若设置为<code>inner</code>则取交集。</li><li><code>join_axes</code>：指定合并后采用的索引。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df1 = df = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df2 = df = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df3 = df = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">3</span>), columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pd.concat([df1, df2, df3], join=<span class="string">&#x27;inner&#x27;</span>, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>append</code>：用法类似于<code>concat</code>，但只能纵向合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.append(df3, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>merge</code>：与<code>concat</code>的主要区别在于用<code>on</code>参数指定要连接的键。</p><ul><li><code>on</code>：指定要连接的一个或多个键，这个键在两张表中是一致的。</li><li><code>how</code>：连接的方法，可选<code>inner</code>（取交集，默认）、<code>outer</code>（取并集）、<code>left</code>（以左表为主）、<code>right</code>（以右表为主）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">pd.merge(left, right, on=<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>Pandas中，缺失值用<code>NaN</code>表示，当创建DataFrame对象时，使用<code>np.nan</code>代表缺失值。</p><p>DataFrame对象使用<code>isnull</code>方法会返回一个布尔矩阵，显示每个位置是否是缺失值。可以灵活运用这一函数来定位缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df4 = pd.DataFrame([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,np.nan,np.nan],[<span class="number">4</span>,np.nan,np.nan],[<span class="number">5</span>,np.nan,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否是缺失值</span></span><br><span class="line">df4.isnull()</span><br><span class="line"><span class="comment"># 查看每列是否存在缺失值</span></span><br><span class="line">df4.isnull().<span class="built_in">any</span>()</span><br><span class="line"><span class="comment"># 只显示存在缺失值的行列，注意当一行存在n个缺失值时会重复输出该行n次</span></span><br><span class="line">df4[df4.isnull().values==<span class="literal">True</span>]</span><br><span class="line"><span class="comment"># 每列缺失值的总数</span></span><br><span class="line">df4.isnull().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 计算每列缺失值的比例，并从高到低输出</span></span><br><span class="line">(df4.isnull().<span class="built_in">sum</span>()/df4.isnull().count()).sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>Pandas提供了一些基础的处理缺失值的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接舍去含有缺失值的行</span></span><br><span class="line">df4.dropna(how=<span class="string">&#x27;any&#x27;</span>)</span><br><span class="line"><span class="comment"># 用常数填充缺失值</span></span><br><span class="line">df4.fillna(value=<span class="number">10.</span>)</span><br><span class="line"><span class="comment"># 用前一个非缺失值填充缺失值，默认axis=0按列填充</span></span><br><span class="line">df4.fillna(method=<span class="string">&#x27;ffill&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 用后一个非缺失值填充缺失值</span></span><br><span class="line">df4.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>Series和DataFrame对象都具有快速绘图的功能。它们用法与matplotlib类似，可以参考我的另一篇文章：<a href="http://ster.im/py_plt/">《Python机器学习库笔记（2）——matplotlib.pyplot》</a>，本文不再赘述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Series</span></span><br><span class="line">ts = pd.Series(np.random.randn(<span class="number">1000</span>), index=pd.date_range(<span class="string">&#x27;1/1/2016&#x27;</span>, periods=<span class="number">1000</span>))</span><br><span class="line">ts = ts.cumsum()</span><br><span class="line">ts.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment">#DataFrame</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>), index=ts.index, columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line">df = df.cumsum()</span><br><span class="line">plt.figure()</span><br><span class="line">df.plot()</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>Pandas支持读取csv、hdf5以及xlsx等类型的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取csv格式的文件</span></span><br><span class="line">pd.read_csv(<span class="string">&#x27;input.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 将DataFrame写入到csv格式文件</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;output.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 读取hdf5格式的文件</span></span><br><span class="line">pd.read_hdf(<span class="string">&#x27;input.h5&#x27;</span>, <span class="string">&#x27;df&#x27;</span>)</span><br><span class="line"><span class="comment"># 将DataFrame写入到hdf5格式文件</span></span><br><span class="line">df.to_hdf(<span class="string">&#x27;output.h5&#x27;</span>, <span class="string">&#x27;df&#x27;</span>)</span><br><span class="line"><span class="comment"># 读取excel文件</span></span><br><span class="line">pd.read_excel(<span class="string">&#x27;input.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>, index_col=<span class="literal">None</span>, na_values=[<span class="string">&#x27;NA&#x27;</span>])</span><br><span class="line"><span class="comment"># 将DataFrame写入到xlsx格式文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;output.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（2）——matplotlib.pyplot</title>
      <link href="/py_plt/"/>
      <url>/py_plt/</url>
      
        <content type="html"><![CDATA[<p>matplotlib是Python数据科学中常用的绘图工具库，我们常用到的是其中一个叫pyplot的子库，它能让我们作出像matlab中的图。掌握matplotlib.pyplot是机器学习项目中数据可视化的关键。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在IPython、Jupyter Notebook有用，可以省略plt.show()</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line"><span class="comment"># 最简单的作图</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 在Pycharm等IDE中显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h3><p>当不改变参数时，matplotlib作的图上的中文会变成方框，因此需要手动修改字体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span> <span class="comment"># 解决负号变方框的问题</span></span><br></pre></td></tr></table></figure><h3 id="图形实例"><a href="#图形实例" class="headerlink" title="图形实例"></a>图形实例</h3><p>通常先创建一个<code>figure()</code>实例，之后可以操作这个图形的名称、坐标轴、图例等。</p><p><code>figure()</code>可以接收多个参数，以下列出几个常用的参数：</p><ul><li><code>num</code>：指定画布的编号，如果使用pycharm等IDE，它也是画布窗口的名称。</li><li><code>figsize</code>：指定画布的大小。</li><li><code>dpi</code>：指定图形的分辨率。</li><li><code>facecolor</code>：指定画布的背景色。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(num=<span class="number">0</span>, figsize=(<span class="number">5</span>, <span class="number">5</span>), dpi=<span class="number">72</span>, facecolor=<span class="string">&#x27;k&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当调用<code>figure()</code>时，除了创建画布对象外，还会获得当前的绘图区域，之后进行的操作默认在当前绘图区域进行。如果<code>figure()</code>不传入任何参数，实际上是在<code>subplot(111)</code>上作图。</p><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p><code>plt.plot()</code>前两个参数接收X轴和Y轴的变量，此外还可以接受多个参数以改变图形主体的外观：</p><ul><li><code>color</code>（可简写为<code>c</code>）：指定曲线的颜色，可以用常用颜色的英文（或其首字母），也可以制定RGB值（如<code>#00FFFF</code>）。</li><li><code>marker</code>：指定数据点的类型，如<code>o</code>代表圆点，<code>s</code>代表方块，<code>x</code>代表叉号，等等。</li><li><code>linewidth</code>：指定曲线的宽度。</li><li><code>linestyle</code>：指定曲线的类型，如<code>-</code>代表实线，<code>--</code>代表虚线，<code>-.</code>代表点划线，等等。</li><li><code>alpha</code>：指定曲线的透明度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.sort(np.random.rand(<span class="number">100</span>))</span><br><span class="line">y = np.sort(np.random.rand(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, c=<span class="string">&#x27;r&#x27;</span>, linewidth=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>用于设定外观的的参数可以用简写，例如下面这个<code>&quot;bx--&quot;</code>参数相当于<code>color=&#39;b&#39;, marker=&#39;x&#39;, linestyle=&#39;--&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.plot(x, y, color=&#x27;b&#x27;, marker=&#x27;x&#x27;, linestyle=&#x27;--&#x27;)</span></span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;bx--&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>用<code>plt.scatter()</code>来绘制散点图，除了上述在折线图可用的参数外，散点图还有其他一些可选参数：</p><ul><li><code>s</code>：点的大小，可以设置为与数据数组大小相同的数组来指定每个点的大小。（同样，颜色也可以这样指定）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">50</span>)</span><br><span class="line">y = np.random.randn(<span class="number">50</span>)</span><br><span class="line">area = np.random.randint(<span class="number">10</span>, <span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, s=area)</span><br></pre></td></tr></table></figure><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p><code>plt.bar()</code>用于绘制柱状图，它还可以接受如下的参数：</p><ul><li><code>height</code>：用数组指定每个柱子的高度。</li><li><code>width</code>：指定柱子的宽度。</li><li><code>align</code>：设置对齐方式，默认是<code>center</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">5</span></span><br><span class="line">x = np.arange(n)</span><br><span class="line">y = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, n)</span><br><span class="line"></span><br><span class="line">plt.bar(x, y, width=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure><p>在一个坐标系中显示多组数据，可以用如下的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">5</span></span><br><span class="line">x = np.arange(n)</span><br><span class="line">y1 = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, n)</span><br><span class="line">y2 = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, n)</span><br><span class="line">y3 = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个柱子的宽度</span></span><br><span class="line">total_width = <span class="number">1</span> <span class="comment">#总长度包含每条柱子长度和一条空白长度</span></span><br><span class="line">width = total_width / <span class="number">4</span> <span class="comment"># y种类数量+1</span></span><br><span class="line"></span><br><span class="line">plt.bar(x - width, y1,  width=width, label=<span class="string">&#x27;y1&#x27;</span>)</span><br><span class="line">plt.bar(x, y2, width=width, label=<span class="string">&#x27;y2&#x27;</span>)</span><br><span class="line">plt.bar(x + width, y3, width=width, label=<span class="string">&#x27;y3&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h2><p><code>plt.boxplot()</code>可以用于绘制箱线图，它默认的构造方法已经足够使用。以下列出一些其他可能用到的参数：</p><ul><li><code>vert</code>：布尔型，指定图的方向，<code>True</code>为纵向，<code>False</code>为横向。</li><li><code>patch_artist</code>：布尔型，指定四分位框内是否填充，<code>True</code>为填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">100</span>).reshape(<span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.boxplot(x)</span><br></pre></td></tr></table></figure><h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><p><code>plt.pie()</code>用于绘制饼图，它可接收如下参数：</p><ul><li><code>explode</code>：当要把某一部分凸出时，将对应的值设为0.1就够。</li><li><code>labels</code>：对应每个部分的标签。</li><li><code>autopct</code>：显示百分比的格式。</li><li><code>shadow</code>：是否显示阴影。</li><li><code>startangle</code>：起始角度，从X轴起逆时针旋转的度数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>]</span><br><span class="line">explode = [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">labels = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.pie(x, explode=explode, labels=labels, autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, shadow=<span class="literal">False</span>, startangle=<span class="number">90</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>) <span class="comment"># 加上这句，饼图呈圆形，否则为椭圆</span></span><br></pre></td></tr></table></figure><h2 id="热图"><a href="#热图" class="headerlink" title="热图"></a>热图</h2><p><code>plt.imshow()</code>可以用于生成热图，分析变量间相关性时常用此图。<code>imshow()</code>主要接收如下参数：</p><ul><li><code>x</code>：即数据，可以是二维浮点型（灰度）、三维浮点型或unit8（RGB）或者四维浮点型或unit8（RGBA）数组。</li><li><code>cmap</code>：用于指定颜色图谱，默认为RGB(A)色彩空间，其余用的比较多的有<code>gray</code>、<code>jet</code>等。</li><li><code>interpolation</code>：插值方法，默认为<code>nearest</code>（不同版本可能有差异），用其他方法可以平滑色块边缘。</li></ul><p>通常还会定义一个<code>plt.colorbar()</code>用于标识颜色。</p><ul><li><code>shrink</code>：设置Bar的长度（比例）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.rand(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(x, cmap=plt.cm.summer, interpolation=<span class="string">&quot;bilinear&quot;</span>)</span><br><span class="line">plt.colorbar(shrink=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure><h2 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h2><p><code>plt.imshow()</code>也能够显示栅格图像，一个很常见的例子是用于显示MNIST的手写数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.rand(<span class="number">1024</span>).reshape(<span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(a, cmap=plt.cm.binary, interpolation=<span class="string">&quot;nearest&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Bedrock&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>) <span class="comment"># 关闭坐标轴</span></span><br></pre></td></tr></table></figure><h2 id="图形的其他元素"><a href="#图形的其他元素" class="headerlink" title="图形的其他元素"></a>图形的其他元素</h2><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><p>坐标轴可以手动设置范围、刻度等。以X轴为例：</p><ul><li><code>plt.xlim</code>：设置坐标轴的范围。</li><li><code>plt.xlabel</code>：设置坐标轴的名称。</li><li><code>plt.xticks</code>：设置坐标轴的刻度，可以接收一个数组，也可以接受一对数组及其对位的刻度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 坐标轴范围</span></span><br><span class="line">plt.xlim((-<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">plt.ylim((-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 坐标轴名称</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;X axis&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Y axis&quot;</span>)</span><br><span class="line"><span class="comment"># 坐标轴刻度</span></span><br><span class="line">plt.xticks(np.arange(-<span class="number">2.</span>, <span class="number">1.5</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.yticks([-<span class="number">2.5</span>, <span class="number">0.</span>, <span class="number">2.5</span>], [<span class="string">&quot;low&quot;</span>, <span class="string">&quot;mid&quot;</span>, <span class="string">&quot;high&quot;</span>])</span><br></pre></td></tr></table></figure><p>利用<code>plt.gca()</code>（Get Current Axis）可以对当前绘图区域的坐标轴进行更多操作，例如将两条坐标轴置于中间变成十字形。</p><ul><li><code>ax.set_title</code>：设置图表标题。</li><li><code>ax.set_xlabel</code>：设置坐标轴的名称。</li><li><code>ax.set_xticks</code>：设置坐标轴的刻度。</li><li><code>ax.set_xticklabels</code>：设置上面所设置刻度对应的标签。</li><li><code>ax.spines[&#39;left&#39;]</code>：一幅图共有四个坐标轴，分别用<code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code>表示。</li><li><code>ax.spines[&#39;left&#39;].set_color</code>：设置该轴颜色，将颜色设置为<code>none</code>可以隐藏该轴。</li><li><code>ax.spines[&#39;left&#39;].set_position</code>：设置坐标轴的位置，用<code>&#39;data&#39;</code>将坐标轴移动到第二个参数指定的数据处。如设置到坐标原点即<code>ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))</code>。</li><li><code>ax.xaxis.set_ticks_position</code>：设置刻度相对于坐标轴的位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">ax.set_title(<span class="string">&#x27;$sin(x)$&#x27;</span>, color=<span class="string">&#x27;k&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 隐藏上、右边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 将左、下轴移至中间</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.plot(x, y)</span><br></pre></td></tr></table></figure><h3 id="标题、图例、网格"><a href="#标题、图例、网格" class="headerlink" title="标题、图例、网格"></a>标题、图例、网格</h3><p>一幅完整的图还包括标题、图例。</p><p>标题可以通过<code>plt.title()</code>方法设置，同时可以传入参数设置标题的颜色、字体等。</p><p>图例可以通过<code>plt.legend()</code>方法显示，前提是创建图形时传入了<code>label</code>参数。还可以接收<code>loc</code>参数来指定图例的位置，一般指定为<code>best</code>即可，图例会被自动放在最合适的位置。</p><p>如果要显示网格，可以通过<code>plt.grid()</code>方法显示。通过传入<code>axis</code>参数可以指定显示<code>&#39;x&#39;</code>、<code>&#39;y&#39;</code>或者<code>&#39;both&#39;</code>方向上的网格线。网格线也可以使用<code>color</code>等参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span> - <span class="number">3</span>*x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.plot(x, y1, <span class="string">&quot;b-&quot;</span>, label=<span class="string">&#x27;line1&#x27;</span>)</span><br><span class="line">plt.plot(x, y2, <span class="string">&quot;r--&quot;</span>, label=<span class="string">&#x27;line2&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;Title&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示网格</span></span><br><span class="line">plt.grid(axis=<span class="string">&#x27;y&#x27;</span>, color=<span class="string">&#x27;grey&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h3><p>当需要特别标注出图上一个点时，先需要标出该点，过该点向坐标轴引一条垂线，再用箭头将其标注出来。matplotlib提供了<code>annotate()</code>的方法来让我们实现这一功能。</p><p><code>annotate()</code>第一个参数接收一组字符串作为显示的标注文字，其余部分参数如下：</p><ul><li><code>xy</code>：被标注的点坐标。</li><li><code>xytext</code>：标注文字的坐标。</li><li><code>arrowprops</code>：字典类型的参数，定义箭头的属性。</li><li><code>arrowstyle</code>：<code>arrowprops</code>的一个键，用于设置箭头的形状，如<code>&#39;-&gt;&#39;</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = x**<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xlim(-<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以(-3，10)这个点为例</span></span><br><span class="line">x0 = -<span class="number">3</span></span><br><span class="line">y0 = x0**<span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 标注该点</span></span><br><span class="line">plt.scatter(x0, y0, s=<span class="number">50</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"><span class="comment"># 向X轴引垂线</span></span><br><span class="line">plt.plot([x0, x0], [y0, <span class="number">0</span>], <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line"><span class="comment"># 向Y轴引垂线</span></span><br><span class="line">plt.plot([-<span class="number">5</span>, x0], [y0, y0], <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line"><span class="comment"># 用箭头引出该点</span></span><br><span class="line">plt.annotate(<span class="string">&quot;Here&quot;</span>, xy=(-<span class="number">3</span>, <span class="number">10</span>), xytext=(-<span class="number">2</span>, <span class="number">15</span>), arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;-&gt;&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="绘制子图"><a href="#绘制子图" class="headerlink" title="绘制子图"></a>绘制子图</h2><h3 id="subplot-用法"><a href="#subplot-用法" class="headerlink" title="subplot()用法"></a>subplot()用法</h3><p>pyplot提供了<code>subplot</code>这一方法来在一幅画布中绘制多个子图。<code>plt.subplot(m,n,k)</code>表示将画布分成m行n列，此图位于第k个位置（先从左往右、再从上往下数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y1 = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">y2 = np.tanh(x)</span><br><span class="line">y3 = np.maximum(<span class="number">0</span>, x)</span><br><span class="line">y4 = np.maximum(<span class="number">0.1</span>*x, x)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">ax1 = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">ax1.plot(x, y1, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2 = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax2.plot(x, y2, <span class="string">&#x27;g:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax3 = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">ax3.plot(x, y3, <span class="string">&#x27;b*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax4 = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">ax4.plot(x, y4, <span class="string">&#x27;y-.&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>plt.subplot(m,n,k)</code>的参数中的逗号可以省略。并且每幅子图并不一定要大小一致，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.title(<span class="string">&#x27;Sigmoid&#x27;</span>) <span class="comment"># 添加子图的标题</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">234</span>)</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line">plt.title(<span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.plot(x, y3)</span><br><span class="line">plt.title(<span class="string">&#x27;ReLu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.plot(x, y4)</span><br><span class="line">plt.title(<span class="string">&#x27;PReLu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">&#x27;Title&#x27;</span>) <span class="comment"># 添加总图的标题</span></span><br></pre></td></tr></table></figure><h3 id="subplots-用法"><a href="#subplots-用法" class="headerlink" title="subplots()用法"></a>subplots()用法</h3><p><code>plt.subplots()</code>是另一种创建子图的方法。返回的类型是元组，第一个是画布对象，第二个是子图的集合。</p><p>传入<code>sharex</code>和<code>sharey</code>参数可以决定子图的X轴、Y轴的范围是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">False</span>)</span><br><span class="line">ax[<span class="number">0</span>][<span class="number">0</span>].plot(x, y1)</span><br><span class="line">ax[<span class="number">0</span>][<span class="number">1</span>].plot(x, y2)</span><br><span class="line">ax[<span class="number">1</span>][<span class="number">0</span>].plot(x, y3)</span><br><span class="line">ax[<span class="number">1</span>][<span class="number">1</span>].plot(x, y4)</span><br></pre></td></tr></table></figure><h3 id="共享坐标轴"><a href="#共享坐标轴" class="headerlink" title="共享坐标轴"></a>共享坐标轴</h3><p>有时需要在一幅子图中展示两组数据，可以用<code>twinx()</code>或者<code>twiny()</code>的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span> - <span class="number">3</span>*x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = plt.subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">ax2 = ax1.twinx() <span class="comment"># 共享X轴</span></span><br><span class="line"></span><br><span class="line">ax1.plot(x, y1, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line">ax2.plot(x, y2, <span class="string">&#x27;b--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;TwinX axis&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;Y1 axis&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;Y2 axis&#x27;</span>, color=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习库笔记（1）——numpy</title>
      <link href="/py_np/"/>
      <url>/py_np/</url>
      
        <content type="html"><![CDATA[<p>numpy是Python的一个线性代数库，其核心是提供了<code>ndarray</code>这一数据类型代替了原生的<code>list</code>，可以进行高效的并行计算，是几乎所有机器学习包的依赖库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><p><code>ndarray</code>可以用于表示多维数组，与<code>list</code>不同的是，<code>ndarray</code>中的数据全是同一类型，这样大大提高了计算效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组对象并赋值</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将list类型转换为np.ndarray类型</span></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">a = np.array(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组的维数</span></span><br><span class="line">a.ndim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定位置的值或数组</span></span><br><span class="line">a[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组各个维度的长度</span></span><br><span class="line">a.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组变更为指定的维度</span></span><br><span class="line">a.reshape(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组中元素的个数</span></span><br><span class="line">a.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有元素求和</span></span><br><span class="line">a.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定的轴方向上求和</span></span><br><span class="line">a.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>ndarray</code>默认的数据类型是<code>np.float64</code>，即双精度。在大多数时候可以通过<code>dtype</code>参数来指定数组的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数组的数据类型</span></span><br><span class="line">a.dtype</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组中每个元素占用的字节，例如int32是4字节</span></span><br><span class="line">a.itemsize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改数组的数据类型</span></span><br><span class="line">a.astype(np.float64)</span><br></pre></td></tr></table></figure><h2 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h2><p>numpy提供多种方式快速构造数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个以0为起点，n为终点，步长为1的一维数组</span></span><br><span class="line">a = np.arange(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个以m为起点，n为终点，步长为1的一维数组</span></span><br><span class="line">a = np.arange(m, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个以m为起点，n为终点，步长为k的一维数组</span></span><br><span class="line">a = np.arange(m, n, k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在[m, n]范围内等间隔取k个数字构造一维数组</span></span><br><span class="line">a = np.linspace(m, n, k, dtype=np.int32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个指定维度的元素全为0的数组</span></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">4</span>), dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个指定维度的元素全为1的数组</span></span><br><span class="line">a = np.ones((<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个指定维度的单位矩阵</span></span><br><span class="line">a = np.eye(<span class="number">3</span>, dtype=np.int32)</span><br></pre></td></tr></table></figure><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>numpy.random提供多种方式生成随机数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置随机数种子，以便复现结果</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服从[0., 1.)均匀分布中随机生成指定维度的数组</span></span><br><span class="line">a = np.random.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从标准正态分布中随机生成指定维度的数组</span></span><br><span class="line">a = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服从[n, m)均匀分布中随机生成指定维度的整数数组</span></span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">100</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从[0., 1.)之间随机抽取一个浮点数</span></span><br><span class="line">a = np.random.random()</span><br></pre></td></tr></table></figure><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>在实际应用中，二维数组（即矩阵）的运算最为多见，因此以二维数组运算举例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">b = np.array([[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组相加</span></span><br><span class="line">a+b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组元素对位相乘（即点乘，要求两矩阵shape相等）</span></span><br><span class="line">a*b</span><br></pre></td></tr></table></figure><p>$$\begin{bmatrix} 1&amp;2&amp;3\4&amp;5&amp;6\7&amp;8&amp;9 \end{bmatrix} \cdot \begin{bmatrix} 9&amp;8&amp;7\6&amp;5&amp;4\3&amp;2&amp;1 \end{bmatrix}=\begin{bmatrix} 9&amp;16&amp;21\24&amp;25&amp;24\21&amp;16&amp;9 \end{bmatrix}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘法（即叉乘，要求左矩阵的列数等于右矩阵的行数）</span></span><br><span class="line">a.dot(b)</span><br><span class="line">np.dot(a,b)</span><br></pre></td></tr></table></figure><p>$$\begin{bmatrix} 1&amp;2&amp;3\4&amp;5&amp;6\7&amp;8&amp;9 \end{bmatrix} \times \begin{bmatrix} 9&amp;8&amp;7\6&amp;5&amp;4\3&amp;2&amp;1 \end{bmatrix}=\begin{bmatrix} 30&amp;24&amp;18\84&amp;69&amp;54\138&amp;114&amp;90 \end{bmatrix}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 过滤数组，返回布尔型的数组</span></span><br><span class="line">a&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到过滤后的数组</span></span><br><span class="line">a[a&gt;<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>numpy中的广播机制允许满足条件的两个shape不同的数组进行加、减、乘运算。</p><ol><li>若两个数组的维数不同，则在不足的数组的shape前补1。例如shape分别为(n,m)和(k,)的数组相加，则后者补为(1,k)。</li><li>两个数组的各个维度的长度要么相等，要么其中一个为1，则可进行运算，否则报错。</li><li>对长度为1的维度，复制这一行/列元素并使得shape与另一个数组相同，然后进行普通的运算。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])+<span class="number">3</span></span><br></pre></td></tr></table></figure><p>例如，([[1,2,3],[4,5,6]])与一个数3相加。3先被填充为shape(1,1)，再复制自身到所有行、列使自身shape等于(2,3)，即([[3,3,3],[3,3,3]])，那么就相当于([[1,2,3],[4,5,6]])与([[3,3,3],[3,3,3]])相加，结果为([[4,5,6],[7,8,9]])。</p><p>$$\begin{bmatrix} 1&amp;2&amp;3\4&amp;5&amp;6 \end{bmatrix}+3=\begin{bmatrix} 1&amp;2&amp;3\4&amp;5&amp;6 \end{bmatrix}+\begin{bmatrix} 3&amp;3&amp;3\3&amp;3&amp;3 \end{bmatrix}=\begin{bmatrix} 4&amp;5&amp;6\7&amp;8&amp;9 \end{bmatrix}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])+np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>同理，([[1],[2],[3]])和([4,5,6])相加，相当于([[1,1,1],[2,2,2],[3,3,3]])和([[4,5,6],[4,5,6],[4,5,6]])相加。</p><p>$$\begin{bmatrix} 1\2\3 \end{bmatrix}+\begin{bmatrix} 4&amp;5&amp;6 \end{bmatrix}=\begin{bmatrix} 1&amp;1&amp;1\2&amp;2&amp;2\3&amp;3&amp;3 \end{bmatrix}+\begin{bmatrix} 4&amp;5&amp;6\4&amp;5&amp;6\4&amp;5&amp;6 \end{bmatrix}=\begin{bmatrix} 5&amp;6&amp;7\6&amp;7&amp;8\7&amp;8&amp;9 \end{bmatrix}$$</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle机器学习实战（4）——MNIST（上）</title>
      <link href="/kaggle_04/"/>
      <url>/kaggle_04/</url>
      
        <content type="html"><![CDATA[<p>MNIST是非常经典的深度学习入门数据集。<a href="https://www.kaggle.com/c/digit-recognizer">Kaggle</a>上也为新手安排了这样一个练习。它是一个10分类任务，图像每幅图像是一个手写数字（0<del>9），其尺寸为28×28，每个像素为一个灰度值通道（0</del>255），因此每个图片包含784个维度。我们要做的就是预测测试集中图像所示的数字，评价的标准是准确度。</p><p>本文翻译自一篇<a href="https://www.kaggle.com/yassineghouzam/introduction-to-cnn-keras-0-997-top-6">kernel</a>，原作者运用Keras这一简易的深度学习工具来入门卷积神经网络。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten, Conv2D, MaxPool2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> ReduceLROnPlateau</span><br><span class="line"></span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;white&#x27;</span>, context=<span class="string">&#x27;notebook&#x27;</span>, palette=<span class="string">&#x27;deep&#x27;</span>)</span><br></pre></td></tr></table></figure><p>整理数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&quot;train.csv&quot;</span>)</span><br><span class="line">test = pd.read_csv(<span class="string">&quot;test.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">Y_train = train[<span class="string">&quot;label&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除“label”列</span></span><br><span class="line">X_train = train.drop(labels = [<span class="string">&quot;label&quot;</span>],axis = <span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放内存</span></span><br><span class="line"><span class="keyword">del</span> train </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示10个数字分布的柱状图</span></span><br><span class="line">g = sns.countplot(Y_train)</span><br><span class="line"></span><br><span class="line">Y_train.value_counts()</span><br></pre></td></tr></table></figure><p>10个数字的分布比较均匀。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查缺失值</span></span><br><span class="line">X_train.isnull().<span class="built_in">any</span>().describe()</span><br><span class="line"></span><br><span class="line">test.isnull().<span class="built_in">any</span>().describe()</span><br></pre></td></tr></table></figure><p>没有缺失值。</p><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">test = test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><h3 id="Reshape数据"><a href="#Reshape数据" class="headerlink" title="Reshape数据"></a>Reshape数据</h3><p>在当前的数据集中，每一行784个特征代表一张图像，每个图宽28个像素、高28个像素，每个像素1个通道（如果图片是彩色的，则需要3个通道），将其转换为三维的张量以便于后续处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把每一行数据转换为28*28*1</span></span><br><span class="line">X_train = X_train.values.reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br><span class="line">test = test.values.reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="标签编码"><a href="#标签编码" class="headerlink" title="标签编码"></a>标签编码</h3><p>原始数据集给出的标签是0~9十个数字，需要将其one-hot化。例如，”2”转化为[0,0,1,0,0,0,0,0,0,0]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把标签变为one-hot向量</span></span><br><span class="line">Y_train = to_categorical(Y_train, num_classes = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="分割训练集与验证集"><a href="#分割训练集与验证集" class="headerlink" title="分割训练集与验证集"></a>分割训练集与验证集</h3><p>将训练集分成两部分：一小部分（10%）作为评估模型的验证集，剩下的（90%）用于训练模型。从前面的探索性分析可以得知10个数字出现的频率较为均衡，随机分割训练集不会导致某些数字在验证集中过于频繁地出现。<strong>注意</strong>：在一些非平衡数据集中，简单的随机分割可能会导致不准确的评估。为了避免这种情况，可以在<code>train_test_split</code>中使用<code>stratify=True</code>选项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置随机种子（非必要）</span></span><br><span class="line">random_seed = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割训练集和验证集</span></span><br><span class="line">X_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size = <span class="number">0.1</span>, random_state=random_seed)</span><br></pre></td></tr></table></figure><p>这样就可以显示一张图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line">g = plt.imshow(X_train[<span class="number">0</span>][:,:,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h2 id="模型：卷积神经网络"><a href="#模型：卷积神经网络" class="headerlink" title="模型：卷积神经网络"></a>模型：卷积神经网络</h2><p>这次要利用Keras来从头到尾构建CNN。<br>Keras相对于Tensorflow、Theano等框架，最大的好处就是简单易懂，新手用几遍就很容易上手，而且有<a href="https://keras.io/zh/">中文版的文档</a>。缺点是无法理解深度模型背后的原理，也就是不懂如何“造轮子”。因此之后我会写一篇如何使用Tensorflow来复现LeNet5的博客。</p><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>原作者利用的是Keras的序贯模型（<code>Sequential</code>），通过<code>.add()</code>方法一个个的将layer加入模型中。</p><p>层的顺序是：[(CONV → Relu) × 2 → POOL → Dropout] × 2 → Flatten → Dense → Dropout → Softmax。</p><ol><li><code>Conv2D</code>（二维卷积层）：该层对二维输入进行滑动窗卷积。当使用该层作为第一层时，应提供<code>input_shape</code>参数，例如<code>input_shape = (28,28,1)</code>代表28×28的灰度图像。之后的层无需提供shape参数。<code>filters</code>输出空间的维度 （即卷积中滤波器的输出数量）。<code>kernel_size</code> 指明 2D 卷积窗口的宽度和高度。<code>strides</code>指明卷积沿宽度和高度方向的步长。<code>padding</code>指明是否填充输入数据以及填充的方法。</li><li><code>MaxPool2D</code>（最大池化层）：主要是在保留主要特征的同时减少参数，防止过拟合。<code>pool_size</code>为缩小比例的因数，例如通常情况下会使用<code>pool_size=(2,2)</code>，把输入张量的两个维度都缩小一半。<code>strides</code>是步长值， 如果是 <code>None</code>，那么默认值是<code>pool_size</code>。</li><li><code>Dropout</code>：是一种正则化方法，对于每个训练样本，随机抽取一定比例的节点将其值设为零。该方法可以提高模型泛化度，减少过拟合。主要参数为<code>rate</code>，取0~1，是需要drop掉的比例。</li><li><code>relu</code>：是一种常用的激活函数，返回max(x,0)。</li><li><code>Flatten</code>：用于将最终的feature map转换为一维向量，以传入全连接层。</li><li><code>Dense</code>（全连接层）：所实现的运算是<code>output = activation(dot(input, kernel)+bias)</code>。第一个参数<code>units</code>指定输出维度。<code>activation</code>指定激活函数。</li><li><code>Softmax</code>：作为输出层的激活函数，输出样本属于每个类的概率分布。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CNN序贯模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(filters = <span class="number">32</span>, kernel_size = (<span class="number">5</span>,<span class="number">5</span>),padding = <span class="string">&#x27;Same&#x27;</span>, </span><br><span class="line">                 activation =<span class="string">&#x27;relu&#x27;</span>, input_shape = (<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))</span><br><span class="line">model.add(Conv2D(filters = <span class="number">32</span>, kernel_size = (<span class="number">5</span>,<span class="number">5</span>),padding = <span class="string">&#x27;Same&#x27;</span>, </span><br><span class="line">                 activation =<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.add(Conv2D(filters = <span class="number">64</span>, kernel_size = (<span class="number">3</span>,<span class="number">3</span>),padding = <span class="string">&#x27;Same&#x27;</span>, </span><br><span class="line">                 activation =<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Conv2D(filters = <span class="number">64</span>, kernel_size = (<span class="number">3</span>,<span class="number">3</span>),padding = <span class="string">&#x27;Same&#x27;</span>, </span><br><span class="line">                 activation =<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">256</span>, activation = <span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation = <span class="string">&quot;softmax&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>定义完模型，还需要建立一个得分函数，一个损失函数和一个优化算法。</p><p><strong>损失函数</strong>用于度量模型在已知标签的图像集合上的表现。对于多分类任务，通常采用<code>categorical_crossentropy</code>，即多分类的对数损失函数。</p><p><strong>优化器（optimizer）</strong>的目的是最小化损失函数。大多数机器学习都是基于梯度的优化，选择优化器就是选择对于梯度下降算法的优化。常见的优化器包括SGD、Adam、Adagrad、RMSProp等几种，这里原作者选择了RMSprop（使用默认参数），它以一种非常简单的方式改进了Adagrad方法，可缓解Adagrad算法学习率下降较快的问题。</p><p><strong>得分函数</strong>用精度（正确的样本数/总样本数）来评估模型的性能。</p><p>用<code>compile</code>配置训练模型，前三个参数分别为<code>optimizer</code>（优化器），<code>loss</code>（损失函数）和<code>metrics</code>（得分函数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化方法</span></span><br><span class="line">optimizer = RMSprop(lr=<span class="number">0.001</span>, rho=<span class="number">0.9</span>, epsilon=<span class="number">1e-08</span>, decay=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer = optimizer , loss = <span class="string">&quot;categorical_crossentropy&quot;</span>, metrics=[<span class="string">&quot;accuracy&quot;</span>])</span><br></pre></td></tr></table></figure><p>为了使优化器收敛得更快，更接近损失函数的全局最小值，原作者使用了学习率退火方法，也就是一种学习率自适应方法。这样就能在保证模型训练速度时防止收敛到局部最优点。本例使用了<code>Keras.callbacks</code>的<code>ReduceLROnPlateau</code>函数，这个回调函数被设置为如果3个epoch后精度没有提高，那么学习率就会变为原来的一半。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学习率退火</span></span><br><span class="line">learning_rate_reduction = ReduceLROnPlateau(monitor=<span class="string">&#x27;val_acc&#x27;</span>, </span><br><span class="line">                                            patience=<span class="number">3</span>, </span><br><span class="line">                                            verbose=<span class="number">1</span>, </span><br><span class="line">                                            factor=<span class="number">0.5</span>, </span><br><span class="line">                                            min_lr=<span class="number">0.00001</span>)</span><br></pre></td></tr></table></figure><p>依据机器的性能设置迭代次数。原作者的epoch设置为30，准确率可达0.9967。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在完整训练集上的迭代次数</span></span><br><span class="line">epochs = <span class="number">1</span></span><br><span class="line">batch_size = <span class="number">86</span></span><br></pre></td></tr></table></figure><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>为了避免过拟合，需要用一些技巧扩展数据集。</p><p>以保持标签不变的方式改变训练数据的方法称为<strong>数据增强</strong>。常用的增强方法有裁剪、缩放、彩色变换、翻转等。在训练数据中应用数据增强方法可以轻松地将训练样本数量增加一倍或三倍，可以得到更加健壮的模型。例如本例，原作者在没有数据增强的情况下，准确率为98.114%；通过数据增强，准确率达到99.67%。</p><p>这里使用的方法包括：</p><ul><li>随机旋转训练图像，10度以内；</li><li>随机缩放训练图像，10%以内；</li><li>随机水平平移图像，宽度的10%以内；</li><li>随机垂直平移图像，高度的10%以内；</li><li>没有翻转图像，避免“6”和“9”的冲突。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据增强</span></span><br><span class="line">datagen = ImageDataGenerator(</span><br><span class="line">        featurewise_center=<span class="literal">False</span>,  <span class="comment"># 将输入数据的均值设置为0，逐特征进行</span></span><br><span class="line">        samplewise_center=<span class="literal">False</span>,  <span class="comment"># 将每个样本的均值设置为0</span></span><br><span class="line">        featurewise_std_normalization=<span class="literal">False</span>,  <span class="comment"># 将输入除以数据标准差，逐特征进行</span></span><br><span class="line">        samplewise_std_normalization=<span class="literal">False</span>,  <span class="comment"># 将每个输入除以其标准差</span></span><br><span class="line">        zca_whitening=<span class="literal">False</span>,  <span class="comment"># 是否应用ZCA白化</span></span><br><span class="line">        rotation_range=<span class="number">10</span>,  <span class="comment"># 随机旋转的度数范围</span></span><br><span class="line">        zoom_range = <span class="number">0.1</span>, <span class="comment"># 随机缩放范围</span></span><br><span class="line">        width_shift_range=<span class="number">0.1</span>,  <span class="comment"># 随机水平平移</span></span><br><span class="line">        height_shift_range=<span class="number">0.1</span>,  <span class="comment"># 随机垂直平移</span></span><br><span class="line">        horizontal_flip=<span class="literal">False</span>,  <span class="comment"># 随机水平翻转</span></span><br><span class="line">        vertical_flip=<span class="literal">False</span>)  <span class="comment"># 随机垂直翻转</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datagen.fit(X_train)</span><br></pre></td></tr></table></figure><p>训练模型。默认情况下用<code>fit</code>方法载入数据是一次性全部载入。此处使用<code>fit_generator</code>方法，用<code>yield</code>分批将训练集送入内存/显存，避免内存/显存不足的情况。</p><p><code>fit_generator</code>接收第一个参数<code>generator</code>为一个生成器，这里用了<code>ImageDataGenerator</code>类的<code>.flow()</code>方法，每次调用输出<code>batch_size</code>个样本及其对应的标签用于训练。<code>steps_per_epoch</code>为一个<code>epoch</code>分成多少个<code>batch_size</code>。<code>epochs</code>为数据的迭代总轮数。<code>verbose</code>为日志显示模式，可选0、1或2。<code>callbacks</code>为在训练时调用的一系列回调函数，例如学习率衰减方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),</span><br><span class="line">                              epochs = epochs, validation_data = (X_val,Y_val),</span><br><span class="line">                              verbose = <span class="number">2</span>, steps_per_epoch=X_train.shape[<span class="number">0</span>] // batch_size</span><br><span class="line">                              , callbacks=[learning_rate_reduction])</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Epoch 1/1 …… loss: 0.4215 - acc: 0.8656 - val_loss: 0.0649 - val_acc: 0.9781（epochs设置为1）</p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="训练集和验证集曲线"><a href="#训练集和验证集曲线" class="headerlink" title="训练集和验证集曲线"></a>训练集和验证集曲线</h3><p>绘制训练集和验证集上的loss函数以及精度曲线。设置<code>epochs=30</code>，模型在验证集上的精度接近99%，并且高于训练集上的精度，说明这个模型没有过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制训练集和验证集上的loss函数和精度曲线</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(history.history[<span class="string">&#x27;loss&#x27;</span>], color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&quot;Training loss&quot;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(history.history[<span class="string">&#x27;val_loss&#x27;</span>], color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&quot;validation loss&quot;</span>,axes =ax[<span class="number">0</span>])</span><br><span class="line">legend = ax[<span class="number">0</span>].legend(loc=<span class="string">&#x27;best&#x27;</span>, shadow=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>].plot(history.history[<span class="string">&#x27;acc&#x27;</span>], color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&quot;Training accuracy&quot;</span>)</span><br><span class="line">ax[<span class="number">1</span>].plot(history.history[<span class="string">&#x27;val_acc&#x27;</span>], color=<span class="string">&#x27;r&#x27;</span>,label=<span class="string">&quot;Validation accuracy&quot;</span>)</span><br><span class="line">legend = ax[<span class="number">1</span>].legend(loc=<span class="string">&#x27;best&#x27;</span>, shadow=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>混淆矩阵每一列代表预测的标签，每一行代表真正的标签。通过混淆矩阵可以直观看出哪些容易被错误分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制混淆矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span>(<span class="params">cm, classes,</span></span></span><br><span class="line"><span class="params"><span class="function">                          normalize=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                          title=<span class="string">&#x27;Confusion matrix&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                          cmap=plt.cm.Blues</span>):</span></span><br><span class="line">    plt.imshow(cm, interpolation=<span class="string">&#x27;nearest&#x27;</span>, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(<span class="built_in">len</span>(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=<span class="number">45</span>)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># normalize参数决定是否归一化，默认为否</span></span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        cm = cm.astype(<span class="string">&#x27;float&#x27;</span>) / cm.<span class="built_in">sum</span>(axis=<span class="number">1</span>)[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">    thresh = cm.<span class="built_in">max</span>() / <span class="number">2.</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(cm.shape[<span class="number">0</span>]), <span class="built_in">range</span>(cm.shape[<span class="number">1</span>])):</span><br><span class="line">        plt.text(j, i, cm[i, j],</span><br><span class="line">                 horizontalalignment=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">                 color=<span class="string">&quot;white&quot;</span> <span class="keyword">if</span> cm[i, j] &gt; thresh <span class="keyword">else</span> <span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;True label&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Predicted label&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证集上的预测</span></span><br><span class="line">Y_pred = model.predict(X_val)</span><br><span class="line"><span class="comment"># 将其转化为one-hot向量</span></span><br><span class="line">Y_pred_classes = np.argmax(Y_pred,axis = <span class="number">1</span>) </span><br><span class="line"><span class="comment"># 转化验证集的真实标签为one-hot向量</span></span><br><span class="line">Y_true = np.argmax(Y_val,axis = <span class="number">1</span>) </span><br><span class="line"><span class="comment"># 计算混淆矩阵</span></span><br><span class="line">confusion_mtx = confusion_matrix(Y_true, Y_pred_classes) </span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plot_confusion_matrix(confusion_mtx, classes = <span class="built_in">range</span>(<span class="number">10</span>)) </span><br></pre></td></tr></table></figure><p>如果按照原作者的参数设置（迭代30个epoch），误分类的情况已经相当少了。较为多见的误分类是把“4”识别为“9”。</p><p>进一步探索误分类样本种预测标签的概率与实际标签的概率分布的差值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预测标签与实际标签的概率差值</span></span><br><span class="line">errors = (Y_pred_classes - Y_true != <span class="number">0</span>)</span><br><span class="line">Y_pred_classes_errors = Y_pred_classes[errors]</span><br><span class="line">Y_pred_errors = Y_pred[errors]</span><br><span class="line">Y_true_errors = Y_true[errors]</span><br><span class="line">X_val_errors = X_val[errors]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_errors</span>(<span class="params">errors_index,img_errors,pred_errors, obs_errors</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 这个函数展示6幅图像及其预测标签和真实标签&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    nrows = <span class="number">2</span></span><br><span class="line">    ncols = <span class="number">3</span></span><br><span class="line">    fig, ax = plt.subplots(nrows,ncols,sharex=<span class="literal">True</span>,sharey=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(nrows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(ncols):</span><br><span class="line">            error = errors_index[n]</span><br><span class="line">            ax[row,col].imshow((img_errors[error]).reshape((<span class="number">28</span>,<span class="number">28</span>)))</span><br><span class="line">            ax[row,col].set_title(<span class="string">&quot;Predicted label :&#123;&#125;\nTrue label :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(pred_errors[error],obs_errors[error]))</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 误分类项的预测标签的预测概率</span></span><br><span class="line">Y_pred_errors_prob = np.<span class="built_in">max</span>(Y_pred_errors,axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 误分类项的真实标签的预测概率</span></span><br><span class="line">true_prob_errors = np.diagonal(np.take(Y_pred_errors, Y_true_errors, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者的差值</span></span><br><span class="line">delta_pred_true_errors = Y_pred_errors_prob - true_prob_errors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">sorted_dela_errors = np.argsort(delta_pred_true_errors)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Top6误差</span></span><br><span class="line">most_important_errors = sorted_dela_errors[-<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示Top6误差</span></span><br><span class="line">display_errors(most_important_errors, X_val_errors, Y_pred_classes_errors, Y_true_errors)</span><br></pre></td></tr></table></figure><p>通过展示一些误分类的图像，可以发现一些误分类可能并非模型的问题，例如非常像“4”的“9”可能属于人为标记时的错误。</p><p>到此，这个模型已经基本构建完成。接下来在测试集上运用模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在测试集上预测</span></span><br><span class="line">results = model.predict(test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取预测结果</span></span><br><span class="line">results = np.argmax(results,axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">results = pd.Series(results,name=<span class="string">&quot;Label&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MNIST是一个被“用烂了”的数据集，在深度学习领域相当于“Hello World”。但动手实现一遍还是会有不小的成就感。</li><li>Keras的序贯模型层次清晰，有助于新手理解卷积网络。如果能用它从头到尾实现一遍CNN，就恭喜你成为了“调参侠”。</li><li>本例用了一些CNN中常见（甚至说必见）的小Trick，比如数据增强、学习率衰减等，没有用到什么奇技淫巧，回归数据竞赛的本真。</li><li>对于新手而言，不必过于纠结网络结构。不如尝试复现一些经典网络，例如LeNet、AlexNet等，加深对深度网络的理解。之后可以尝试Inception，ResNet等当下热门的网络，处理真正的图片。当然，首先需要一台配备高档显卡的电脑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习笔记（4）——序列模型</title>
      <link href="/ng_04/"/>
      <url>/ng_04/</url>
      
        <content type="html"><![CDATA[<h2 id="循环序列模型"><a href="#循环序列模型" class="headerlink" title="循环序列模型"></a>循环序列模型</h2><h3 id="序列模型应用场景"><a href="#序列模型应用场景" class="headerlink" title="序列模型应用场景"></a>序列模型应用场景</h3><ul><li>声音转文字</li><li>音乐生成</li><li>自然语言情感分析</li><li>DNA序列分析</li><li>机器翻译</li><li>视频行为识别</li><li>人名识别</li></ul><h3 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h3><ul><li>在NLP中，用$T_X^{(i)}$表示第$i$个训练样本的输入序列长度，$T_y^{(i)}$表示第$i$个训练样本的输出序列长度</li><li>在词典中，遍历训练样本上的词汇，将样本中出现的词标注为1，其余为0</li></ul><h3 id="循环神经网络模型"><a href="#循环神经网络模型" class="headerlink" title="循环神经网络模型"></a>循环神经网络模型</h3><p>$$a^{&lt;0&gt;}=\vec{0}$$<br>$$a^{<t>}=g(W_{aa}a^{<t-1>}+W_{ax}X^{<t>}+b_a)$$<br>$$\hat{y}^{<t>}=g(W_{ya}a^{<t>}+b_y)$$</p><ul><li>为了简化计算，把上一次的激活值与这一次的输入合并为一个矩阵</li></ul><p>$$[W_{aa}\vdots W_{ax}]=W_a$$<br>$$a^{<t>}=g(W_a[a^{<t-1>},X^{<t>}]+b_a)$$</p><ul><li>循环神经网络的输出不仅取决于这一次的输入，也与上几次的输入有关</li><li>一般的循环神经网络在某一时刻的预测只取决于之前的信息，与之后的信息无关，双向循环神经网络（BRNN）则取决于之前与之后的信息</li><li>循环神经网络的激活函数通常选择<code>tanh</code>，有时也用<code>ReLU</code>，输出层一般是<code>sigmoid</code>或<code>softmax</code>函数</li></ul><h3 id="基于时间的反向传播"><a href="#基于时间的反向传播" class="headerlink" title="基于时间的反向传播"></a>基于时间的反向传播</h3><p>$$\mathcal{L}^{<t>}(\hat{y}^{<t>},y^{<t>})=-y^{<t>}\log\hat{y}^{<t>}-(1-y^{<t>})\log(1-\hat{y}^{<t>})$$<br>$$\mathcal{L}(\hat{y},y)=\sum^{T_y}_{t=1}\mathcal{L}^{<t>}(\hat{y}^{<t>},y^{<t>})$$</p><h3 id="不同类型的RNN"><a href="#不同类型的RNN" class="headerlink" title="不同类型的RNN"></a>不同类型的RNN</h3><ul><li>RNN经常用来处理$T_X^{(i)}\not=T_y^{(i)}$的情况</li><li>文本情感分析：输入一整句话，只在最后的时刻输出，称为多对一结构</li><li>音乐生成：输入一个向量（可以为零向量），每一时刻都有输出，并把输出输入到下一层，称为一对多结构</li><li>机器翻译：输入和输出的长度不同，称为多对多结构</li><li>其他：一对一结构、注意力结构</li></ul><h3 id="语言模型和序列生成"><a href="#语言模型和序列生成" class="headerlink" title="语言模型和序列生成"></a>语言模型和序列生成</h3><ul><li>包含大量单词的语料库（<code>corpus</code>）</li><li>某个词在词典中的位置为1，其余为0的向量：<code>1-hot</code>向量</li><li>增加句子结尾的标识符<code>&lt;EOS&gt;</code></li><li>对不存在字典中的词替换成<code>&lt;UNK&gt;</code>代表未知字符</li><li>对于每时刻的输入，模型通过softmax函数给出预测，下一层通过输入上一层的$a$以及真实的$y$，预测这一时刻的输出</li></ul><h3 id="从训练好的RNN中重采样"><a href="#从训练好的RNN中重采样" class="headerlink" title="从训练好的RNN中重采样"></a>从训练好的RNN中重采样</h3><ul><li>输入$a_0$和$X_1$，输出$\hat{y}_1$，将其作为下一个时刻的输入，直到最后输出<code>&lt;EOS&gt;</code>或达到设定长度为止</li><li>除了基于单词的词典外，也有基于字符的词典，其优点是不会输出<code>&lt;UNK&gt;</code>，缺点是难以捕捉长句的前文关系，且计算代价高昂</li></ul><h3 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h3><ul><li>基础的RNN模型不擅长捕获长期依赖效应（例如生成一个长句子很难记住单复数的形式），这与RNN模型梯度易消失有关</li></ul><h3 id="GRU单元"><a href="#GRU单元" class="headerlink" title="GRU单元"></a>GRU单元</h3><ul><li>门控循环单元：改善梯度消失问题</li><li>$c$称为记忆细胞，它具有记忆功能</li></ul><p>$$c^{<t>}=a^{<t>}$$<br>$$\tilde{c}^{<t>}=tanh(W_c[c^{<t-1>},X^{<t>}]+b_c)$$<br>$$\Gamma_u=\sigma(W_u[c^{<t-1>},X^{<t>}]+b_u)$$<br>$$c^{<t>}=\Gamma_u*\tilde{c}^{<t>}+(1-\Gamma_u)*c^{<t-1>}$$</p><ul><li>门$\Gamma_u$决定什么时候更新$c$的值，如果$\Gamma_u=1$则使用新值，如果$\Gamma_u=0$则使用旧值</li></ul><h3 id="长短时记忆（LSTM）"><a href="#长短时记忆（LSTM）" class="headerlink" title="长短时记忆（LSTM）"></a>长短时记忆（LSTM）</h3><ul><li>通常，LSTM比GRU更加强大和灵活</li></ul><p>$$\tilde{c}^{<t>}=tanh(W_c[a^{<t-1>},X^{<t>}]+b_c)$$<br>$$\Gamma_u=\sigma(W_u[a^{<t-1>},X^{<t>}]+b_u)\ \text{(update)}$$<br>$$\Gamma_f=\sigma(W_f[a^{<t-1>},X^{<t>}]+b_f)\ \text{(forget)}$$<br>$$\Gamma_o=\sigma(W_o[a^{<t-1>},X^{<t>}]+b_o)\ \text{(output)}$$<br>$$c^{<t>}=\Gamma_u<em>\tilde{c}^{<t>}+\Gamma_f</em>c^{<t-1>}$$<br>$$a^{<t>}=\Gamma_o*\tanh\ c^{<t>}$$</p><ul><li>偷窥孔连接（Peephole Connection）：门值不仅取决于上一个激活值和X，也取决于上一个记忆细胞的值</li></ul><h3 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h3><ul><li>增加反向连接层，前向传播一部分计算从左到右，另一部分从右到左，计算两部分的激活值</li></ul><p>$$\hat{y}^{<t>}=g(W_y[\overrightarrow{a^{<t>}},\overleftarrow{a^{<t>}}]+b_y)$$</p><ul><li>NLP问题首选LSTM+BRNN模型</li><li>缺点是需要完整的数据序列</li></ul><h3 id="深层RNN"><a href="#深层RNN" class="headerlink" title="深层RNN"></a>深层RNN</h3><ul><li>通常，循环神经网络只有一个隐藏层，当使用两个以上隐藏层时得到深度循环神经网络</li></ul><h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><h3 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h3><ul><li>词汇表与<code>1-hot</code>向量：任何词向量的内积都是0，因此对相关词的泛化性能不强</li><li>使用词的高维特征表示（词嵌入），能够得到更好的泛化性能</li><li><code>t-SNE</code>算法能将词的高维特征可视化到二维空间里</li></ul><h3 id="将词嵌入运用到NLP中"><a href="#将词嵌入运用到NLP中" class="headerlink" title="将词嵌入运用到NLP中"></a>将词嵌入运用到NLP中</h3><ul><li>词嵌入算法会考察非常大的文本量（或者来自互联网上的预先训练好的模型），迁移学习到只有少量标记的训练集中，并可以利用新数据微调词嵌入模型</li></ul><h3 id="词嵌入的特性"><a href="#词嵌入的特性" class="headerlink" title="词嵌入的特性"></a>词嵌入的特性</h3><ul><li>类比：将具有相关性的词的向量相减，得到两者之间的特征向量，可用于类比到具有相似性质的词上，例如，要从“man”以及“woman”之间的关系求“King”相对应的词(期望是“Queen”)，只要求</li></ul><p>$$e_{man}-e_{woman}\approx e_{king}-e_w$$<br>$$\text{Find word w}:\arg\max \ sim(e_w,e_{king}-e_{man}+e_{women})$$</p><ul><li>其中利用向量间的余弦相似度</li></ul><p>$$sim(u,v)=\frac{u^Tv}{||u||_2||v||_2}$$</p><h3 id="词嵌入矩阵"><a href="#词嵌入矩阵" class="headerlink" title="词嵌入矩阵"></a>词嵌入矩阵</h3><ul><li>例如，有一个词典$E$，具有10000个词汇和300维特征，它是$300\times10000$维的矩阵；其中第6257位的单词“Orange”的<code>1-hot</code>向量为10000维向量，相乘得到“Orange”的嵌入向量</li></ul><p>$$E\cdot o_{6257}=e_{6257}$$</p><ul><li>在实际中利用矩阵乘法获取嵌入向量效率低下，因此直接获取词典矩阵的某一列元素</li></ul><h3 id="学习词嵌入"><a href="#学习词嵌入" class="headerlink" title="学习词嵌入"></a>学习词嵌入</h3><ul><li>预测一句话的最后一个单词，可将这句话前面的所有单词（或者固定长度的历史窗口）的向量输入一个神经网络，经过softmax函数输出预测的单词</li><li>其他方法包括将所需预测单词的左边n个和右边n个单词输入神经网络；或只取所需预测单词的左边1个单词；或取最邻近的某个单词，称为<code>skip-gram</code>模型</li></ul><h3 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h3><ul><li><code>skip-gram</code>：抽取上下文的目标词配对，构造监督学习问题</li><li>输入一个词的<code>1-hot</code>向量，与词嵌入矩阵相乘得到嵌入向量，输入进softmax函数，预测这个词前后是什么词的概率</li><li>例如在10000维的词典中，得到某单词的嵌入向量$e_c$，输入softmax函数，输出预测$\hat{y}$</li></ul><p>$$P(t|c)=\frac{e^{\theta_t^Te_c}}{\sum^{10000}<em>{j=1}e^{\theta_j^Te_c}}$$<br>$$\mathcal{L}(\hat{y},y)=-\sum^{10000}</em>{i=1}y_i\log \hat{y}_i$$</p><ul><li>$\theta_t$是与$t$有关的参数，是$t$与标签相符的概率</li><li>由于过大的词典会导致计算代价高昂，故常采用树状二分类器</li><li><code>CBOW</code>：获得中间词两边的上下文，利用周围的词预测中间词</li></ul><h3 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h3><ul><li>在一句话中抽取一个上下文词和目标词作为一对正样本，利用相同的上下文词在词典中抽取k个词作为负样本，即便这个词出现在目标词上下文中</li><li>学习算法输入一对词，输出它们是否配对的预测</li><li>对于小数据集，k选取5～20</li><li>对于大数据集，k选取2～5</li><li>将1个正样本和k个负样本输入softmax函数</li></ul><p>$$P(y=1|c,t)=\sigma(\theta_t^Te_c)$$</p><ul><li>相比<code>skip-gram</code>，只需更新k+1个logistic单元</li><li>负采样的抽样方法：根据经验，按照英文单词分布的抽样方法</li></ul><p>$$P(W_i)=\frac{f(W_i)^{\frac{3}{4}}}{\sum^{10000}_{j=1}f(W_j)^{\frac{3}{4}}}$$</p><h3 id="GloVe词向量"><a href="#GloVe词向量" class="headerlink" title="GloVe词向量"></a>GloVe词向量</h3><ul><li>记$X_{ij}$是单词i在单词j上下文中出现的次数</li></ul><p>$$\text{minimize} \sum^{10000}<em>{i=1}\sum^{10000}</em>{j=1}f(X_{ij})(\theta^T_ie_j+b_i+b_j’-\log X_{ij})^2$$</p><h3 id="情绪分类"><a href="#情绪分类" class="headerlink" title="情绪分类"></a>情绪分类</h3><ul><li>从一句话的单词中提取嵌入向量，用求和或平均的方法得到特征向量，输入softmax函数，预测评分</li><li>缺点：没有考虑词序对情绪分类的影响</li><li>使用多对一的RNN结构，在最后时刻输出对整句话的评分</li></ul><h3 id="词嵌入除偏"><a href="#词嵌入除偏" class="headerlink" title="词嵌入除偏"></a>词嵌入除偏</h3><ul><li>使用机器学习进行决策的一个优点在于避免了人为的主观偏见，而词嵌入模型往往会出现性别歧视、种族歧视、年龄歧视等不期望出现的偏见，因此要修改学习算法尽量避免这些偏见</li><li>辨别出想要消除特定偏见的趋势，例如求出“he”和“she”以及“male”和“female”的嵌入向量之差，求平均得到性别偏见的方向向量</li><li>中和步（<code>Neutralizer</code>）：对于定义不明确的单词，例如“doctor”和“babysitter”，减少它们在存在偏见的方向上的距离</li><li>均衡步（<code>Equalize pairs</code>）：利用线性代数的方法让存在明显性别区别的一对词同某个不存在性别偏见的词的距离相接近</li></ul><h2 id="序列模型和注意力机制"><a href="#序列模型和注意力机制" class="headerlink" title="序列模型和注意力机制"></a>序列模型和注意力机制</h2><h3 id="Seq2Seq模型"><a href="#Seq2Seq模型" class="headerlink" title="Seq2Seq模型"></a>Seq2Seq模型</h3><ul><li>机器翻译：多对多结构</li><li>图片转文字：用循环网络替换深度卷积网络的softmax层</li></ul><h3 id="语言模型与机器翻译"><a href="#语言模型与机器翻译" class="headerlink" title="语言模型与机器翻译"></a>语言模型与机器翻译</h3><ul><li>语言模型：输入一个零向量，用上一时刻的输出作为这一时刻的输入</li><li>机器翻译（条件语言模型）：后半部分（Decoder）类似于语言模型，区别在于输入是一个句子构成Encoder</li><li>贪心搜索：每个时刻都取概率最大的输出值</li></ul><p>$$\arg\max_{y^{&lt;1&gt;},\cdots,y^{<Ty>}}P(y^{&lt;1&gt;},\cdots,y^{<Ty>}|x)$$</p><h3 id="集束搜索"><a href="#集束搜索" class="headerlink" title="集束搜索"></a>集束搜索</h3><ul><li>集束宽度（<code>Beam Width</code>）：集束搜索考虑的结果个数</li><li>集束宽度大，结果越好，计算越慢</li><li>集束搜索在每一时刻的输入都保留集束宽度个结果，结果通常比贪心搜索效果好</li><li>第一步输入Encoder的结果，输出词典中每个词的概率，取前集束宽度个结果保存，并作为下一时刻的输入</li><li>第二步将上一时刻的多个输出作为输入，计算组合概率</li></ul><p>$$P(y^{&lt;1&gt;},y^{&lt;2&gt;}|x)=P(y^{&lt;1&gt;}|x)P(y^{&lt;2&gt;}|x,y^{&lt;1&gt;})$$</p><h3 id="长度归一化"><a href="#长度归一化" class="headerlink" title="长度归一化"></a>长度归一化</h3><ul><li>集束搜索的目标是最大化条件概率</li></ul><p>$$\arg\max_y\prod^{T_y}_{t=1}P(y^{<t>}|x,y^{&lt;1&gt;},\cdots,y^{<t-1>})$$</p><ul><li>为了防止结果超出浮点精度，通常取对数</li></ul><p>$$\arg\max_y\sum^{T_y}_{t=1}\log P(y^{<t>}|x,y^{&lt;1&gt;},\cdots,y^{<t-1>})$$</p><ul><li>它会导致输出偏向较短的句子，因此采用归一化方法</li></ul><p>$$\frac{1}{T_y^\alpha}\sum_{t=1}^{T_y}\log P(y^{<t>}|x,y^{&lt;1&gt;},\cdots,y^{<t-1>})$$</p><ul><li>通常取$\alpha=0.7$</li></ul><h3 id="集束搜索误差分析"><a href="#集束搜索误差分析" class="headerlink" title="集束搜索误差分析"></a>集束搜索误差分析</h3><ul><li>误差来源有RNN和集束搜索</li><li>设人工翻译的预测为$y^*$，机器翻译的预测为$\hat{y}$</li><li>若$P(y^*|x)&gt;P(\hat{y}|x)$：集束搜索出现问题</li><li>若$P(y^*|x)\leq P(\hat{y}|x)$：RNN出现问题</li><li>对多个样本进行分析，从而判断主因</li></ul><h3 id="Bleu得分"><a href="#Bleu得分" class="headerlink" title="Bleu得分"></a>Bleu得分</h3><ul><li>Bleu得分能自动评价机器翻译的好坏</li><li>Bleu的原理是观察机器翻译的结果是否在人工翻译中至少出现一次</li><li>改良后的精度评估：分母为某个单词在机器翻译中出现的次数，分子为该单词在人工翻译样本中出现次数的最大值</li><li>以上扩展至n元词组，将从1至n的Bleu得分平均，并引入BP（简短惩罚）以惩罚太短的翻译结果，得到联合Bleu得分</li></ul><p>$$BP=\begin{cases}1\ \text{if MT output length&gt;reference output length}\\exp(1-\frac{\text{MT output length}}{\text{reference output length}})\ \text{otherwise}\end{cases}$$</p><h3 id="注意力模型"><a href="#注意力模型" class="headerlink" title="注意力模型"></a>注意力模型</h3><ul><li>机器翻译通常在短句子上Bleu得分较高，在长句子上得分较低</li><li>注意力模型使用注意力参数$\alpha^{&lt;t,t’&gt;}$来表示生成单词$t$时应该放多少注意力在单词$t’$上</li></ul><p>$$\sum_{t’}\alpha^{&lt;t,t’&gt;}=1$$</p><ul><li>将X输入双向RNN中，得到前向和后向激活值，激活值乘以注意力参数得到上下文关系，输入到隐藏层S中</li></ul><p>$$c^{<t>}=\sum_{t’}\alpha^{&lt;t,t’&gt;}a^{&lt;t’&gt;}$$</p><ul><li>把上一个S层的输出以及激活值输入到softmax函数，输出$e^{&lt;t,t’&gt;}$，并计算注意力参数$\alpha$</li></ul><p>$$\alpha^{&lt;t,t’&gt;}=\frac{\exp(e^{&lt;t,t’&gt;})}{\sum^{T_x}_{t’=1}\exp(e^{&lt;t,t’&gt;})}$$</p><h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><ul><li>注意力模型的语音识别</li><li>CTC损失函数语音识别：通过输出重复字符和空白符以使得输出维度等于输入维度，通过把空白符分隔开的重复字符折叠起来，得到较短的句子</li></ul><h3 id="触发字检测"><a href="#触发字检测" class="headerlink" title="触发字检测"></a>触发字检测</h3><ul><li>例如，Google Home（Okay Google），Apple Siri（Hey Siri）</li><li>平时的标签为0，当检测到关键字时，标签为1</li><li>为了适当提高标签为1的比例，并非只在一个时刻点标签1，而是一段时间内标签1</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Andrew Ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习笔记（3）——卷积神经网络</title>
      <link href="/ng_03/"/>
      <url>/ng_03/</url>
      
        <content type="html"><![CDATA[<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><ul><li>过滤器/卷积核（<code>Filter</code>）</li><li>从图像矩阵中选取与卷积核维度相同的子矩阵，与卷积核矩阵进行元素相乘</li><li>设输入一个$n\times n$的矩阵，经过$f\times f$的卷积核运算，输出一个$(n-f+1)\times (n-f+1)$维度的矩阵</li><li>例如，一幅$6\times6$的图像矩阵，经过$3\times3$的卷积核运算，变换为$4\times4$的矩阵</li><li>一种垂直边缘检测卷积核：</li></ul><p>$$\begin{bmatrix}1&amp;0&amp;-1 \ 1&amp;0&amp;-1 \ 1&amp;0&amp;-1 \end{bmatrix}$$</p><ul><li>一种水平边缘检测卷积核：</li></ul><p>$$\begin{bmatrix}1&amp;1&amp;1 \ 0&amp;0&amp;0 \ -1&amp;-1&amp;-1 \end{bmatrix}$$</p><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>卷积的缺点：经过多层之后，图片会变得很小；图像边缘大部分信息丢失</li><li><code>Padding</code>就是在图像周围填充像素点，以克服上述缺点</li><li>填充像素的多少采用<code>Valid</code>和<code>Same</code>两种方式确定</li><li><code>Same</code>是输入的图像和输出的图像维度相同，即</li></ul><p>$$n+2p-f+1=n,\ p=\frac{f-1}{2}$$</p><h3 id="卷积步长"><a href="#卷积步长" class="headerlink" title="卷积步长"></a>卷积步长</h3><ul><li>设步长为s，则输出矩阵的维度是$[\frac{n+2p-f}{s}+1]\times[\frac{n+2p-f}{s}+1]$</li></ul><h3 id="卷积的实现"><a href="#卷积的实现" class="headerlink" title="卷积的实现"></a>卷积的实现</h3><ul><li>图像和过滤器都有高、宽和通道数，且两者的通道数相等，输出是一个二维矩阵</li><li>如果应用了多种过滤器，将它们的输出组合成三维矩阵</li></ul><p>$$n\times n\times n_c * f\times f\times n_c\longrightarrow(n-f+1)\times(n-f+1)\times n’_c$$</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><ul><li>设第$l$层为卷积层</li><li>$f^{[l]}$为过滤器的维度</li><li>$p^{[l]}$为padding的大小</li><li>$s^{[l]}$为步长</li><li>$n_C^{[l]}$为过滤器的数量</li><li>$n_C^{[l-1]}$为通道数</li><li>每个过滤器大小为$f^{[l]}\times f^{[l]}\times n_C^{[l-1]}$</li><li>输入层是一个$n_H^{[l-1]}\times n_W^{[l-1]}\times n_C^{[l-1]}$的图像</li><li>输出层是一个$n_H^{[l]}\times n_W^{[l]}\times n_C^{[l]}$的图像，其中宽、高:</li></ul><p>$$n^{[l]}=[\frac{n^{[l-1]}+2p^{[l]}-f^{[l]}}{s^{[l]}}+1]$$</p><ul><li>激活的单元$a^{[l]}$为$n_H^{[l]}\times n_W^{[l]}\times n_C^{[l]}$</li><li>m个样本，$A^{[l]}$为$m\times n_H^{[l]}\times n_W^{[l]}\times n_C^{[l]}$</li><li>权重$W$为$f^{[l]}\times f^{[l]}\times n_C^{[l-1]}\times n_C^{[l]}$</li><li>偏差$b$为$1\times1\times1\times n_C^{[l]}$</li></ul><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><ul><li>最大池化：选择过滤器大小内的最大值输出</li><li>平均池化：选择过滤器大小内的平均值输出</li><li>超参数有过滤器大小<code>Filter Size</code>和步长<code>Stride</code>，通常都取2</li></ul><h3 id="构建卷积神经网络"><a href="#构建卷积神经网络" class="headerlink" title="构建卷积神经网络"></a>构建卷积神经网络</h3><ul><li>一个典型的卷积神经网络包含：卷积层<code>CONV</code>，池化层<code>POOL</code>，全连接层<code>FC</code></li><li>一般在统计网络层数时，只计算具有权重的层，因此把<code>CONV</code>和<code>POOL</code>算作一层</li><li>图片输入经过多层卷积后，平整化为一个一维向量，输入到下一层，这一层称为全连接层；全连接层后是softmax函数输出图像分类</li><li>随着层数的增加，图片的宽、高通常都会减小，通道数增加</li><li>一种常见的CNN模式：<code>CONV-&gt;POOL-&gt;CONV-&gt;POOL-&gt;FC-&gt;FC-&gt;FC-&gt;Softmax</code></li></ul><h3 id="为什么要使用卷积"><a href="#为什么要使用卷积" class="headerlink" title="为什么要使用卷积"></a>为什么要使用卷积</h3><ul><li>参数共享：图片的每个位置可以使用同一个过滤器提取特征</li><li>稀疏连接：每一层的输出值只取决于一小部分输入值</li></ul><h3 id="经典卷积网络"><a href="#经典卷积网络" class="headerlink" title="经典卷积网络"></a>经典卷积网络</h3><ul><li><code>LeNet-5</code>(Yann LeCun, 1994)：早期的CNN模型，可对手写数字进行识别</li><li><code>AlexNet</code>(Alex krizhevsky, 2012)：使用了<code>ReLU</code>激活函数、<code>Dropout</code>、局部响应归一层（<code>LRN</code>）</li><li><code>VGG-16</code>(VGG(Oxford), 2014)：全部使用$3\times3$的卷积核和$2\times2$的最大池化层，包含16个卷积层和全连接层</li><li><code>ResNet</code>(Microsoft, 2015)：增加了跳远连接，使用残差块可以训练更深（152层）的网络</li><li><code>Inception</code>(Google, 2014)：每个<code>Inception</code>模块包含和多个不同size的卷积层（也包含$1\times1$的卷积核）和一个<code>Same</code>的最大池化层，去除了全连接层</li><li>这些已经实现并开源的深度网络实例可以在github上下载</li></ul><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><ul><li>将他人开源的训练成果迁移到自己的训练模型上</li><li>使用他人训练的权重而不修改参数，称为<code>freeze</code>层，当自己的数据较少时，只训练softmax层，也可以获得很好的性能</li><li>自己的数据越多，<code>freeze</code>层越少，自己训练的层数越多</li><li>如果自己有大量数据，把开源的权重作为初始化并自己训练整个网络</li></ul><h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h3><ul><li>垂直镜像对称</li><li>随机裁剪</li><li>色彩转换</li></ul><h3 id="计算机视觉现状"><a href="#计算机视觉现状" class="headerlink" title="计算机视觉现状"></a>计算机视觉现状</h3><ul><li>用于基准训练和赢得比赛的常用技巧（通常对实际生产不实用）</li><li>集成：独立地训练几个神经网络，平均它们的输出</li><li><code>Multi-crop</code>：分类器在一个图像的多个分割上训练，平均它们的输出</li><li>使用已发表论文上的神经网络模型</li><li>使用开源的神经网络架构</li><li>使用他人预先训练的模型，在数据集上微调</li></ul><h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><h3 id="目标定位"><a href="#目标定位" class="headerlink" title="目标定位"></a>目标定位</h3><ul><li>标签$y$包含的信息包括：$P_c$表示是否检测到目标，$b_x$、$b_y$表示目标中心的坐标，$b_h$、$b_w$表示目标的高、宽，$C_1$、$C_2$、$C_3$表示目标的类别</li></ul><h3 id="特征点检测"><a href="#特征点检测" class="headerlink" title="特征点检测"></a>特征点检测</h3><ul><li>对于人脸，手工检测的特征点包含眼睛、嘴部、脸部等多个人工标注的特征点</li><li>对于人身体，手工检测的特征点包含胸部、肘部等多个人工标注的特征</li></ul><h3 id="目标检测算法"><a href="#目标检测算法" class="headerlink" title="目标检测算法"></a>目标检测算法</h3><ul><li>训练集是适当裁剪过的图像（例如：车占满一幅图片），标记为1（有目标）或0（无目标）</li><li>滑动窗口目标检测：用一个固定大小的窗口以某个特定的步幅遍历图像的每一个区域，然后将窗口扩大重复操作</li><li>在卷积网络里，实现滑动窗口要把全连接层变为卷积层，减少重复计算</li></ul><h3 id="Bounding-Box"><a href="#Bounding-Box" class="headerlink" title="Bounding Box"></a>Bounding Box</h3><ul><li>YOLO算法</li><li>把输入图像划分成$S\times S$的格子，每个格子包含$P_c$表示是否检测到目标，$b_x$、$b_y$表示目标中心的坐标，$b_h$、$b_w$表示目标的高、宽，$C_1$、$C_2$、$C_3$表示目标的类别，用在格子中的相对位置和长度表示目标的位置</li></ul><h3 id="交并比IoU"><a href="#交并比IoU" class="headerlink" title="交并比IoU"></a>交并比<code>IoU</code></h3><ul><li>监测区域相交的部分/合并的部分称为交并比</li></ul><h3 id="非最大值抑制"><a href="#非最大值抑制" class="headerlink" title="非最大值抑制"></a>非最大值抑制</h3><ul><li>将所有框的得分（$P_c$）排序，选中最高分及其对应的框</li><li>遍历其余的框，如果和当前最高分框的重叠面积<code>IoU</code>大于一定阈值，将框删除</li><li>从未处理的框中继续选一个得分最高的，重复上述过程</li></ul><h3 id="Anchor-Box"><a href="#Anchor-Box" class="headerlink" title="Anchor Box"></a>Anchor Box</h3><ul><li>用于检测多个目标</li><li>输出$y$的前8个参数和<code>AnchorBox1</code>关联，后面8个参数和<code>AnchorBox2</code>关联，看哪一个anchor box和实际边界框的交并比更高</li></ul><h3 id="YOLO算法的实现"><a href="#YOLO算法的实现" class="headerlink" title="YOLO算法的实现"></a>YOLO算法的实现</h3><ul><li>将图像分割为$n$个网格</li><li>输出$y$为$[n\times n\times anchorBox\times (5+classes)]$维向量</li><li>用非最大值抑制去除冗余的窗口</li><li>使用卷积层进行位置检测，全连接层进行目标识别，实现了端到端的学习</li></ul><h3 id="R-CNN算法"><a href="#R-CNN算法" class="headerlink" title="R-CNN算法"></a>R-CNN算法</h3><ul><li>首先对输入图像运行图像分割算法</li><li>在色块上创建窗口，并运行分类器</li><li>Fast R-CNN：使用卷积层实现了滑动窗口，比R-CNN速度加快</li><li>Faster R-CNN：使用卷积神经网络实现了滑动窗口，比R-CNN速度大大加快</li></ul><h2 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h2><h3 id="人脸验证vs人脸识别"><a href="#人脸验证vs人脸识别" class="headerlink" title="人脸验证vs人脸识别"></a>人脸验证vs人脸识别</h3><ul><li>人脸验证是1:1比对，精度可达99.9%</li><li>人脸识别是1:K比对，将人脸与数据库中的K个脸样本比对，返回人脸的ID</li></ul><h3 id="一次识别"><a href="#一次识别" class="headerlink" title="一次识别"></a>一次识别</h3><ul><li>在实际应用中，往往只有一张照片，训练样本太小以至于无法进行CNN训练</li><li>通常采用相似度进行比较，越相似的人脸，得分差值越小</li></ul><h3 id="Simaese算法"><a href="#Simaese算法" class="headerlink" title="Simaese算法"></a>Simaese算法</h3><ul><li>用一个卷积神经网络，把不同人脸图片输入，比较其输出的值的范数平方距离作为相似度</li></ul><h3 id="Triplet损失"><a href="#Triplet损失" class="headerlink" title="Triplet损失"></a>Triplet损失</h3><p>$$||f(A)-f(P)||^2-||f(A)-f(N)||^2+\alpha\le0$$</p><ul><li>$\alpha$是间隔参数，防止上式恒等于0</li></ul><p>$$L(A,P,N)=\max(||f(A)-f(P)||^2-||f(A)-f(N)||^2+\alpha,0)$$</p><ul><li>选择的样本尽量使得$d(A,P)\approx d(A,N)$，这样训练起来效率更高</li></ul><h3 id="面部验证与而分类"><a href="#面部验证与而分类" class="headerlink" title="面部验证与而分类"></a>面部验证与而分类</h3><ul><li>采用逻辑函数对<code>Simaese</code>判定是否是同一个人</li></ul><p>$$\hat{y}=\sigma(\sum^{128}_{k=1}W_i|f(x^{(i)})_k-f(x^{(j)})_k|+b)$$</p><h3 id="神经风格迁移"><a href="#神经风格迁移" class="headerlink" title="神经风格迁移"></a>神经风格迁移</h3><ul><li>代价函数</li></ul><p>$$J(G)=\alpha J_{content}(C,G)+\beta J_{style}(S,G)$$</p><ul><li>随机初始化$G$</li><li>使用梯度下降最小化代价函数$J(G)$</li><li>$J_{content}(C,G)$用隐藏层$l$计算代价函数，使用预先训练好的模型（如VGG），如果“内容图像”和“输出图像”两个激活值相似：</li></ul><p>$$J_{content}(C,G)=\frac{1}{2}||a^{<a href="C">l</a>}-a^{<a href="G">l</a>}||^2$$</p><ul><li>“风格图像”是一个$n_c^{[l]} \times n_c^{[l]}$矩阵</li></ul><p>$$G_{kk’}^{<a href="S">l</a>}=\sum^{n_H^{[l]}}<em>{i=1}\sum^{n_W^{[l]}}</em>{j=1}a_{ijk}^{<a href="S">l</a>}a_{ijk’}^{<a href="S">l</a>}$$<br>$$G_{kk’}^{<a href="G">l</a>}=\sum^{n_H^{[l]}}<em>{i=1}\sum^{n_W^{[l]}}</em>{j=1}a_{ijk}^{<a href="G">l</a>}a_{ijk’}^{<a href="G">l</a>}$$<br>$$J_{style}^{[l]}(S,G)=\frac{1}{(2n_H^{[l]}n_W^{[l]}n_C^{[l]})^2}\sum_k\sum_{k’}(G_{kk’}^{<a href="S">l</a>}-G_{kk’}^{<a href="G">l</a>})$$</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Andrew Ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习笔记（2）——结构化机器学习项目</title>
      <link href="/ng_02/"/>
      <url>/ng_02/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习策略"><a href="#机器学习策略" class="headerlink" title="机器学习策略"></a>机器学习策略</h2><h3 id="机器学习策略-1"><a href="#机器学习策略-1" class="headerlink" title="机器学习策略"></a>机器学习策略</h3><ul><li>收集更多数据</li><li>增加数据多样性</li><li>增加梯度下降迭代次数</li><li>尝试Adam优化算法</li><li>使用规模更大/更小的神经网络</li><li>使用<code>Dropout</code></li><li>添加$L_2$正则化</li><li>修改网络架构（激活函数、隐藏单元数目）</li></ul><h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><ul><li>在训练集上性能良好（更大型的神经网络/更好的优化算法）</li><li>在开发集上性能良好（增加正则项/更多的训练样本）</li><li>在测试集上性能良好（更大的开发集）</li><li>在实际情况上性能良好（调整样本的分布）</li></ul><h3 id="单实数评估指标"><a href="#单实数评估指标" class="headerlink" title="单实数评估指标"></a>单实数评估指标</h3><ul><li>查准率<code>Precision</code>：</li></ul><p>$$\frac{\text{True Positive}}{\text{True Positive} + \text{False Positive}}$$</p><ul><li>查全率<code>Recall</code>：</li></ul><p>$$\frac{\text{True Positive}}{\text{True Positive} + \text{True Negative}}$$</p><ul><li><code>F1-score</code>：</li></ul><p>$$\frac{2}{\frac{1}{\text{Precision}}+\frac{1}{\text{Recall}}}$$</p><h3 id="满足和优化指标"><a href="#满足和优化指标" class="headerlink" title="满足和优化指标"></a>满足和优化指标</h3><ul><li>选择最好的分类器时，准确度和运算时间都要考虑</li><li>准确度是优化目标，运算时间是满足指标</li></ul><h3 id="训练-开发-测试集划分"><a href="#训练-开发-测试集划分" class="headerlink" title="训练/开发/测试集划分"></a>训练/开发/测试集划分</h3><ul><li>确保开发和测试集来自同一分布</li><li>将所有数据打乱顺序，随机分配到开发集和测试集上</li></ul><h3 id="开发集和测试集的大小"><a href="#开发集和测试集的大小" class="headerlink" title="开发集和测试集的大小"></a>开发集和测试集的大小</h3><ul><li>传统的（小规模数据集）划分：训练集：测试集=70%：30%，或者训练集：开发集：测试集=60%:20%:20%</li><li>对于较大规模的数据集，训练集：开发集：测试集=98%:1%:1%</li><li>提升训练集样本数有助于提高模型的整体性能</li><li>测试集用于评估性能可以少于整体样本数的30%</li><li>为了评估不同的分类器，开发集需要足够大</li></ul><h3 id="改变开发集-测试集指标"><a href="#改变开发集-测试集指标" class="headerlink" title="改变开发集/测试集指标"></a>改变开发集/测试集指标</h3><ul><li>在计算误差时，对错误的分类加大权重</li><li>误差评估：</li></ul><p>$$Error=\frac{1}{m_{dev}}\sum^{m_{dev}}_{i=1}\mathcal{L}{(\hat{y}^{(i)}\not=y^{(i)})}$$</p><ul><li>修改错误分类的权重后：</li></ul><p>$$Error=\frac{1}{\sum w^{(i)}}\sum^{m_{dev}}_{i=1}w^{(i)}\mathcal{L}{(\hat{y}^{(i)}\not=y^{(i)})}$$</p><h3 id="机器学习算法达到人类水平表现"><a href="#机器学习算法达到人类水平表现" class="headerlink" title="机器学习算法达到人类水平表现"></a>机器学习算法达到人类水平表现</h3><ul><li>贝叶斯最优误差</li><li>评估机器算学习误差产生的原因</li><li>更好的分析方差和偏差</li></ul><h3 id="可减少的偏差"><a href="#可减少的偏差" class="headerlink" title="可减少的偏差"></a>可减少的偏差</h3><ul><li>用人类水平误差替代贝叶斯误差</li></ul><h3 id="人类水平误差"><a href="#人类水平误差" class="headerlink" title="人类水平误差"></a>人类水平误差</h3><ul><li>比较人类水平误差（贝叶斯误差）-训练集误差-开发集误差之间的差</li><li>训练集误差接近人类水平误差（贝叶斯误差），开发集误差较大：减少方差</li><li>训练集误差接近开发集误差，与人类水平误差（贝叶斯误差）差距较大：减少偏差</li></ul><h3 id="超过人类水平表现"><a href="#超过人类水平表现" class="headerlink" title="超过人类水平表现"></a>超过人类水平表现</h3><ul><li>结构化数据问题上，机器学习表现已经超过人类表现，例如：在线广告、产品推荐、物流预测、贷款申请情况预测</li><li>自然感知问题上，超越人类表现不容易</li></ul><h3 id="提高模型性能"><a href="#提高模型性能" class="headerlink" title="提高模型性能"></a>提高模型性能</h3><ul><li>训练集拟合程度较好，低偏差</li><li>开发集和测试集表现较好，低方差</li><li>训练误差和人类水平误差之间的差距是偏差的优化目标，可采取的方法包括：使用更大的模型、训练更久、使用更好的优化算法（Momentum、RMSprop、Adam）、更好的神经网络架构、改变超参数</li><li>开发误差和训练误差之间的差距是方差的优化目标，可采取的方法包括：收集更多数据、正则化（$L_2$，<code>Dropout</code>，数据增强）、更好的神经网络架构、改变超参数</li></ul><h3 id="进行误差分析"><a href="#进行误差分析" class="headerlink" title="进行误差分析"></a>进行误差分析</h3><ul><li>大多数深度学习模型对随机误差鲁棒性强，但对系统误差鲁棒性差</li><li>评估某一错误原因占全部错误的比重，决定是否要对该类误差做单独处理</li><li>如果因为标记错误导致了误差，除了训练集，开发集和测试集上的数据也要修改，保证它们依然来自同一分布</li><li>同时需要考察虽然标记错误但分类正确的样本</li></ul><h3 id="快速搭建模型"><a href="#快速搭建模型" class="headerlink" title="快速搭建模型"></a>快速搭建模型</h3><ul><li>快速建立第一个模型并进行迭代，利用方差和偏差评估模型的优化方向</li><li>在较为热门的领域，参考文献对训练自己的模型有较大的帮助</li></ul><h3 id="不同分布数据集的处理"><a href="#不同分布数据集的处理" class="headerlink" title="不同分布数据集的处理"></a>不同分布数据集的处理</h3><ul><li>方法1：把两组数组混合在一起。优点：训练集、开发集和测试集来自同一分布；缺点：开发集和测试集包含某一组数据的样本量太少，不是所需求的目标</li><li>方法2：50%投入训练集，其他分别投入开发集和测试集。优点：开发集和测试集包含所需要的优化目标；缺点：训练集、开发集和测试集并非来自同一分布</li></ul><h3 id="数据不匹配问题"><a href="#数据不匹配问题" class="headerlink" title="数据不匹配问题"></a>数据不匹配问题</h3><ul><li>训练-开发集</li><li>若训练集误差训练-开发集误差接近，开发集误差较大，则存在样本分布的问题</li><li>试图找到训练集和开发集/测试集样本之间的区别，使得训练样本的数据更接近于开发/测试样本或者获取更多相近似的样本</li><li>人工合成数据</li></ul><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><ul><li>如果想从任务A中迁移一些知识到任务B，若A和B属于同样的类型，A的数据比B的数据多得多，A低层次的特征可以帮助B的学习，迁移学习意义更大</li></ul><h3 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h3><ul><li>例如要判断图像中是否有4种物体，则输出结果$\hat{y}$为$4\times1$的向量</li></ul><p>$$Loss=\frac{1}{m}\sum^m_{i=1}\sum^4_{j=1}L(\hat{y}^{(i)}_j,y^{(i)}_j)$$</p><ul><li>同时处理多个任务比多次处理单个任务性能要好，同时可以应对只有部分标签的情况</li><li>适用于训练的多个目标具有相同的低层次特征</li><li>如果想要从多任务学习中提升特定任务的性能，要让其余任务训练样本数量之和远大于特定任务的训练样本</li><li>可以建立更大的神经网络模型来提高多任务学习的性能</li></ul><h3 id="端到端的深度学习"><a href="#端到端的深度学习" class="headerlink" title="端到端的深度学习"></a>端到端的深度学习</h3><ul><li>在深度神经网络中输入$X$，直接输出$\hat{y}$，而无需手工提取特征</li><li>庞大的训练数据集使得端到端深度学习性能良好</li><li>优点：避免人的主观意志，不需要花时间手工设计功能</li><li>缺点：依赖大量数据，排除了手工设计功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Andrew Ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习笔记（1）——超参数调试与优化</title>
      <link href="/ng_01/"/>
      <url>/ng_01/</url>
      
        <content type="html"><![CDATA[<h2 id="深度学习的实用层面"><a href="#深度学习的实用层面" class="headerlink" title="深度学习的实用层面"></a>深度学习的实用层面</h2><h3 id="训练集-开发集-测试集"><a href="#训练集-开发集-测试集" class="headerlink" title="训练集/开发集/测试集"></a>训练集/开发集/测试集</h3><ul><li>在机器学习中，通常是训练集：测试集=7:3或者训练集：开发集：测试集=6:2:2</li><li>在大数据时代，开发集和测试集的容量可以有所减小（对于超百万级别的数据，训练集可以占到99.5%）</li><li>确保开发集和测试集的数据与训练集来自同一分布</li></ul><h3 id="偏差和方差"><a href="#偏差和方差" class="headerlink" title="偏差和方差"></a>偏差和方差</h3><ul><li>高偏差：欠拟合（例如训练集误差15%，开发集误差16%）</li><li>高方差：过拟合（例如训练集误差1%，开发集误差11%）</li></ul><h3 id="训练神经网络的基本方法"><a href="#训练神经网络的基本方法" class="headerlink" title="训练神经网络的基本方法"></a>训练神经网络的基本方法</h3><ul><li>高偏差（训练集性能不佳）-&gt; 尝试规模更大的神经网络/花费更多时间训练算法/更先进的优化算法</li><li>高方差（开发集性能不佳）-&gt; 尝试获取更多的数据/正则化/其他神经网络模型</li></ul><h3 id="L-2-正则化"><a href="#L-2-正则化" class="headerlink" title="$L_2$正则化"></a>$L_2$正则化</h3><p>$$J(W,b)=\frac{1}{m}\sum^m_{i=1}\mathcal{L}(\hat{y}^{(i)},y^{(i)})+\frac{\lambda}{2m}||W||^2_2$$</p><ul><li>欧几里得范数：</li></ul><p>$$||W||<em>2^2=\sum</em>{j=1}^{n_x}W_j^2=W^TW$$</p><ul><li>弗罗贝尼乌斯范数（<code>Frobenius Norm</code>）：</li></ul><p>$$||W^{[l]}||^2_F=\sum^{n^{[l-1]}}<em>{i=1}\sum^{n^{[l]}}</em>{j=1}(W_{ij}^{[l]})^2$$</p><ul><li>正则化参数$\lambda$设置较大，权重矩阵接近于0，消除或者减少许多隐藏单元的影响，简化神经网络，从而减少过拟合</li></ul><h3 id="Dropout正则化"><a href="#Dropout正则化" class="headerlink" title="Dropout正则化"></a>Dropout正则化</h3><ul><li>反向随机失活：随机删除神经网络中的一些单元，简化神经网络，从而减少过拟合</li><li><code>Dropout</code>在计算机视觉中使用比较频繁</li></ul><h3 id="其他正则化方法"><a href="#其他正则化方法" class="headerlink" title="其他正则化方法"></a>其他正则化方法</h3><ul><li>通过翻转、随机剪裁图片、轻微变形等方法增大数据集</li><li><code>Early Stopping</code>：随着迭代次数的增加，训练集性能提升同时开发集性能下降，因此在迭代过程中提早停止训练网络</li></ul><h3 id="归一化输入"><a href="#归一化输入" class="headerlink" title="归一化输入"></a>归一化输入</h3><ul><li>零均值化</li><li>归一化方差</li></ul><h3 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h3><ul><li>深层网络反向传播对激活函数（例如<code>sigmoid</code>和<code>tanh</code>）求导，梯度更新以指数衰减或递增，造成梯度消失和梯度爆炸</li></ul><h3 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h3><ul><li>用于开发反向传播的求导是否正确</li><li>梯度检验不用于训练，只用于debug</li><li>梯度检验不能忽略正则项</li><li>梯度检验不能和<code>Dropout</code>混用</li><li>随机初始化时运用一次梯度检验，反复训练之后再次运用梯度检验</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="Mini-Batch梯度下降"><a href="#Mini-Batch梯度下降" class="headerlink" title="Mini-Batch梯度下降"></a>Mini-Batch梯度下降</h3><ul><li>把一个包含大量样本的训练集拆分成数个小样本（Mini-Batch）的训练集，从而提高训练的效率</li><li>当Mini-Batch的大小等于m时，称为Batch梯度下降，缺点是每次迭代的时间过长</li><li>当Mini-Batch的大小等于1时，称为随机梯度下降，缺点是失去向量化带来的算法加速，计算效率低下</li><li>视情况选择合适的Mini-Batch的大小</li><li>若训练集样本少于2000，直接使用Batch梯度下降</li><li>典型的Mini-Batch设置为64~512（常为2的次方）</li></ul><h3 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h3><p>$$v^t=\beta v^{t-1}+(1-\beta)\theta^t$$</p><h3 id="Momentum梯度下降"><a href="#Momentum梯度下降" class="headerlink" title="Momentum梯度下降"></a>Momentum梯度下降</h3><p>$$V_{dW} = \beta v_{dW} + (1-\beta)d_W$$<br>$$V_{db} = \beta v_{db} + (1-\beta)d_b$$<br>$$W = W - \alpha v_{dW}, b = b - \alpha v_{db}$$</p><ul><li>$\beta$一般取$0.9$</li></ul><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>$$S_{dW} = \beta S_{dW} + (1-\beta)dW^2$$<br>$$S_{db} = \beta S_{db} + (1-\beta)db^2$$<br>$$W = W - \alpha \frac{dW}{\sqrt{S_{dW}+\epsilon}}$$<br>$$b = b - \alpha \frac{db}{\sqrt{S_{db}+\epsilon}}$$</p><h3 id="Adam优化算法"><a href="#Adam优化算法" class="headerlink" title="Adam优化算法"></a>Adam优化算法</h3><ul><li>结合了Momentum和RMSprop再修正其偏差</li><li>Momentum</li></ul><p>$$V_{dW}=\beta_1V_{dW}+(1-\beta_1)dW$$<br>$$V_{db}=\beta_1V_{db}+(1-\beta_1)db$$</p><ul><li>RMSprop</li></ul><p>$$S_{dW}=\beta_2S_{dW}+(1-\beta_2)dW^2$$<br>$$S_{db}=\beta_2S_{db} + (1-\beta_2)db^2$$</p><ul><li>偏差修正</li></ul><p>$$V^{corrected}<em>{dW} = \frac{V</em>{dW}}{1-\beta_1^t}, V^{corrected}<em>{db} = \frac{V</em>{db}}{1-\beta_1^t}$$<br>$$S^{corrected}<em>{dW} = \frac{S</em>{dW}}{1-\beta_2^t}, S^{corrected}<em>{db} = \frac{S</em>{db}}{1-\beta_2^t}$$<br>$$W = W - \alpha \frac{V^{corrected}<em>{dW}}{\sqrt{S^{corrected}</em>{dW}}+\epsilon}$$<br>$$b = b - \alpha \frac{V^{corrected}<em>{db}}{\sqrt{S^{corrected}</em>{db}}+\epsilon}$$</p><ul><li>$\beta_1$一般取$0.9$，$\beta_2$一般取$0.999$，$\epsilon$一般取$10^{-8}$</li></ul><h3 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h3><ul><li>线性衰减：$\alpha = \frac{1}{1 + \text{decay-rate} * \text{epoch-num}} \alpha_0$</li><li>其他方法：指数衰减、平方根衰减、离散下降、手动衰减等</li></ul><h3 id="局部最优"><a href="#局部最优" class="headerlink" title="局部最优"></a>局部最优</h3><ul><li>高维空间中更有可能遇到鞍点而不是局部最优点</li></ul><h2 id="超参数调试、Batch正则化和程序框架"><a href="#超参数调试、Batch正则化和程序框架" class="headerlink" title="超参数调试、Batch正则化和程序框架"></a>超参数调试、Batch正则化和程序框架</h2><h3 id="调试处理"><a href="#调试处理" class="headerlink" title="调试处理"></a>调试处理</h3><ul><li>超参数：学习率$\alpha$， $\beta$（Mometum）， $\beta_1$ / $\beta_2$ / $\epsilon$（Adam），神经网络层数，隐含层的神经元数，学习率衰减率，mini-Batch的大小等</li><li>最重要的超参数：学习率$\alpha$</li><li>次重要：$\beta$（Mometum）、mini-Batch的大小、隐含层的神经元数</li><li>再次重要：网络层数、学习率衰减率</li><li>Adam的参数基本采用常用设置</li></ul><h3 id="为超参数选择合适的范围"><a href="#为超参数选择合适的范围" class="headerlink" title="为超参数选择合适的范围"></a>为超参数选择合适的范围</h3><ul><li>用对数标尺搜索超参数比随机均匀取值更合理</li><li>例如：$\alpha=10^r,r\in[-4,0]$</li></ul><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><ul><li>归一化也适用于隐含层的$z^{(1)}$~$z^{(m)}$</li></ul><p>$$\mu=\frac{1}{m}\sum_i{z^{(i)}}$$<br>$$\sigma^2=\frac{1}{m}\sum_i({z^{(i)}-\mu})^2$$<br>$$z_{norm}^{(i)}=\frac{z^{(i)}-\mu}{(\sqrt{\sigma^2+\epsilon}}$$<br>$$\tilde{z}^{(i)}=\gamma z_{norm}^{(i)}+\beta$$</p><ul><li>其中$\gamma$和$\beta$是模型的学习参数</li><li>BN减少了隐含层变量的分布变化数量，同时有轻微的正则化效果</li><li>通常用指数加权平均来调整每个mini-batch训练集中的$\mu$和$\sigma$</li></ul><h3 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h3><ul><li>Softmax将逻辑回归推广到C类，输出$X$属于各分类的概率</li><li>$t=e^{z^{[l]}}$，$z^{[l]}$是输出层的元素构成的向量</li></ul><p>$$a^{[l]}=\frac{e^{z^{[l]}}}{\sum_{j=1}^nt_i}$$<br>$$a^{[l]}<em>i=\frac{t_i}{\sum</em>{j=1}^n t_i}$$</p><h3 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h3><ul><li>Caffe/Caffe2</li><li>CNTK</li><li>DL4J</li><li>Keras</li><li>Lasagne</li><li>mxnet</li><li>PaddlePaddle</li><li>TensorFlow</li><li>Theano</li><li>Torch</li><li>选择框架的标准：易于编程；运行速度；持续开源</li></ul><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><ul><li>示例<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设代价函数是J = w**2 - 10*w + 25，w是我们要优化的变量</span></span><br><span class="line">w = tf.Variable(<span class="number">0</span>, dtype=tf.float32)</span><br><span class="line"><span class="comment"># cost = tf.add(tf.add(w**2, tf.mutiply(-10., w)), 25)</span></span><br><span class="line">cost = w**<span class="number">2</span> - <span class="number">10</span>*w + <span class="number">25</span></span><br><span class="line"><span class="comment"># 学习率0.01</span></span><br><span class="line">train = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cost)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出w初始化的值0.0</span></span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出一步梯度下降后w的值0.1</span></span><br><span class="line">session.run(train)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代1000次，w接近于最优值5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">session.run(train)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br></pre></td></tr></table></figure></li><li>placeholder()函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># placeholder()告诉tensorFlow稍后要为x输入变量</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">cost = x[<span class="number">0</span>][<span class="number">0</span>]*w**<span class="number">2</span> + x[<span class="number">1</span>][<span class="number">0</span>]*w + x[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">coefficients = np.array([[<span class="number">1.</span>], [-<span class="number">10.</span>], [<span class="number">25.</span>]])</span><br><span class="line"></span><br><span class="line">session.run(train, feed_dict=[x:coefficients])</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Andrew Ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle机器学习实战（3）——房价预测（下）</title>
      <link href="/kaggle_03/"/>
      <url>/kaggle_03/</url>
      
        <content type="html"><![CDATA[<p>这篇文章翻译自<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">kaggle房价预测</a>上点赞数第二的<a href="https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard">kernel</a>，该kernel涵盖了从数据预处理到最终建模的完整过程。</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">color = sns.color_palette()</span><br><span class="line">sns.set_style(<span class="string">&#x27;darkgrid&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm, skew</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">train = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>)</span><br><span class="line">test = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示训练数据的前五行</span></span><br><span class="line">train.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示测试数据的前五行</span></span><br><span class="line">test.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把“Id”这一列从数据集中单独挑出，便于操作</span></span><br><span class="line">train_ID = train[<span class="string">&#x27;Id&#x27;</span>]</span><br><span class="line">train.drop(<span class="string">&quot;Id&quot;</span>, axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br><span class="line">test_ID = test[<span class="string">&#x27;Id&#x27;</span>]</span><br><span class="line">test.drop(<span class="string">&quot;Id&quot;</span>, axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="离群值"><a href="#离群值" class="headerlink" title="离群值"></a>离群值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制面积与房价的散点图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.scatter(x = train[<span class="string">&#x27;GrLivArea&#x27;</span>], y = train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line">plt.ylabel(<span class="string">&#x27;SalePrice&#x27;</span>, fontsize=<span class="number">13</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;GrLivArea&#x27;</span>, fontsize=<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>从图中可以明显的看出：有两个具有巨大面积的房屋的房价显然过低，因此可以安全地删除它们。<strong>注意</strong>：虽然训练数据中还有其他的离群值可以删除，但无法保证测试数据集中也有离群值，若删除训练样本中的大量离群值会影响测试集上的精度。因此只删除了两个，以使模型更健壮。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除这两个离群值</span></span><br><span class="line">train = train.drop(train[(train[<span class="string">&#x27;GrLivArea&#x27;</span>]&gt;<span class="number">4000</span>) &amp; (train[<span class="string">&#x27;SalePrice&#x27;</span>]&lt;<span class="number">300000</span>)].index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重绘图以查看是否剔除离群值</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.scatter(x = train[<span class="string">&#x27;GrLivArea&#x27;</span>], y = train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line">plt.ylabel(<span class="string">&#x27;SalePrice&#x27;</span>, fontsize=<span class="number">13</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;GrLivArea&#x27;</span>, fontsize=<span class="number">13</span>)</span><br></pre></td></tr></table></figure><h3 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h3><p>Y——房价（<code>SalePrice</code>）是我们需要预测的目标变量。首先要查看它是否满足正态分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制Y的概率分布图</span></span><br><span class="line">sns.distplot(train[<span class="string">&#x27;SalePrice&#x27;</span>], fit=norm);</span><br><span class="line">plt.legend([<span class="string">&#x27;Normal dist&#x27;</span>], loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;SalePrice distribution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Y的正态分布参数</span></span><br><span class="line">(mu, sigma) = norm.fit(train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n mu = &#123;:.2f&#125; and sigma = &#123;:.2f&#125;\n&#x27;</span>.<span class="built_in">format</span>(mu, sigma))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制QQ-plot图</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(train[<span class="string">&#x27;SalePrice&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：mu = 12.02 and sigma = 0.40</p><p>可见目标变量Y呈现一种偏态分布，需要将其转换为正态分布以便运用线性回归模型。这里运用了<code>log1p</code>函数，返回的是$\log(1+x)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正态化Y</span></span><br><span class="line">train[<span class="string">&#x27;SalePrice&#x27;</span>] = np.log1p(train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制分布图检查新的分布</span></span><br><span class="line">sns.distplot(train[<span class="string">&#x27;SalePrice&#x27;</span>], fit=norm);</span><br><span class="line">plt.legend([<span class="string">&#x27;Normal dist&#x27;</span>], loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;SalePrice distribution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取新的正态分布参数</span></span><br><span class="line">(mu, sigma) = norm.fit(train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n mu = &#123;:.2f&#125; and sigma = &#123;:.2f&#125;\n&#x27;</span>.<span class="built_in">format</span>(mu, sigma))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制QQ-plot图</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(train[<span class="string">&#x27;SalePrice&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><h3 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用热图展示各个变量与Y的相关性</span></span><br><span class="line">corrmat = train.corr()</span><br><span class="line">plt.subplots(figsize=(<span class="number">12</span>,<span class="number">9</span>))</span><br><span class="line">sns.heatmap(corrmat, vmax=<span class="number">0.9</span>, square=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先把训练集和测试集合并起来并丢弃Y，以便处理缺失值</span></span><br><span class="line">ntrain = train.shape[<span class="number">0</span>] <span class="comment"># 训练集数目</span></span><br><span class="line">ntest = test.shape[<span class="number">0</span>] <span class="comment"># 测试集数目</span></span><br><span class="line">y_train = train.SalePrice.values <span class="comment"># 训练集的Y</span></span><br><span class="line">all_data = pd.concat((train, test)).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">all_data.drop([<span class="string">&#x27;SalePrice&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;all_data size is : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(all_data.shape))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：all_data size is : (2917, 79)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看缺失值情况</span></span><br><span class="line">all_data_na = (all_data.isnull().<span class="built_in">sum</span>() / <span class="built_in">len</span>(all_data)) * <span class="number">100</span></span><br><span class="line">all_data_na = all_data_na.drop(all_data_na[all_data_na == <span class="number">0</span>].index).sort_values(ascending=<span class="literal">False</span>)[:<span class="number">30</span>]</span><br><span class="line">missing_data = pd.DataFrame(&#123;<span class="string">&#x27;Missing Ratio&#x27;</span> :all_data_na&#125;)</span><br><span class="line">missing_data.head(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制缺失值的柱状图</span></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">15</span>,<span class="number">12</span>))</span><br><span class="line">plt.xticks(rotation=<span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">sns.barplot(x=all_data_na.index, y=all_data_na)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Features&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Percent of missing values&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Percent missing data by feature&#x27;</span>, fontsize=<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>参照<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">数据下载页</a>给出的各个变量的解释（data_description.txt），逐一补充缺失值。</p><ul><li><code>PoolQC</code>, <code>MiscFeature</code>, <code>Alley</code>, <code>Fence</code>, <code>FireplaceQu</code>：这些变量里的空值代表样本房屋不包含泳池、篱笆等设施，因此用<code>None</code>来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;PoolQC&quot;</span>] = all_data[<span class="string">&quot;PoolQC&quot;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;MiscFeature&quot;</span>] = all_data[<span class="string">&quot;MiscFeature&quot;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;Alley&quot;</span>] = all_data[<span class="string">&quot;Alley&quot;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;Fence&quot;</span>] = all_data[<span class="string">&quot;Fence&quot;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;FireplaceQu&quot;</span>] = all_data[<span class="string">&quot;FireplaceQu&quot;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>LotFrontage</code>：与街道相连的房产的面积，可以用同一个小区内其他样本该项的中位数来补全。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;LotFrontage&quot;</span>] = all_data.groupby(<span class="string">&quot;Neighborhood&quot;</span>)[<span class="string">&quot;LotFrontage&quot;</span>].transform(<span class="keyword">lambda</span> x: x.fillna(x.median()))</span><br></pre></td></tr></table></figure><ul><li><code>GarageType</code>, <code>GarageFinish</code>, <code>GarageQual</code>, <code>GarageCond</code>：车库系列变量1，为标称型，用<code>None</code>来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> (<span class="string">&#x27;GarageType&#x27;</span>, <span class="string">&#x27;GarageFinish&#x27;</span>, <span class="string">&#x27;GarageQual&#x27;</span>, <span class="string">&#x27;GarageCond&#x27;</span>):</span><br><span class="line">    all_data[col] = all_data[col].fillna(<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>GarageYrBlt</code>, <code>GarageArea</code>, <code>GarageCars</code>：车库系列变量2，为数值型，用0来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> (<span class="string">&#x27;GarageYrBlt&#x27;</span>, <span class="string">&#x27;GarageArea&#x27;</span>, <span class="string">&#x27;GarageCars&#x27;</span>):</span><br><span class="line">    all_data[col] = all_data[col].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>BsmtFinSF1</code>, <code>BsmtFinSF2</code>, <code>BsmtUnfSF</code>, <code>TotalBsmtSF</code>, <code>BsmtFullBath</code>, <code>BsmtHalfBath</code>：地下室系列变量1，为数值型，用0来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> (<span class="string">&#x27;BsmtFinSF1&#x27;</span>, <span class="string">&#x27;BsmtFinSF2&#x27;</span>, <span class="string">&#x27;BsmtUnfSF&#x27;</span>,<span class="string">&#x27;TotalBsmtSF&#x27;</span>, <span class="string">&#x27;BsmtFullBath&#x27;</span>, <span class="string">&#x27;BsmtHalfBath&#x27;</span>):</span><br><span class="line">    all_data[col] = all_data[col].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>BsmtQual</code>, <code>BsmtCond</code>, <code>BsmtExposure</code>, <code>BsmtFinType1</code>, <code>BsmtFinType2</code>：地下室系列变量2，为标称型，用<code>None</code>来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> (<span class="string">&#x27;BsmtQual&#x27;</span>, <span class="string">&#x27;BsmtCond&#x27;</span>, <span class="string">&#x27;BsmtExposure&#x27;</span>, <span class="string">&#x27;BsmtFinType1&#x27;</span>, <span class="string">&#x27;BsmtFinType2&#x27;</span>):</span><br><span class="line">    all_data[col] = all_data[col].fillna(<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>MasVnrArea</code>, <code>MasVnrType</code>：空值代表样本房屋不包含砖石贴面墙，因此分别用0和<code>None</code>来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;MasVnrType&quot;</span>] = all_data[<span class="string">&quot;MasVnrType&quot;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">all_data[<span class="string">&quot;MasVnrArea&quot;</span>] = all_data[<span class="string">&quot;MasVnrArea&quot;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>MSZoning</code>, <code>Electrical</code>, <code>KitchenQual</code>, <code>Exterior1st</code>, <code>Exterior2nd</code>, <code>SaleType</code>：因为这些变量中仅有个别缺失值，可采用众数填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&#x27;MSZoning&#x27;</span>] = all_data[<span class="string">&#x27;MSZoning&#x27;</span>].fillna(all_data[<span class="string">&#x27;MSZoning&#x27;</span>].mode()[<span class="number">0</span>])</span><br><span class="line">all_data[<span class="string">&#x27;Electrical&#x27;</span>] = all_data[<span class="string">&#x27;Electrical&#x27;</span>].fillna(all_data[<span class="string">&#x27;Electrical&#x27;</span>].mode()[<span class="number">0</span>])</span><br><span class="line">all_data[<span class="string">&#x27;KitchenQual&#x27;</span>] = all_data[<span class="string">&#x27;KitchenQual&#x27;</span>].fillna(all_data[<span class="string">&#x27;KitchenQual&#x27;</span>].mode()[<span class="number">0</span>])</span><br><span class="line">all_data[<span class="string">&#x27;Exterior1st&#x27;</span>] = all_data[<span class="string">&#x27;Exterior1st&#x27;</span>].fillna(all_data[<span class="string">&#x27;Exterior1st&#x27;</span>].mode()[<span class="number">0</span>])</span><br><span class="line">all_data[<span class="string">&#x27;Exterior2nd&#x27;</span>] = all_data[<span class="string">&#x27;Exterior2nd&#x27;</span>].fillna(all_data[<span class="string">&#x27;Exterior2nd&#x27;</span>].mode()[<span class="number">0</span>])</span><br><span class="line">all_data[<span class="string">&#x27;SaleType&#x27;</span>] = all_data[<span class="string">&#x27;SaleType&#x27;</span>].fillna(all_data[<span class="string">&#x27;SaleType&#x27;</span>].mode()[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li><code>Utilities</code>：这一项除了两个缺失值外只有训练集中有一个值是特例，也就是说这一个变量对预测没有任何影响，故删去。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data = all_data.drop([<span class="string">&#x27;Utilities&#x27;</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li><code>Functional</code>：数据说明中有提到，空值代表<code>Typ</code>（典型）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&quot;Functional&quot;</span>] = all_data[<span class="string">&quot;Functional&quot;</span>].fillna(<span class="string">&quot;Typ&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>MSSubClass</code>：缺失值可能意味着该样本的房屋没有建筑等级，用<code>None</code>来填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&#x27;MSSubClass&#x27;</span>] = all_data[<span class="string">&#x27;MSSubClass&#x27;</span>].fillna(<span class="string">&quot;None&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后再检查一遍是否还遗漏了未补全的缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再次检查缺失值</span></span><br><span class="line">all_data_na = (all_data.isnull().<span class="built_in">sum</span>() / <span class="built_in">len</span>(all_data)) * <span class="number">100</span></span><br><span class="line">all_data_na = all_data_na.drop(all_data_na[all_data_na == <span class="number">0</span>].index).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">missing_data = pd.DataFrame(&#123;<span class="string">&#x27;Missing Ratio&#x27;</span> :all_data_na&#125;)</span><br><span class="line">missing_data.head()</span><br></pre></td></tr></table></figure><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="数值型转换为标称型"><a href="#数值型转换为标称型" class="headerlink" title="数值型转换为标称型"></a>数值型转换为标称型</h3><p>诸如<code>MSSubClass</code>（住宅类型）、<code>OverallCond</code>（房屋总体质量）等变量，虽然它们的值是数字，但本质上属于标称型变量，需将其转化为字符串类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&#x27;MSSubClass&#x27;</span>] = all_data[<span class="string">&#x27;MSSubClass&#x27;</span>].apply(<span class="built_in">str</span>)</span><br><span class="line">all_data[<span class="string">&#x27;OverallCond&#x27;</span>] = all_data[<span class="string">&#x27;OverallCond&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">all_data[<span class="string">&#x27;YrSold&#x27;</span>] = all_data[<span class="string">&#x27;YrSold&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">all_data[<span class="string">&#x27;MoSold&#x27;</span>] = all_data[<span class="string">&#x27;MoSold&#x27;</span>].astype(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><h3 id="定序型转换为数值型"><a href="#定序型转换为数值型" class="headerlink" title="定序型转换为数值型"></a>定序型转换为数值型</h3><p>诸如<code>FireplaceQu</code>（壁炉质量）、<code>BsmtQual</code>（地下室高度）、<code>GarageQual</code>（车库质量）等变量，虽然它们是字符串类型的标称型变量，但其隐含了顺序的信息（如质量的好坏、功能的多少），需要对其进行Label Encoding，使其转化为有序的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">cols = (<span class="string">&#x27;FireplaceQu&#x27;</span>, <span class="string">&#x27;BsmtQual&#x27;</span>, <span class="string">&#x27;BsmtCond&#x27;</span>, <span class="string">&#x27;GarageQual&#x27;</span>, <span class="string">&#x27;GarageCond&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ExterQual&#x27;</span>, <span class="string">&#x27;ExterCond&#x27;</span>,<span class="string">&#x27;HeatingQC&#x27;</span>, <span class="string">&#x27;PoolQC&#x27;</span>, <span class="string">&#x27;KitchenQual&#x27;</span>, <span class="string">&#x27;BsmtFinType1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;BsmtFinType2&#x27;</span>, <span class="string">&#x27;Functional&#x27;</span>, <span class="string">&#x27;Fence&#x27;</span>, <span class="string">&#x27;BsmtExposure&#x27;</span>, <span class="string">&#x27;GarageFinish&#x27;</span>, <span class="string">&#x27;LandSlope&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;LotShape&#x27;</span>, <span class="string">&#x27;PavedDrive&#x27;</span>, <span class="string">&#x27;Street&#x27;</span>, <span class="string">&#x27;Alley&#x27;</span>, <span class="string">&#x27;CentralAir&#x27;</span>, <span class="string">&#x27;MSSubClass&#x27;</span>, <span class="string">&#x27;OverallCond&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;YrSold&#x27;</span>, <span class="string">&#x27;MoSold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">    lbl = LabelEncoder()</span><br><span class="line">    lbl.fit(<span class="built_in">list</span>(all_data[c].values))</span><br><span class="line">    all_data[c] = lbl.transform(<span class="built_in">list</span>(all_data[c].values))</span><br></pre></td></tr></table></figure><h3 id="创造新变量"><a href="#创造新变量" class="headerlink" title="创造新变量"></a>创造新变量</h3><p>鉴于房屋面积在决定房价的各个变量中居于主导地位，原作者添加了一个新的变量<code>TotalSF</code>，它是房屋地下室、第一层和第二层面积的总和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">&#x27;TotalSF&#x27;</span>] = all_data[<span class="string">&#x27;TotalBsmtSF&#x27;</span>] + all_data[<span class="string">&#x27;1stFlrSF&#x27;</span>] + all_data[<span class="string">&#x27;2ndFlrSF&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="正态化：box-cox变换"><a href="#正态化：box-cox变换" class="headerlink" title="正态化：box-cox变换"></a>正态化：box-cox变换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选出所有数值型的变量</span></span><br><span class="line">numeric_feats = all_data.dtypes[all_data.dtypes != <span class="string">&quot;object&quot;</span>].index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查所有数值型变量的偏态</span></span><br><span class="line">skewed_feats = all_data[numeric_feats].apply(<span class="keyword">lambda</span> x: skew(x.dropna())).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSkew in numerical features: \n&quot;</span>)</span><br><span class="line">skewness = pd.DataFrame(&#123;<span class="string">&#x27;Skew&#x27;</span> :skewed_feats&#125;)</span><br><span class="line">skewness.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>使用box-cox变换来正态化呈现明显偏态的变量。关于box-cox变换，可以参考<a href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.special.boxcox1p.html">scipy的官方文档</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">skewness = skewness[<span class="built_in">abs</span>(skewness) &gt; <span class="number">0.75</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are &#123;&#125; skewed numerical features to Box Cox transform&quot;</span>.<span class="built_in">format</span>(skewness.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> boxcox1p</span><br><span class="line">skewed_features = skewness.index</span><br><span class="line">lam = <span class="number">0.15</span></span><br><span class="line"><span class="keyword">for</span> feat <span class="keyword">in</span> skewed_features:</span><br><span class="line">    all_data[feat] = boxcox1p(all_data[feat], lam)</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：There are 59 skewed numerical features to Box Cox transform</p><h3 id="虚拟变量"><a href="#虚拟变量" class="headerlink" title="虚拟变量"></a>虚拟变量</h3><p>把所有离散型变量变成one-hot形式的变量。这一步可能会导致数据的变量数量大大增加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_data = pd.get_dummies(all_data)</span><br><span class="line"><span class="built_in">print</span>(all_data.shape)</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：(2917, 220)</p><p>以上完成了数据清洗的步骤，将合并后的数据集还原成训练集和测试集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train = all_data[:ntrain]</span><br><span class="line">test = all_data[ntrain:]</span><br></pre></td></tr></table></figure><h2 id="训练模型与测试"><a href="#训练模型与测试" class="headerlink" title="训练模型与测试"></a>训练模型与测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet, Lasso, BayesianRidge, LassoLarsIC <span class="comment">#线性回归模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor, GradientBoostingRegressor <span class="comment">#集成模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.kernel_ridge <span class="keyword">import</span> KernelRidge <span class="comment">#核岭回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline <span class="comment">#pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler <span class="comment">#标准化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin, RegressorMixin, clone <span class="comment">#自定义类的API</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold, cross_val_score, train_test_split <span class="comment">#交叉验证</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error <span class="comment">#均方误差</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb <span class="comment">#XGBoost</span></span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb <span class="comment">#lightGBM</span></span><br></pre></td></tr></table></figure><h3 id="定义模型评估方法"><a href="#定义模型评估方法" class="headerlink" title="定义模型评估方法"></a>定义模型评估方法</h3><ul><li>直接使用<code>cross_val_score</code>的参数<code>cv=5</code>没有将数据的顺序随机打乱，因此用了<code>KFold</code>方法，手动添加了<code>shuffle=True</code>，再用<code>get_n_splits</code>返回K折的折数。</li><li><code>random_state</code>为随机种子，保证每次得到的结果与原作者相同，该参数可以不加。</li><li>返回的<code>rmse</code>是模型在训练集上的均方根误差。由于Y已经对数转换过，因此实际上该值代表的是均方根误差的对数，即RMSLE。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5折交叉验证</span></span><br><span class="line">n_folds = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rmsle_cv</span>(<span class="params">model</span>):</span></span><br><span class="line">    kf = KFold(n_folds, shuffle=<span class="literal">True</span>, random_state=<span class="number">42</span>).get_n_splits(train.values)</span><br><span class="line">    rmse= np.sqrt(-cross_val_score(model, train.values, y_train, scoring=<span class="string">&quot;neg_mean_squared_error&quot;</span>, cv = kf))</span><br><span class="line">    <span class="keyword">return</span>(rmse)</span><br></pre></td></tr></table></figure><h3 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h3><p>原作者使用了常见的三种带正则化的线性回归模型和Kaggle比赛上大热的几种集成学习模型：GB、XGBoost和LightGBM。</p><ul><li><strong>Lasso回归</strong>：该算法对离群值敏感，因此需要加强鲁棒性。本例使用了<code>Robustscaler</code>这一标准化方法来缩放离群值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lasso = make_pipeline(RobustScaler(), Lasso(alpha =<span class="number">0.0005</span>, random_state=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li><strong>弹性网络回归（Elastic Net）</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENet = make_pipeline(RobustScaler(), ElasticNet(alpha=<span class="number">0.0005</span>, l1_ratio=<span class="number">.9</span>, random_state=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><ul><li><strong>核岭回归（KRR）</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KRR = KernelRidge(alpha=<span class="number">0.6</span>, kernel=<span class="string">&#x27;polynomial&#x27;</span>, degree=<span class="number">2</span>, coef0=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>Gradient Boosting回归</strong>：采用了Huber loss，处理离群值时更加健壮。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GBoost = GradientBoostingRegressor(n_estimators=<span class="number">3000</span>, learning_rate=<span class="number">0.05</span>,</span><br><span class="line">                                   max_depth=<span class="number">4</span>, max_features=<span class="string">&#x27;sqrt&#x27;</span>,</span><br><span class="line">                                   min_samples_leaf=<span class="number">15</span>, min_samples_split=<span class="number">10</span>,</span><br><span class="line">                                   loss=<span class="string">&#x27;huber&#x27;</span>, random_state =<span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>XGBoost</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model_xgb = xgb.XGBRegressor(colsample_bytree=<span class="number">0.4603</span>, gamma=<span class="number">0.0468</span>,</span><br><span class="line">                             learning_rate=<span class="number">0.05</span>, max_depth=<span class="number">3</span>,</span><br><span class="line">                             min_child_weight=<span class="number">1.7817</span>, n_estimators=<span class="number">2200</span>,</span><br><span class="line">                             reg_alpha=<span class="number">0.4640</span>, reg_lambda=<span class="number">0.8571</span>,</span><br><span class="line">                             subsample=<span class="number">0.5213</span>, silent=<span class="number">1</span>,</span><br><span class="line">                             random_state =<span class="number">7</span>, nthread = -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>LightGBM</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model_lgb = lgb.LGBMRegressor(objective=<span class="string">&#x27;regression&#x27;</span>,num_leaves=<span class="number">5</span>,</span><br><span class="line">                              learning_rate=<span class="number">0.05</span>, n_estimators=<span class="number">720</span>,</span><br><span class="line">                              max_bin = <span class="number">55</span>, bagging_fraction = <span class="number">0.8</span>,</span><br><span class="line">                              bagging_freq = <span class="number">5</span>, feature_fraction = <span class="number">0.2319</span>,</span><br><span class="line">                              feature_fraction_seed=<span class="number">9</span>, bagging_seed=<span class="number">9</span>,</span><br><span class="line">                              min_data_in_leaf =<span class="number">6</span>, min_sum_hessian_in_leaf = <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>用RMSLE评估各个基础模型在交叉验证集上的得分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = rmsle_cv(lasso)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nLasso score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Lasso score: 0.1115 (0.0074)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = rmsle_cv(ENet)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ElasticNet score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：ElasticNet score: 0.1116 (0.0074)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = rmsle_cv(KRR)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Kernel Ridge score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Kernel Ridge score: 0.1153 (0.0075)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = rmsle_cv(GBoost)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Gradient Boosting score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Gradient Boosting score: 0.1177 (0.0080)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = rmsle_cv(model_xgb)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Xgboost score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Xgboost score: 0.1151 (0.0069)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = rmsle_cv(model_lgb)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LGBM score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span> .<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：LGBM score: 0.1162 (0.0071)</p><h3 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h3><h4 id="最简单的集成模型：取各个基础模型的均值"><a href="#最简单的集成模型：取各个基础模型的均值" class="headerlink" title="最简单的集成模型：取各个基础模型的均值"></a>最简单的集成模型：取各个基础模型的均值</h4><p>新建一个类<code>AveragingModels</code>用于封装自定义的模型。<code>sklearn.base</code>中提供了所需继承的父类。</p><ul><li><code>BaseEstimator</code>：所有预测模型的基类，提供读写参数的方法（<code>__init__()</code>）。</li><li><code>RegressorMixin</code>：回归模型的Mixin类，提供返回回归模型$R^2$的方法（<code>predict()</code>）。</li><li><code>TransformerMixin</code>：提供拟合数据方法的Mixin类（<code>fit()</code>）。</li><li><code>clone</code>：复制一个具有相同参数的预测模型，不复制数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AveragingModels</span>(<span class="params">BaseEstimator, RegressorMixin, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, models</span>):</span></span><br><span class="line">        self.models = models</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">        <span class="comment"># 克隆原始模型</span></span><br><span class="line">        self.models_ = [clone(x) <span class="keyword">for</span> x <span class="keyword">in</span> self.models]</span><br><span class="line">        <span class="comment"># 拟合克隆的模型</span></span><br><span class="line">        <span class="keyword">for</span> model <span class="keyword">in</span> self.models_:</span><br><span class="line">            model.fit(X, y)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用克隆的模型预测并取其平均值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        predictions = np.column_stack([model.predict(X) \</span><br><span class="line">        <span class="keyword">for</span> model <span class="keyword">in</span> self.models_])</span><br><span class="line">        <span class="keyword">return</span> np.mean(predictions, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>用ENet、GBR、KRR和Lasso做一个均值集成模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">averaged_models = AveragingModels(models = (ENet, GBoost, KRR, lasso))</span><br><span class="line"></span><br><span class="line">score = rmsle_cv(averaged_models)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Averaged base models score: &#123;:.4f&#125; (&#123;:.4f&#125;)\n&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Averaged base models score: 0.1091 (0.0075)</p><p>可以看出，即便是最简单的均值集成模型也能取得比单一模型更好的效果。在此基础上尝试更加复杂的集成模型。</p><h4 id="进阶：Stacking集成模型"><a href="#进阶：Stacking集成模型" class="headerlink" title="进阶：Stacking集成模型"></a>进阶：Stacking集成模型</h4><p>Stacking模型的重点是在均值基础模型上添加一个元模型，并使用元模型进行最终预测。感兴趣的可以看一下这篇kernel：<a href="https://www.kaggle.com/arthurtok/introduction-to-ensembling-stacking-in-python">Stacking集成模型入门</a>。</p><p>整个Stacking过程主要分为两层：</p><ul><li><p>第一层通常会采用多种不同的基础模型（称为初级学习器），并采用K折（这里假设K=5），即把原始训练数据集分成5份，则需要进行5次迭代，每次迭代在其中4份上训练每一个初级学习器，用剩下的1份测试。在经历5次迭代之后，在整个原始训练集上都获得了新的预测结果，将其合并，称为次级训练集；每次训练同时都会在整个原始测试集上进行拟合，得到的5个结果取平均值作为次级测试集。</p></li><li><p>将多个初级学习器得到的次级训练集合并作为输入，原Y作为输出，训练元模型，并用其拟合次级测试集，得到最终预测。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stacking模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackingAveragedModels</span>(<span class="params">BaseEstimator, RegressorMixin, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, base_models, meta_model, n_folds=<span class="number">5</span></span>):</span></span><br><span class="line">        self.base_models = base_models</span><br><span class="line">        self.meta_model = meta_model</span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">        self.base_models_ = [<span class="built_in">list</span>() <span class="keyword">for</span> x <span class="keyword">in</span> self.base_models]</span><br><span class="line">        self.meta_model_ = clone(self.meta_model)</span><br><span class="line">        kfold = KFold(n_splits=self.n_folds, shuffle=<span class="literal">True</span>, random_state=<span class="number">156</span>)</span><br><span class="line">        out_of_fold_predictions = np.zeros((X.shape[<span class="number">0</span>], <span class="built_in">len</span>(self.base_models)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, model <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.base_models):</span><br><span class="line">            <span class="keyword">for</span> train_index, holdout_index <span class="keyword">in</span> kfold.split(X, y):</span><br><span class="line">                instance = clone(model)</span><br><span class="line">                self.base_models_[i].append(instance)</span><br><span class="line">                instance.fit(X[train_index], y[train_index])</span><br><span class="line">                y_pred = instance.predict(X[holdout_index])</span><br><span class="line">                out_of_fold_predictions[holdout_index, i] = y_pred</span><br><span class="line"></span><br><span class="line">        self.meta_model_.fit(out_of_fold_predictions, y)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        meta_features = np.column_stack([</span><br><span class="line">            np.column_stack([model.predict(X) <span class="keyword">for</span> model <span class="keyword">in</span> base_models]).mean(axis=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> base_models <span class="keyword">in</span> self.base_models_ ])</span><br><span class="line">        <span class="keyword">return</span> self.meta_model_.predict(meta_features)</span><br></pre></td></tr></table></figure><p>使用Enet、KRR和Gboost作为初级学习器，Lasso作为元学习器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stacked_averaged_models = StackingAveragedModels(base_models = (ENet, GBoost, KRR), meta_model = lasso)</span><br><span class="line"></span><br><span class="line">score = rmsle_cv(stacked_averaged_models)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stacking Averaged models score: &#123;:.4f&#125; (&#123;:.4f&#125;)&quot;</span>.<span class="built_in">format</span>(score.mean(), score.std()))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：Stacking Averaged models score: 0.1085 (0.0074)</p><p>从RMSLE得分上来看，运用Stacking集成之后得到了更好的验证集精度。</p><h4 id="集成Stacking、XGBoost和LightGBM"><a href="#集成Stacking、XGBoost和LightGBM" class="headerlink" title="集成Stacking、XGBoost和LightGBM"></a>集成Stacking、XGBoost和LightGBM</h4><p>首先定义RMSLE评分函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rmsle</span>(<span class="params">y, y_pred</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(mean_squared_error(y, y_pred))</span><br></pre></td></tr></table></figure><ul><li><strong>Stacking</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stacked_averaged_models.fit(train.values, y_train)</span><br><span class="line">stacked_train_pred = stacked_averaged_models.predict(train.values)</span><br><span class="line">stacked_pred = np.expm1(stacked_averaged_models.predict(test.values))</span><br><span class="line"><span class="built_in">print</span>(rmsle(y_train, stacked_train_pred))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：0.07815719379164626</p><ul><li><strong>XGBoost</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model_xgb.fit(train, y_train)</span><br><span class="line">xgb_train_pred = model_xgb.predict(train)</span><br><span class="line">xgb_pred = np.expm1(model_xgb.predict(test))</span><br><span class="line"><span class="built_in">print</span>(rmsle(y_train, xgb_train_pred))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：0.07879894799249872</p><ul><li><strong>LightGBM</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model_lgb.fit(train, y_train)</span><br><span class="line">lgb_train_pred = model_lgb.predict(train)</span><br><span class="line">lgb_pred = np.expm1(model_lgb.predict(test.values))</span><br><span class="line"><span class="built_in">print</span>(rmsle(y_train, lgb_train_pred))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：0.07307464036005418</p><p>把三个集成学习模型加权平均得到最终预测结果。</p><p>关于如何确定权重，原作者没有给出具体的方法，推测是根据RMSLE的高低来分配权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;RMSLE score on train data:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rmsle(y_train,stacked_train_pred*<span class="number">0.70</span> +</span><br><span class="line">               xgb_train_pred*<span class="number">0.15</span> + lgb_train_pred*<span class="number">0.15</span> ))</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：RMSLE score on train data: 0.07543604303996428</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensemble = stacked_pred*<span class="number">0.70</span> + xgb_pred*<span class="number">0.15</span> + lgb_pred*<span class="number">0.15</span></span><br></pre></td></tr></table></figure><p>在测试集上运用最终的加权平均，得到的结果输出csv文件后可以提交。原作者最终RMSLE得分为0.11420，截至2017年7月2日排名前4%。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本kernel的以下几点值得学习借鉴：</p><ul><li>仔细处理缺失值。</li><li>按照实际情况增加了新的变量，转化了一些数值型或标称型变量，以及虚拟化变量。</li><li>对偏态分布的变量使用box-cox变换而不是log变换。</li><li>运用了Stacking方法，它是Kaggle上取得好名次的一大利器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> 集成学习 </tag>
            
            <tag> Stacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle机器学习实战（2）——房价预测（上）</title>
      <link href="/kaggle_02/"/>
      <url>/kaggle_02/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">kaggle房价预测</a>是一个典型的回归问题。该问题提供了数千条房屋的房价和大量的特征变量，需要挑战者训练回归模型并预测测试集上房屋的房价，追求最小的均方误差。</p><p>这篇文章翻译自其中点赞数量最多的一篇<a href="https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python">kernel</a>，它主要讲的是探索性数据分析这一方面。</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>注意：<code>%matplotlib inline</code>是一个魔法函数，可以让matplotlib在Jupter Notebook中直接绘图，否则要使用<code>plt.show()</code>才能显示图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取csv格式的训练集</span></span><br><span class="line">df_train = pd.read_csv(<span class="string">&#x27;path/train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="观察变量"><a href="#观察变量" class="headerlink" title="观察变量"></a>观察变量</h2><p>训练集包含1460个样本，每个样本包含详细概括房子的各个信息的变量共计79个，以及它们的房价。</p><p>首先，搞清这79个变量是<strong>数值型</strong>（<strong>numerical</strong>）还是<strong>标称型</strong>（<strong>categorical</strong>）变量。然后我们根据生活中的实际经验，对可能影响房价的因素分成三大类：建筑本身，空间大小和区位。接着，对每个因子的重要性进行预估。</p><p>在依靠直觉对每个变量的重要性进行评估时，可以用三个问题作为标准：</p><ul><li>假如你在买房，你会考虑这个因素吗？</li><li>如果你要考虑这个因素，你会把它摆在第几位？</li><li>这个因素是否和其他因素有些重合？  </li></ul><p>据此就可以筛选出主观上较重要的因子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示变量名 </span></span><br><span class="line"><span class="built_in">print</span>(df_train.columns)</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">data_description.txt</a>。  </p><p>主观上认定以下变量与房价存在显著的相关性：</p><ul><li><code>OverallQual</code>（房屋的总体质量）：代表房屋质量的一个重要变量。</li><li><code>YearBuilt</code>（房龄）：代表房屋质量的另一个重要变量。</li><li><code>TotalBsmtSF</code>（地下室总面积）、<code>GrLivArea</code>（地上居住面积）：这个很容易理解。</li></ul><p>除了“房屋本身的质量”和“面积”这两大因素之外，很显然“区位”也是影响房价必须考虑的一项，但原数据给出的区位相关变量都是诸如周围有哪些地标建筑、靠近哪些交通枢纽这些无法直接体现区位优劣的变量，并且它们难以可视化。我们暂时不考虑它们。</p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>先观察预测变量Y：房价。它是一个连续型的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述性统计</span></span><br><span class="line"><span class="built_in">print</span>(df_train[<span class="string">&#x27;SalePrice&#x27;</span>].describe())</span><br><span class="line"><span class="comment"># 可视化Y</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>从图可知，训练集的房价呈现偏态分布。分析偏度和峰度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 偏度和峰度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Skewness: %f&quot;</span> % df_train[<span class="string">&#x27;SalePrice&#x27;</span>].skew())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Kurtosis: %f&quot;</span> % df_train[<span class="string">&#x27;SalePrice&#x27;</span>].kurt())</span><br></pre></td></tr></table></figure><p>我们希望因变量能服从正态分布，因为这将大大提升线性模型的性能。之后会使之变换为正态分布。</p><p>接下来可视化“主观上认为比较重要的变量”。</p><h3 id="与数值型变量的关系"><a href="#与数值型变量的关系" class="headerlink" title="与数值型变量的关系"></a>与数值型变量的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地上居住面积/房价散点图</span></span><br><span class="line">var = <span class="string">&#x27;GrLivArea&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">&#x27;SalePrice&#x27;</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 地下室面积/房价散点图</span></span><br><span class="line">var = <span class="string">&#x27;TotalBsmtSF&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">&#x27;SalePrice&#x27;</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br></pre></td></tr></table></figure><p>以上两个图可以在Jupter Notebook中自行绘制。从图上可以直观的看出，这两个变量都与房价正相关。值得注意的是这两个散点图出现了很多零散的不符合规律的点（离群值）。</p><h3 id="与标称型变量的关系"><a href="#与标称型变量的关系" class="headerlink" title="与标称型变量的关系"></a>与标称型变量的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 房屋质量/房价箱型图</span></span><br><span class="line">var = <span class="string">&#x27;OverallQual&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">fig = sns.boxplot(x=var, y=<span class="string">&quot;SalePrice&quot;</span>, data=data)</span><br><span class="line">fig.axis(ymin=<span class="number">0</span>, ymax=<span class="number">800000</span>)</span><br></pre></td></tr></table></figure><p>很显然，房价与房屋质量(<code>OverallQual</code>)呈正相关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 房子修建的年份/房价箱型图</span></span><br><span class="line">var = <span class="string">&#x27;YearBuilt&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">16</span>, <span class="number">8</span>))</span><br><span class="line">fig = sns.boxplot(x=var, y=<span class="string">&quot;SalePrice&quot;</span>, data=data)</span><br><span class="line">fig.axis(ymin=<span class="number">0</span>, ymax=<span class="number">800000</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">90</span>)</span><br></pre></td></tr></table></figure><p>这里，房屋的修建年份(<code>YearBuilt</code>)和房价似乎只有微弱的正相关性，但仍可以认为绝大多数情况下，越新的房子越能卖个高价。</p><p>对以上四个变量的可视化做个总结：</p><ol><li>“地上居住面积”(<code>GrLivArea</code>)和“地下室面积”(<code>TotalBsmtSF</code>)与房价呈显著的正相关，且“地下室面积”与房价拟合的直线斜率较大。</li><li>“房屋质量”(<code>OverallQual</code>)和“修建年份”(<code>YearBuilt</code>)与房价也具有相关性，其中“房屋质量”相关性更强。</li></ol><p>接下来，观察其他变量。客观地讲，它们是同等重要的。</p><h3 id="与其他变量的关系"><a href="#与其他变量的关系" class="headerlink" title="与其他变量的关系"></a>与其他变量的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有变量的相关性矩阵热图</span></span><br><span class="line">corrmat = df_train.corr()</span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">9</span>))</span><br><span class="line">sns.heatmap(corrmat, vmax=<span class="number">.8</span>, square=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与Y的相关性矩阵top10热图</span></span><br><span class="line">k = <span class="number">10</span>  <span class="comment"># 热力图变量数目</span></span><br><span class="line">cols = corrmat.nlargest(k, <span class="string">&#x27;SalePrice&#x27;</span>)[<span class="string">&#x27;SalePrice&#x27;</span>].index</span><br><span class="line">cm = np.corrcoef(df_train[cols].values.T)</span><br><span class="line">sns.<span class="built_in">set</span>(font_scale=<span class="number">1.25</span>)</span><br><span class="line">hm = sns.heatmap(cm, cbar=<span class="literal">True</span>, annot=<span class="literal">True</span>, square=<span class="literal">True</span>, fmt=<span class="string">&#x27;.2f&#x27;</span>, annot_kws=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;, yticklabels=cols.values, xticklabels=cols.values)</span><br></pre></td></tr></table></figure><p><code>seaborn</code>的热图是快速了解变量之间关系的极佳方法。我们主要关心浅色和深色区块，它表示两个变量之间具有强烈的正/负相关。在线性模型中，若自变量之间具有线性关系会对模型的性能产生影响，因为它们包含重复的信息，应当舍去。</p><p>从第一张图我们看出，“地下室面积”(<code>TotalBsmtSF</code>)和“一楼面积”(<code>1stFlrSF</code>)这两个变量高度正相关，以及车库系列变量(<code>GarageCars</code>, <code>GarageArea</code>)之间具有很强的关联（这些也符合我们的生活经验），我们将会只保留其中一个与房价相关性更高的变量。</p><p>第二张图主要是看与预测变量Y最相关的10个变量之间的相关性。我们可以更加清楚的看到这些变量之间的相关系数。这top10里面出现了地上面积、地下室面积、建筑质量和修建年份这些指标，证实了我们第一步的猜想；“地上居住面积”(<code>GrLivArea</code>)和“地上房间总数”(<code>TotRmsAbvGrd</code>)非常相关，因此我们只保留其中一个。</p><p>得到了与Y有较高关联性的特征（并剔除了一些相似的特征），我们接下来用散点图来进一步查看变量之间的联系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 房价与一些变量的关系的散点图</span></span><br><span class="line">sns.<span class="built_in">set</span>()</span><br><span class="line">cols = [<span class="string">&#x27;SalePrice&#x27;</span>, <span class="string">&#x27;OverallQual&#x27;</span>, <span class="string">&#x27;GrLivArea&#x27;</span>, <span class="string">&#x27;GarageCars&#x27;</span>, <span class="string">&#x27;TotalBsmtSF&#x27;</span>, <span class="string">&#x27;FullBath&#x27;</span>, <span class="string">&#x27;YearBuilt&#x27;</span>]</span><br><span class="line">sns.pairplot(df_train[cols], size=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure><p>我们发现“地下室面积”(<code>TotalBsmtSF</code>)和“地上面积”(<code>GrLiveArea</code>)的散点图上，有一串点可以连成一条直线。观察房价与修建年份的散点图，这些点云的上界和下界呈指数函数状分布，而近几年修建的新房的房价保持在指数函数上方，推测近几年房价涨的更快了。</p><p>至此我们初步完成了数据的可视化。</p><h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><p>在着手处理缺失值之前，我们要考虑清楚：</p><ol><li>数据缺失的现象有多普遍？</li><li>丢失的数据是随机的，还是有规律可循的？</li></ol><p>缺失值的处理要谨慎，我们显然不希望训练样本大量流失。此外，数据的缺失可能导致预测结果出现偏见以及歪曲事实。</p><p>首先，统计出缺失的变量及其频率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺失值查看</span></span><br><span class="line">total = df_train.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">percent = (df_train.isnull().<span class="built_in">sum</span>() / df_train.isnull().count()).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">missing_data = pd.concat([total, percent], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;Total&#x27;</span>, <span class="string">&#x27;Percent&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(missing_data.head(<span class="number">20</span>))</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"></th><th align="right">Total</th><th align="right">Percent</th></tr></thead><tbody><tr><td align="left">PoolQC</td><td align="right">1453</td><td align="right">0.995205</td></tr><tr><td align="left">MiscFeature</td><td align="right">1406</td><td align="right">0.963014</td></tr><tr><td align="left">Alley</td><td align="right">1369</td><td align="right">0.937671</td></tr><tr><td align="left">Fence</td><td align="right">1179</td><td align="right">0.807534</td></tr><tr><td align="left">FireplaceQu</td><td align="right">690</td><td align="right">0.472603</td></tr><tr><td align="left">LotFrontage</td><td align="right">259</td><td align="right">0.177397</td></tr><tr><td align="left">GarageCond</td><td align="right">81</td><td align="right">0.055479</td></tr><tr><td align="left">GarageType</td><td align="right">81</td><td align="right">0.055479</td></tr><tr><td align="left">GarageYrBlt</td><td align="right">81</td><td align="right">0.055479</td></tr><tr><td align="left">GarageFinish</td><td align="right">81</td><td align="right">0.055479</td></tr><tr><td align="left">GarageQual</td><td align="right">81</td><td align="right">0.055479</td></tr><tr><td align="left">BsmtExposure</td><td align="right">38</td><td align="right">0.026027</td></tr><tr><td align="left">BsmtFinType2</td><td align="right">38</td><td align="right">0.026027</td></tr><tr><td align="left">BsmtFinType1</td><td align="right">37</td><td align="right">0.025342</td></tr><tr><td align="left">BsmtCond</td><td align="right">37</td><td align="right">0.025342</td></tr><tr><td align="left">BsmtQual</td><td align="right">37</td><td align="right">0.025342</td></tr><tr><td align="left">MasVnrArea</td><td align="right">8</td><td align="right">0.005479</td></tr><tr><td align="left">MasVnrType</td><td align="right">8</td><td align="right">0.005479</td></tr><tr><td align="left">Electrical</td><td align="right">1</td><td align="right">0.000685</td></tr><tr><td align="left">Utilities</td><td align="right">0</td><td align="right">0.000000</td></tr></tbody></table><p>通常情况下，我们考虑当某一个变量的缺失值超过15%，就直接删除这个变量，而不是尝试去填充它。按这个思路，“泳池质量”(<code>PoolQC</code>)、“杂项（电梯等）”(<code>MiscFeature</code>)、“屋旁小巷类型”(<code>Alley</code>)、“栅栏质量”(<code>Fence</code>)等几个变量就应当剔除。关键在于我们抛弃这些数据会错失一些有用信息吗？我认为不会，因为我们在买房时不会重视这些信息。所以可以放心删除它们。</p><p>在剩下来的变量中，车库系列变量(<code>GarageX</code>)缺失的数目相同。考虑到有关车库的信息中最重要的是容量(<code>GarageCars</code>)，因此我们可以删除这些不怎么重要的变量。同理，我们对地下室系列变量(<code>BsmtX</code>)做同样的处理。</p><p>对于“砌砖面积”(<code>MasVnrArea</code>)及其材质(<code>MasVnrType</code>)这两个变量，我们认为它不重要，并且它们与“修建年份”(<code>YearBuilt</code>)和“房屋总体质量”(<code>OverallQual</code>)有很强的相关性。因此，抛弃这两个变量不会丢失重要信息。</p><p>最后，在“电气系统”(<code>Electrical</code>)这个变量中有一个确失值，我们选择删除包含这个缺失值的样本，并保留这一变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺失值处理</span></span><br><span class="line">df_train = df_train.drop((missing_data[missing_data[<span class="string">&#x27;Total&#x27;</span>] &gt; <span class="number">1</span>]).index, <span class="number">1</span>)</span><br><span class="line">df_train = df_train.drop(df_train.loc[df_train[<span class="string">&#x27;Electrical&#x27;</span>].isnull()].index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证一下是否处理了全部的缺失值</span></span><br><span class="line">df_train.isnull().<span class="built_in">sum</span>().<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure><h2 id="处理离群值"><a href="#处理离群值" class="headerlink" title="处理离群值"></a>处理离群值</h2><p>离群值就是指数据中偏离其他数值较大的数值。离群值可以显著地影响模型，并且提供了一些特例以供我们解读。这里就以预测变量Y——房价的标准差来分析。</p><h3 id="单变量分析"><a href="#单变量分析" class="headerlink" title="单变量分析"></a>单变量分析</h3><p>我们要设定一个阈值，把部分观测值设定为离群值。首先，需要标准化数据。这里的标准化包括把数据的平均值化为0，同时标准差化为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据标准化</span></span><br><span class="line">saleprice_scaled = StandardScaler().fit_transform(df_train[<span class="string">&#x27;SalePrice&#x27;</span>][:, np.newaxis]);</span><br><span class="line">low_range = saleprice_scaled[saleprice_scaled[:, <span class="number">0</span>].argsort()][:<span class="number">10</span>]</span><br><span class="line">high_range = saleprice_scaled[saleprice_scaled[:, <span class="number">0</span>].argsort()][-<span class="number">10</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;outer range (low) of the distribution:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(low_range)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nouter range (high) of the distribution:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(high_range)</span><br></pre></td></tr></table></figure><p>从结果中可以看出，最低的10个值偏离0都不太远，而最高的10个值中，距离0都较远。尤其是需要注意两个大于7的值。我们再做进一步的分析。</p><h3 id="双变量分析"><a href="#双变量分析" class="headerlink" title="双变量分析"></a>双变量分析</h3><p>重新绘制与房价相关变量的散点图，这次的目的是观察离群值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地上居住面积/房价双变量分析</span></span><br><span class="line">var = <span class="string">&#x27;GrLivArea&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">&#x27;SalePrice&#x27;</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br></pre></td></tr></table></figure><p>现在重新审视这张图可以发现：地上面积最大的两个房子，它们的价格却反常的低，我们可以推测比如这两个房子在乡下。我们要做的是把这两个样本定义为离群值并剔除，因为它们不能代表典型的情况。</p><p>上文说要留意两个偏离较大的值，也就是图中房价最高的两个点。但从这张散点图上看，这两个特殊案例符合主流趋势，因此对这两个点予以保留。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除离群值</span></span><br><span class="line">df_train.sort_values(by=<span class="string">&#x27;GrLivArea&#x27;</span>, ascending=<span class="literal">False</span>)[:<span class="number">2</span>]</span><br><span class="line">df_train = df_train.drop(df_train[df_train[<span class="string">&#x27;Id&#x27;</span>] == <span class="number">1299</span>].index)</span><br><span class="line">df_train = df_train.drop(df_train[df_train[<span class="string">&#x27;Id&#x27;</span>] == <span class="number">524</span>].index)</span><br></pre></td></tr></table></figure><p>同样，我们重新观察一下地下室面积与房价的散点图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地下室面积/房价双变量分析</span></span><br><span class="line">var = <span class="string">&#x27;TotalBsmtSF&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">&#x27;SalePrice&#x27;</span>, ylim=(<span class="number">0</span>, <span class="number">800000</span>))</span><br></pre></td></tr></table></figure><p>可以观察到部分点（例如面积大于3000的3个）有离群的迹象，但可以接受，因此予以保留。</p><h2 id="正态化数据"><a href="#正态化数据" class="headerlink" title="正态化数据"></a>正态化数据</h2><p>根据多重线性回归的假设检验，我们要确保数据具有以下特性：</p><ol><li>正态性：残差e服从正态分布。</li><li>方差齐性：残差e的大小不随变量取值水平的改变而改变。</li><li>线性：自变量与因变量之间存在线性关系。</li><li>独立性：各个自变量之间不存在多重共线性问题。</li></ol><p>现在要解决正态性问题。单变量的正态化并不能保证整个多元回归的正态性，但有一定效果。这同时可以解决异方差性的问题。</p><p>数据服从标准正态分布是我们的追求。对数据正态化的方法有很多，比如Box-Cox变换。我们已经知道这组数据中有些变量，例如因变量房价，服从偏态分布，可以用更简单的方法使之正态化。</p><p>首先我们绘制所要考察变量的柱状图和正态概率分布图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 房价的柱状图和正太概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>], fit=norm)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><p>很明显这组房价满足偏态分布；用一种简单的转换方法可以使这组数据符合正态分布——取对数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对房价取对数</span></span><br><span class="line">df_train[<span class="string">&#x27;SalePrice&#x27;</span>] = np.log(df_train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换后的房价的柱状图和正太概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>], fit=norm)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><p>然后处理一个重要的自变量“地上居住面积”(<code>GrLiveArea</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地上面积的柱状图和正太概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对地上面积取对数</span></span><br><span class="line">df_train[<span class="string">&#x27;GrLivArea&#x27;</span>] = np.log(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换后的地上面积的柱状图和正太概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><p>“地下室面积”(<code>totalBesmtSF</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地下室面积的柱状图和正太概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><p>处理这个变量相对比较棘手，因为有相当一部分的观测值为0。而0值是无法取对数的。除去这些0，总体上还是满足偏态分布的。因此，我们会新建一个二值变量来反映这个样本是否包含地下室，对于有地下室的样本进行对数转换，忽略无地下室的样本。（因为无法确定这种做法对不对，原作者称之为‘high risk engineering’。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个新的列来存储新的变量</span></span><br><span class="line"><span class="comment"># 如果area&gt;0则新变量为1，如果area==0则为0</span></span><br><span class="line">df_train[<span class="string">&#x27;HasBsmt&#x27;</span>] = pd.Series(<span class="built_in">len</span>(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]), index=df_train.index)</span><br><span class="line">df_train[<span class="string">&#x27;HasBsmt&#x27;</span>] = <span class="number">0</span> </span><br><span class="line">df_train.loc[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>,<span class="string">&#x27;HasBsmt&#x27;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对符合条件的地下室面积取对数</span></span><br><span class="line">df_train.loc[df_train[<span class="string">&#x27;HasBsmt&#x27;</span>]==<span class="number">1</span>,<span class="string">&#x27;TotalBsmtSF&#x27;</span>] = np.log(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换后的地下室面积的柱状图和正太概率分布图</span></span><br><span class="line">sns.distplot(df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;TotalBsmtSF&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;TotalBsmtSF&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure><h3 id="同方差性"><a href="#同方差性" class="headerlink" title="同方差性"></a>同方差性</h3><p>以地上居住面积与房价关系的散点图为例，早先版本的散点图左下角密集而右上角稀疏，呈现圆锥状，这就是具有同方差性的问题。</p><p>绘制对数转换后的散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地上居住面积/房价散点图</span></span><br><span class="line">plt.scatter(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], df_train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br></pre></td></tr></table></figure><p>可以看见我们已经解决了同方差性的问题，数据变得正态了。再来看看房价和地下室面积的关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地下室面积/房价散点图</span></span><br><span class="line">plt.scatter(df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;TotalBsmtSF&#x27;</span>], df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;SalePrice&#x27;</span>])</span><br></pre></td></tr></table></figure><p>至此，我们可以认为这几个重要变量的正态化已经完成了。</p><h2 id="虚拟变量"><a href="#虚拟变量" class="headerlink" title="虚拟变量"></a>虚拟变量</h2><p>这一步将把标称型的数据one-hot化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把标称性变量虚拟化</span></span><br><span class="line">df_train = pd.get_dummies(df_train)</span><br></pre></td></tr></table></figure><p>这篇探索性数据分析的kernel就到此为止了。接下来要做的就是训练模型，将会参考另外一篇<a href="https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard">kernel</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于大多数Kaggle数据科学竞赛，处理数据是耗费的时间最多的、并且是对结果精度影响最大的环节。因此这篇kernel尽管没有到训练那一步，却获得了极高的点赞数。</li><li>探索性数据分析，包含数据可视化、处理缺失值、离群值以及数据标准化、正态化、虚拟化等等，对于数据挖掘和统计机器学习非常重要。作为初学者，要熟练运用numpy、matplotlib、pandas这三大利器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> 数据清洗 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle机器学习实战（1）——泰坦尼克号生还预测</title>
      <link href="/kaggle_01/"/>
      <url>/kaggle_01/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.kaggle.com/c/titanic">泰坦尼克号生还预测</a>是非常推荐给入门级新手的一个热身训练。这是一个二分类任务。本文主要翻译自这篇<a href="https://www.kaggle.com/mrisdal/exploring-survival-on-the-titanic">kernel</a>，它是kaggle上点赞数最高的一篇kernel（截至2018-03-28）。采用的工具是R语言。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调包</span></span><br><span class="line">library(<span class="string">&#x27;ggplot2&#x27;</span>) <span class="comment"># 数据可视化</span></span><br><span class="line">library(<span class="string">&#x27;ggthemes&#x27;</span>) <span class="comment"># 数据可视化</span></span><br><span class="line">library(<span class="string">&#x27;scales&#x27;</span>) <span class="comment"># 数据可视化</span></span><br><span class="line">library(<span class="string">&#x27;dplyr&#x27;</span>) <span class="comment"># 数据操作</span></span><br><span class="line">library(<span class="string">&#x27;mice&#x27;</span>) <span class="comment"># 缺失值填充</span></span><br><span class="line">library(<span class="string">&#x27;randomForest&#x27;</span>) <span class="comment"># 这一步就已经剧透了，我们要用随机森林</span></span><br></pre></td></tr></table></figure><p>之后我们读取csv格式的数据，假设数据存放在../input文件夹下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train &lt;- read.csv(<span class="string">&#x27;../input/train.csv&#x27;</span>, stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line">test  &lt;- read.csv(<span class="string">&#x27;../input/test.csv&#x27;</span>, stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line"></span><br><span class="line">full  &lt;- bind_rows(train, test) <span class="comment"># 合并训练集和测试集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总览数据</span></span><br><span class="line">str(full)</span><br></pre></td></tr></table></figure><p>经过这一步我们就对变量有了大体的印象，哪些变量是数值型的，哪些变量是字符串型的。我们总共有12个变量，1309组数据。为了更方便理解，我们再来看一遍变量代表了什么：</p><ul><li><code>Survived</code>：我们要预测的Y，用1表示生还，0表示死亡</li><li><code>Pclass</code>：头等舱/二等舱/三等舱</li><li><code>Name</code>：姓名</li><li><code>Sex</code>：性别</li><li><code>Age</code>：年龄</li><li><code>SibSp</code>：船上兄弟姐妹/配偶的数量</li><li><code>Parch</code>：船上父母/孩子的数量</li><li><code>Ticket</code>：船票号码</li><li><code>Fare</code>：船票费用</li><li><code>Cabin</code>：舱位</li><li><code>Embarked</code>：登船的港口（瑟堡/皇后镇/南安普顿）</li></ul><p>看过电影《泰坦尼克号》或者听说过西方宣传的所谓“骑士精神”的人，都知道泰坦尼克号上妇女和小孩的生还几率比男性要高很多；此外头等舱乘客的生还率也是显然要高于二等舱、三等舱的。因此，<code>Sex</code>、<code>Age</code>、<code>Pclass</code>、<code>Fare</code>这些变量我们想当然的把它们列入考察范围。关键就在于对剩下的一些变量的运用——这就是<strong>特征工程</strong>了，在这个实战项目中，它甚至比选择哪一种分类方法更为重要。</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="姓名的处理"><a href="#姓名的处理" class="headerlink" title="姓名的处理"></a>姓名的处理</h3><p>对于“乘客的姓名”这一变量，许多人认为这是一个跟预测结果无关紧要的变量，难道叫张三还是李四会决定一个人的生死？但是，仔细观察变量会发现：这一长串的名字可不是“张三”“李四”这么简单，它们由名字、称谓（例如Mrs., Dr.）、姓氏构成。这些字符串可以拆分出一些有用的信息，例如，称谓可以体现一个人的阶级属性；有相同姓氏的人可以归为一个家庭（外国人同姓不同族的情况比中国少多了）。因此我们要做的就是尽可能利用给出的信息，来创造变量！</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从姓名中提取有用的信息（Title：称谓）</span></span><br><span class="line">full$Title &lt;- gsub(<span class="string">&#x27;(.*, )|(\\..*)&#x27;</span>, <span class="string">&#x27;&#x27;</span>, full$Name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按性别显示称谓的统计信息</span></span><br><span class="line">table(full$Sex, full$Title)</span><br></pre></td></tr></table></figure><p>第一步是利用R语言中的<code>gsub()</code>函数，将不需要的字符串替换掉：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsub(pattern, replacement, x)</span><br></pre></td></tr></table></figure><p><code>gsub()</code>会替换<code>x</code>中所有满足<code>pattern</code>条件的字符串转变为<code>replacement</code>，在此之前我们要简单了解一下R的正则表达式，<code>.</code>表示任意字符，<code>\\</code>是转义字符，因此<code>\\.</code>就是一般的句点，<code>|</code>是逻辑或，可以简单理解为前后两个条件的并集。例如<code>Braund, Mr. Owen Harris</code>，我们要提取<code>Mr</code>，就是把第一个逗号+空格之前的字符串以及第一个句点后面的字符串全部替换为空。  </p><p>我们可以看到<code>Capt</code>、<code>Col</code>、<code>Don</code>、<code>Dona</code>等等这些称谓只有极个位数的人，因此要精简一下。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动把一些出现频率较低的称谓归为“稀有称谓”</span></span><br><span class="line">rare_title &lt;- <span class="built_in">c</span>(<span class="string">&#x27;Dona&#x27;</span>, <span class="string">&#x27;Lady&#x27;</span>, <span class="string">&#x27;the Countess&#x27;</span>,<span class="string">&#x27;Capt&#x27;</span>, <span class="string">&#x27;Col&#x27;</span>, <span class="string">&#x27;Don&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;Dr&#x27;</span>, <span class="string">&#x27;Major&#x27;</span>, <span class="string">&#x27;Rev&#x27;</span>, <span class="string">&#x27;Sir&#x27;</span>, <span class="string">&#x27;Jonkheer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同义词转换</span></span><br><span class="line">full$Title[full$Title == <span class="string">&#x27;Mlle&#x27;</span>]        &lt;- <span class="string">&#x27;Miss&#x27;</span> </span><br><span class="line">full$Title[full$Title == <span class="string">&#x27;Ms&#x27;</span>]          &lt;- <span class="string">&#x27;Miss&#x27;</span></span><br><span class="line">full$Title[full$Title == <span class="string">&#x27;Mme&#x27;</span>]         &lt;- <span class="string">&#x27;Mrs&#x27;</span> </span><br><span class="line">full$Title[full$Title %in% rare_title]  &lt;- <span class="string">&#x27;Rare Title&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再按性别显示称谓的统计信息</span></span><br><span class="line">table(full$Sex, full$Title)</span><br></pre></td></tr></table></figure><p>于是我们得到了：男性中有61人为<code>Master</code>称谓，25人为稀有称谓，其余757人为普通的<code>Mr</code>称谓；女性中有264人为未婚<code>Miss</code>，198人为已婚<code>Mrs</code>，4人为稀有称谓。</p><p>接着，我们提取名字中的姓氏，这很有可能会与ta是否生还密切相关——因为“一家人最重要的是整整齐齐”。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取姓氏，增设一个变量：Surname</span></span><br><span class="line">full$Surname &lt;- sapply(full$Name,  </span><br><span class="line">                      <span class="keyword">function</span>(x) strsplit(x, split = <span class="string">&#x27;[,.]&#x27;</span>)[[<span class="number">1</span>]][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">nlevels(factor(full$Surname))</span><br></pre></td></tr></table></figure><p>共有875个不重样的姓氏。（有兴趣的话，还可以从姓氏分析出国籍、种族。）</p><h3 id="同一家族的人"><a href="#同一家族的人" class="headerlink" title="同一家族的人"></a>同一家族的人</h3><p>现在我们有了姓氏，再结合<code>SibSp</code>和<code>Parch</code>两个反映家族特征的变量，可以拿过来制造我们所需的变量。首先，我们创造一个表示船上有多少名家族成员的变量。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个船上同一家族人数的变量（包含自己）</span></span><br><span class="line">full$Fsize &lt;- full$SibSp + full$Parch + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创造一个新变量，把家族大小跟在姓氏后面更直观一些</span></span><br><span class="line">full$Family &lt;- paste(full$Surname, full$Fsize, sep=<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把家族人数和生还情况的关系可视化一下</span></span><br><span class="line">ggplot(full[<span class="number">1</span>:<span class="number">891</span>,], aes(x = Fsize, fill = factor(Survived))) +</span><br><span class="line">  geom_bar(stat=<span class="string">&#x27;count&#x27;</span>, position=<span class="string">&#x27;dodge&#x27;</span>) +</span><br><span class="line">  scale_x_continuous(breaks=<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">11</span>)) +</span><br><span class="line">  labs(x = <span class="string">&#x27;Family Size&#x27;</span>) +</span><br><span class="line">  theme_few()</span><br></pre></td></tr></table></figure><p>通过柱状图可以非常直观地看出，家庭大小在2~4人的生还率要超过50%，而相对的，单身的和家庭超过4人的则生还率有非常明显的降低。据此，我们创建一个新的变量来更好地反映家庭大小与生还情况的关系：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立离散的家庭大小变量</span></span><br><span class="line">full$FsizeD[full$Fsize == <span class="number">1</span>] &lt;- <span class="string">&#x27;singleton&#x27;</span></span><br><span class="line">full$FsizeD[full$Fsize &lt; <span class="number">5</span> &amp; full$Fsize &gt; <span class="number">1</span>] &lt;- <span class="string">&#x27;small&#x27;</span></span><br><span class="line">full$FsizeD[full$Fsize &gt; <span class="number">4</span>] &lt;- <span class="string">&#x27;large&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把离散的家庭大小变量和生还情况用马赛克图表示</span></span><br><span class="line">mosaicplot(table(full$FsizeD, full$Survived), main=<span class="string">&#x27;Family Size by Survival&#x27;</span>, shade=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>马赛克图更为清晰地揭示了单身和大家庭的人更难以生还的事实。如果结合年龄数据，可以挖掘出更多信息——但是年龄一项有263个缺失值，因此先跳过。  </p><p>最后再看一下<code>Cabin</code>这个变量，它有太多的缺失值了。我们能从中挖掘的信息就是它的第一位代表甲板号A-F，也就是房间所在位置，它可能会是影响能否生还的变量。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">full$Deck&lt;-factor(sapply(full$Cabin, <span class="keyword">function</span>(x) strsplit(x, <span class="literal">NULL</span>)[[<span class="number">1</span>]][<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>另外就是有一些带有多个舱位的数据（例如“C23 C25 C27”），我们想办法在这上面做点文章。但首先，我们要做的是处理缺失值。</p><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>接下来我们要处理最为棘手的缺失值了。也许快刀斩乱麻是一个方法，但由于这个训练样本容量较小、特征维度也较小，我们不应该选择删除某一个训练样本或者某一特征。所以我们选择用这一行或这一列的平均数、中位数、众数来填充。选择填充缺失值的方法之前，我们可以借助可视化的手段。  </p><h3 id="用合理的值填充"><a href="#用合理的值填充" class="headerlink" title="用合理的值填充"></a>用合理的值填充</h3><p>我们先看登船港口这一项，有62号和830号两个缺失值。他们俩有相同的票号、票价和船舱号，所以他们是一个港口上船的。让我们把票价和登船港口以及舱位等级的图画一画，关系就清晰明了。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先把缺失项排除掉</span></span><br><span class="line">embark_fare &lt;- full %&gt;%</span><br><span class="line">  filter(PassengerId != <span class="number">62</span> &amp; PassengerId != <span class="number">830</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把登船港口跟船舱等级和票价做个可视化</span></span><br><span class="line">ggplot(embark_fare, aes(x = Embarked, y = Fare, fill = factor(Pclass))) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  geom_hline(aes(yintercept=<span class="number">80</span>), </span><br><span class="line">    colour=<span class="string">&#x27;red&#x27;</span>, linetype=<span class="string">&#x27;dashed&#x27;</span>, lwd=<span class="number">2</span>) +</span><br><span class="line">  scale_y_continuous(labels=dollar_format()) +</span><br><span class="line">  theme_few()</span><br></pre></td></tr></table></figure><p>请在RStudio里面画一画——有了这个箱形图就直观多了。很显然，票价与登船港口和船舱等级直接相关，而80刀所对应的区间正位于头等舱-C港口的那群人的中位数附近。那么，在票价上花了80刀，并且是头等舱乘客的62号，他的登船港口我们可以放心大胆地填上C。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">full$Embarked[<span class="built_in">c</span>(<span class="number">62</span>, <span class="number">830</span>)] &lt;- <span class="string">&#x27;C&#x27;</span></span><br></pre></td></tr></table></figure><p>接着处理1044号乘客票价一栏的缺失值。很显然，我们要找和他同样的三等舱、S港口上船的乘客，比较他们的船票价格，填充一个比较合理的数值。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三等舱、S登船的乘客的票价，并标注出中位数</span></span><br><span class="line">ggplot(full[full$Pclass == <span class="string">&#x27;3&#x27;</span> &amp; full$Embarked == <span class="string">&#x27;S&#x27;</span>, ], </span><br><span class="line">  aes(x = Fare)) +</span><br><span class="line">  geom_density(fill = <span class="string">&#x27;#99d6ff&#x27;</span>, alpha=<span class="number">0.4</span>) + </span><br><span class="line">  geom_vline(aes(xintercept=median(Fare, na.rm=<span class="built_in">T</span>)),</span><br><span class="line">    colour=<span class="string">&#x27;red&#x27;</span>, linetype=<span class="string">&#x27;dashed&#x27;</span>, lwd=<span class="number">1</span>) +</span><br><span class="line">  scale_x_continuous(labels=dollar_format()) +</span><br><span class="line">  theme_few()</span><br></pre></td></tr></table></figure><p>好，我们完全有理由给这个缺失值填上8.05刀——三等舱S登船的票价的中位数。</p><h3 id="预测推断"><a href="#预测推断" class="headerlink" title="预测推断"></a>预测推断</h3><p>上面我们处理的都是少量的缺失值，但是看看年龄这一项，有太多的缺失值了，如果用平均数或者中位数来填充，效果肯定会不好，所以我们要建立一个回归模型来预测缺失值的年龄。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看一看有多少缺失值</span></span><br><span class="line"><span class="built_in">sum</span>(<span class="built_in">is.na</span>(full$Age))</span><br></pre></td></tr></table></figure><p>这里原文用了<code>mice</code>这个包来做预测推断。<code>mice</code>利用其他已知变量的数据对待填充的数据进行拟合并填充，</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先把这些定性的变量化为factor类型</span></span><br><span class="line">factor_vars &lt;- <span class="built_in">c</span>(<span class="string">&#x27;PassengerId&#x27;</span>,<span class="string">&#x27;Pclass&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>,<span class="string">&#x27;Embarked&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;Title&#x27;</span>,<span class="string">&#x27;Surname&#x27;</span>,<span class="string">&#x27;Family&#x27;</span>,<span class="string">&#x27;FsizeD&#x27;</span>)</span><br><span class="line"></span><br><span class="line">full[factor_vars] &lt;- lapply(full[factor_vars], <span class="keyword">function</span>(x) as.factor(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置随机数种子，接下来我们用随机森林填充缺失值</span></span><br><span class="line">set.seed(<span class="number">129</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用数据集中已知的数据拟合缺失值，首先排除一些不需要的变量</span></span><br><span class="line">mice_mod &lt;- mice(full[, !<span class="built_in">names</span>(full) %in% <span class="built_in">c</span>(<span class="string">&#x27;PassengerId&#x27;</span>,<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Ticket&#x27;</span>,<span class="string">&#x27;Cabin&#x27;</span>,<span class="string">&#x27;Family&#x27;</span>,<span class="string">&#x27;Surname&#x27;</span>,<span class="string">&#x27;Survived&#x27;</span>)], method=<span class="string">&#x27;rf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">mice_output &lt;- complete(mice_mod)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看补全后的和原始的年龄数值分布情况</span></span><br><span class="line">par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">hist(full$Age, freq=<span class="built_in">F</span>, main=<span class="string">&#x27;Age: Original Data&#x27;</span>, </span><br><span class="line">  col=<span class="string">&#x27;darkgreen&#x27;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">0.04</span>))</span><br><span class="line">hist(mice_output$Age, freq=<span class="built_in">F</span>, main=<span class="string">&#x27;Age: MICE Output&#x27;</span>, </span><br><span class="line">  col=<span class="string">&#x27;lightgreen&#x27;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">0.04</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果看起来不错，所以把拟合出的结果代入到原数据集中</span></span><br><span class="line">full$Age &lt;- mice_output$Age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后查看缺失值数量，变成0了</span></span><br><span class="line"><span class="built_in">sum</span>(<span class="built_in">is.na</span>(full$Age))</span><br></pre></td></tr></table></figure><p>这样我们就完成了年龄的缺失值填充了。前面已经说过，对于我们要预测的生还情况而言，年龄是一个相当重要的参数。所以我们可以再多做一些特征工程，创造一些更有用的变量。（下面这一步我认为是这篇kernel的精华所在！）</p><h3 id="利用好‘年龄’变量"><a href="#利用好‘年龄’变量" class="headerlink" title="利用好‘年龄’变量"></a>利用好‘年龄’变量</h3><p>我们有了完整的年龄数据，再结合之前通过姓名提取的一些信息，可以创造出更具价值的变量——<code>Child</code>和<code>Mother</code>，这是两个布尔型的变量。判断一个人是否是孩子很简单，年龄小于18。判断一个人是不是妈妈需要4点：</p><ol><li>她是女性；</li><li>她大于18岁；</li><li>她的孩子数量大于0；</li><li>她的称谓不是<code>Miss</code>。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先看一下年龄，性别和生还率的关系</span></span><br><span class="line">ggplot(full[<span class="number">1</span>:<span class="number">891</span>,], aes(Age, fill = factor(Survived))) + </span><br><span class="line">  geom_histogram() + </span><br><span class="line">  facet_grid(.~Sex) + </span><br><span class="line">  theme_few()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创造一个变量</span></span><br><span class="line">full$Child[full$Age &lt; <span class="number">18</span>] &lt;- <span class="string">&#x27;Child&#x27;</span></span><br><span class="line">full$Child[full$Age &gt;= <span class="number">18</span>] &lt;- <span class="string">&#x27;Adult&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个新建的变量的统计</span></span><br><span class="line">table(full$Child, full$Survived)</span><br></pre></td></tr></table></figure><p>从这个结果似乎看不出孩子的身份能保证一名乘客生还。接下来创造<code>Mother</code>这个变量，我们预想中母亲的生还率会高一些。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造一个变量</span></span><br><span class="line">full$Mother &lt;- <span class="string">&#x27;Not Mother&#x27;</span></span><br><span class="line">full$Mother[full$Sex == <span class="string">&#x27;female&#x27;</span> &amp; full$Parch &gt; <span class="number">0</span> &amp; full$Age &gt; <span class="number">18</span> &amp; full$Title != <span class="string">&#x27;Miss&#x27;</span>] &lt;- <span class="string">&#x27;Mother&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个新建的变量的统计</span></span><br><span class="line">table(full$Mother, full$Survived)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把这两个新建的变量添加到原数据集中</span></span><br><span class="line">full$Child  &lt;- factor(full$Child)</span><br><span class="line">full$Mother &lt;- factor(full$Mother)</span><br></pre></td></tr></table></figure><p>保险起见可以再复查一下有没有疏漏：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md.pattern(full)</span><br></pre></td></tr></table></figure><p>填补了年龄、登船港口和船票价格的缺失值，并且创建了一些相信对预测结果能起到作用的变量，接下来便可以进行训练和预测了。</p><h2 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h2><p>选择何种分类模型对最终结果的精度是至关重要的，但这篇文章的作者没有告诉我们为什么选择随机森林，以及参数如何确定。</p><p>先拆分训练集和测试集。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train &lt;- full[<span class="number">1</span>:<span class="number">891</span>,]</span><br><span class="line">test &lt;- full[<span class="number">892</span>:<span class="number">1309</span>,] </span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置随机数种子</span></span><br><span class="line">set.seed(<span class="number">754</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型（只挑选了有用的变量用于训练）</span></span><br><span class="line">rf_model &lt;- randomForest(factor(Survived) ~ Pclass + Sex + Age + SibSp + Parch + </span><br><span class="line">                                            Fare + Embarked + Title + </span><br><span class="line">                                            FsizeD + Child + Mother,</span><br><span class="line">                                            data = train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化性能随树的数量的变化</span></span><br><span class="line">plot(rf_model, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">0.36</span>))</span><br><span class="line">legend(<span class="string">&#x27;topright&#x27;</span>, colnames(rf_model$err.rate), col=<span class="number">1</span>:<span class="number">3</span>, fill=<span class="number">1</span>:<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这张图上黑线表示整体的错误率（大约在20%左右），红线和绿线分别表示死亡和幸存的错误率。预测死亡比预测生还要更成功。这是为什么？</p><h3 id="变量权重"><a href="#变量权重" class="headerlink" title="变量权重"></a>变量权重</h3><p>通过绘制决策树上的基尼系数的平均值来考察变量的重要性。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取重要度</span></span><br><span class="line">importance    &lt;- importance(rf_model)</span><br><span class="line">varImportance &lt;- data.frame(Variables = row.names(importance), </span><br><span class="line">                            Importance = <span class="built_in">round</span>(importance[ ,<span class="string">&#x27;MeanDecreaseGini&#x27;</span>],<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据重要度创建排名变量</span></span><br><span class="line">rankImportance &lt;- varImportance %&gt;%</span><br><span class="line">  mutate(Rank = paste0(<span class="string">&#x27;#&#x27;</span>,dense_rank(desc(Importance))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化重要性排名</span></span><br><span class="line">ggplot(rankImportance, aes(x = reorder(Variables, Importance), </span><br><span class="line">    y = Importance, fill = Importance)) +</span><br><span class="line">  geom_bar(stat=<span class="string">&#x27;identity&#x27;</span>) + </span><br><span class="line">  geom_text(aes(x = Variables, y = <span class="number">0.5</span>, label = Rank),</span><br><span class="line">    hjust=<span class="number">0</span>, vjust=<span class="number">0.55</span>, size = <span class="number">4</span>, colour = <span class="string">&#x27;red&#x27;</span>) +</span><br><span class="line">  labs(x = <span class="string">&#x27;Variables&#x27;</span>) +</span><br><span class="line">  coord_flip() + </span><br><span class="line">  theme_few()</span><br></pre></td></tr></table></figure><p>与乘客最终是否幸存影响最大的变量竟然是<code>Title</code>——也就是我们根据姓名创造出来的称谓这个变量！第二名是性别，第三名是船票费用，紧接着是年龄。而预想中关系密切的“船舱等级”竟然只排到第五位，这个结果令人惊讶。</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>训练出了模型，对测试集进行预测。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prediction &lt;- predict(rf_model, test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把结果保存至两列：乘客ID和是否生还</span></span><br><span class="line">solution &lt;- data.frame(PassengerID = test$PassengerId, Survived = prediction)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出至文件</span></span><br><span class="line">write.csv(solution, file = <span class="string">&#x27;rf_mod_Solution.csv&#x27;</span>, row.names = <span class="built_in">F</span>)</span><br></pre></td></tr></table></figure><p>上传，查看精度和排名。（作者的精度为0.80382）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><p>这篇kernel在特征工程上面花了比较多的心思。首先是根据姓名提取出了“称谓”这个变量，最后事实证明这是一个非常有效的变量。创建“家庭大小”这个变量也很有创意。之后创建了“是母亲”“是孩子”这两个有趣的变量，这是一个非常新颖的想法，我们可以融会贯通在别的实战项目里面运用类似的思想，说不定有奇效。</p></li><li><p>许多高精度的kernel证明了，对于这种变量很少的训练样本，多多进行特征工程、创造新的变量是王道。本kernel没有在选择模型以及调参方面作过多叙述，因为随机森林已经足够好。运用更加复杂的集成模型能给最终结果带来一定提升。</p></li><li><p>泰坦尼克号生还预测可谓是机器学习初学者必须亲手参与的经典入门试题，可以尝试更多的特征工程、运用不同的模型多加尝试。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> R </tag>
            
            <tag> 特征工程 </tag>
            
            <tag> 随机森林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
